<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patrons - React Version</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            scroll-behavior: smooth;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
        }
        
        html {
            scroll-behavior: smooth;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
        }
        
        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }
        
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(156, 163, 175, 0.5);
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(156, 163, 175, 0.8);
        }
        
        /* Improve rendering performance */
        .game-board {
            -webkit-transform: translateZ(0);
            -moz-transform: translateZ(0);
            -ms-transform: translateZ(0);
            -o-transform: translateZ(0);
            transform: translateZ(0);
            will-change: transform;
        }
        
        /* Smoother transitions for all interactive elements */
        button, .action-space, .player-card {
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        /* Better momentum scrolling for iOS */
        @supports (-webkit-overflow-scrolling: touch) {
            body {
                -webkit-overflow-scrolling: touch;
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
            }
        }
        
        /* Reduce animation conflicts during scrolling */
        @media (prefers-reduced-motion: no-preference) {
            .action-space:hover {
                transition: all 0.15s ease-out;
            }
            
            button:hover {
                transition: all 0.15s ease-out;
            }
        }
        
        /* For users who prefer reduced motion */
        @media (prefers-reduced-motion: reduce) {
            html {
                scroll-behavior: auto;
            }
            
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Player colors removed - no longer needed for worker display */
        /* .player-1 { background: #8e44ad !important; } */
        /* .player-2 { background: #27ae60 !important; } */
        /* .player-3 { background: #e67e22 !important; } */
        /* .player-4 { background: #2c3e50 !important; } */
        
        @keyframes pulse-blue {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
        }
        
        .pulse-current {
            animation: pulse-blue 2s infinite;
        }
        
        .glass {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-100 via-purple-100 to-pink-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useContext, createContext, useReducer, useEffect } = React;
        
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB0c0iUOG3llUzLd9FhQ6Qc1qCB0DoajVw",
            authDomain: "cornycolonies.firebaseapp.com",
            databaseURL: "https://cornycolonies-default-rtdb.firebaseio.com",
            projectId: "cornycolonies",
            storageBucket: "cornycolonies.firebasestorage.app",
            messagingSenderId: "566795956627",
            appId: "1:566795956627:web:585b66a3277696f3b0b866"
        };
        
        // Initialize Firebase (will use demo mode for now)
        let database = null;
        try {
            if (typeof firebase !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                database = firebase.database();
            }
        } catch (error) {
            console.log('Firebase not available, using local mode');
        }

        // Game Context
        const GameContext = createContext();

        // Fun emoji pool for players
        const PLAYER_EMOJIS = [
            '🦊', '🐸', '🦁', '🐼', '🦄', '🐙', '🦜', '🦋',
            '🐢', '🦉', '🐵', '🦒', '🐯', '🐨', '🦝', '🦌',
            '🐲', '🦅', '🦓', '🦘', '🦩', '🦥', '🦦', '🦭',
            '🎮', '🎲', '🎯', '🎪', '🎨', '🎭', '🎺', '🎸',
            '🚀', '🛸', '⚡', '🌟', '💎', '🔮', '🎃', '🌈'
        ];
        
        // Function to get random emojis for players
        function getRandomPlayerEmojis(playerCount = 4) {
            const shuffled = [...PLAYER_EMOJIS].sort(() => Math.random() - 0.5);
            return shuffled.slice(0, playerCount);
        }
        
        // Get initial emojis for players
        const initialPlayerEmojis = getRandomPlayerEmojis(4);
        
        const initialState = {
            // Game state
            currentPlayer: 1,
            turnDirection: 1,
            gameMode: null, // 'basic' or 'advanced' - set when game starts
            players: [
                { id: 1, name: "Player 1", emoji: initialPlayerEmojis[0], resources: { red: 0, yellow: 0, blue: 0, purple: 0, gold: 0, white: 0, black: 0, silver: 0 }, workersLeft: 4, effects: [], victoryPoints: 0, vpSources: {} },
                { id: 2, name: "Player 2", emoji: initialPlayerEmojis[1], resources: { red: 0, yellow: 0, blue: 0, purple: 0, gold: 0, white: 0, black: 0, silver: 0 }, workersLeft: 4, effects: [], victoryPoints: 0, vpSources: {} },
                { id: 3, name: "Player 3", emoji: initialPlayerEmojis[2], resources: { red: 0, yellow: 0, blue: 0, purple: 0, gold: 0, white: 0, black: 0, silver: 0 }, workersLeft: 4, effects: [], victoryPoints: 0, vpSources: {} },
                { id: 4, name: "Player 4", emoji: initialPlayerEmojis[3], resources: { red: 0, yellow: 0, blue: 0, purple: 0, gold: 0, white: 0, black: 0, silver: 0 }, workersLeft: 4, effects: [], victoryPoints: 0, vpSources: {} }
            ],
            occupiedSpaces: {},
            round: 1,
            turnOrder: [1, 2, 3, 4],
            workerPlacedThisTurn: false,
            workersToPlace: 1,
            shopUsedBeforeWorkers: false, // Track if shop was used before placing workers
            shopUsedAfterWorkers: false, // Track if shop was used after placing all workers
            modal: null,
            actionLog: [],
            gameLayers: null, // Will be set when game starts
            closedShops: {}, // Track which shops are closed { 'red1': true, 'blue2': true, etc }
            shopCostModifier: 0, // Cost modifier for shops this round
            skippedTurns: {}, // Track players who should skip turns { playerId: turnsToSkip }
            playersOutOfWorkers: [], // Track order players ran out of workers for purple VP
            waitingForOthers: {}, // Track players waiting for others to run out (purple R3)
            roundActions: [], // Track all actions taken this round for Red R3 shop
            
            // Multiplayer state
            roomCode: null,
            myPlayerId: null,
            myPlayerName: '',
            connectedPlayers: {},
            isHost: false,
            gameStarted: false,
            connectionStatus: 'disconnected' // 'disconnected', 'connecting', 'connected'
        };

        function gameReducer(state, action) {
            switch (action.type) {
                case 'PLACE_WORKER':
                    const newWorkersToPlace = Math.max(0, state.workersToPlace - 1);
                    const currentPlayerWorkers = state.players.find(p => p.id === state.currentPlayer).workersLeft - 1;
                    
                    return {
                        ...state,
                        occupiedSpaces: {
                            ...state.occupiedSpaces,
                            [action.actionId]: state.currentPlayer
                        },
                        players: state.players.map(player => 
                            player.id === state.currentPlayer 
                                ? { ...player, workersLeft: currentPlayerWorkers }
                                : player
                        ),
                        workerPlacedThisTurn: true,
                        workersToPlace: newWorkersToPlace,
                        roundActions: [...state.roundActions, { playerId: state.currentPlayer, actionId: action.actionId }]
                    };
                
                case 'UPDATE_RESOURCES':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { 
                                    ...player, 
                                    resources: {
                                        red: player.resources.red + (action.resources.red || 0),
                                        yellow: player.resources.yellow + (action.resources.yellow || 0),
                                        blue: player.resources.blue + (action.resources.blue || 0),
                                        purple: player.resources.purple + (action.resources.purple || 0),
                                        gold: player.resources.gold + (action.resources.gold || 0),
                                        white: player.resources.white + (action.resources.white || 0),
                                        black: player.resources.black + (action.resources.black || 0),
                                        silver: player.resources.silver + (action.resources.silver || 0)
                                    }
                                }
                                : player
                        )
                    };
                    
                case 'SET_RESOURCES':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, resources: action.resources }
                                : player
                        )
                    };
                
                // ADD_VICTORY_POINTS is deprecated - use UPDATE_VP instead
                case 'ADD_VICTORY_POINTS':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { 
                                    ...player, 
                                    victoryPoints: player.victoryPoints + action.points,
                                    vpSources: {
                                        ...player.vpSources,
                                        victoryShop: (player.vpSources?.victoryShop || 0) + action.points
                                    }
                                }
                                : player
                        )
                    };
                    
                case 'UPDATE_VP':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { 
                                    ...player, 
                                    victoryPoints: player.victoryPoints + action.vp,
                                    vpSources: {
                                        ...player.vpSources,
                                        [action.source || 'other']: (player.vpSources?.[action.source || 'other'] || 0) + action.vp
                                    }
                                }
                                : player
                        )
                    };
                
                case 'ADD_EFFECT':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, effects: [...(player.effects || []), action.effect] }
                                : player
                        )
                    };
                
                case 'UPDATE_PLAYER_EFFECTS':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, effects: action.effects }
                                : player
                        )
                    };
                
                case 'SET_WORKERS_TO_PLACE':
                    return {
                        ...state,
                        workersToPlace: action.count,
                        workerPlacedThisTurn: false
                    };
                
                case 'ADD_WORKERS_TO_PLACE':
                    return {
                        ...state,
                        workersToPlace: state.workersToPlace + action.count
                    };
                
                case 'END_TURN':
                    const currentPlayerObj = state.players.find(p => p.id === state.currentPlayer);
                    
                    // Track if player just ran out of workers
                    let newPlayersOutOfWorkers = [...state.playersOutOfWorkers];
                    if (currentPlayerObj.workersLeft === 0 && !newPlayersOutOfWorkers.includes(state.currentPlayer)) {
                        newPlayersOutOfWorkers.push(state.currentPlayer);
                    }
                    
                    // Purple VP: Check if this is first or last player to run out
                    const purpleVPUpdates = [];
                    const playersWithWorkers = state.players.filter(p => p.workersLeft > 0);
                    
                    // First player to run out gets 4 VP
                    if (newPlayersOutOfWorkers.length === 1 && newPlayersOutOfWorkers[0] === state.currentPlayer) {
                        purpleVPUpdates.push({ playerId: state.currentPlayer, vp: 4, reason: 'first to run out of workers' });
                    }
                    // Last player to run out gets 4 VP (when only 1 player left with workers)
                    if (playersWithWorkers.length === 1 && currentPlayerObj.workersLeft === 0) {
                        const lastPlayer = playersWithWorkers[0];
                        if (!newPlayersOutOfWorkers.includes(lastPlayer.id)) {
                            newPlayersOutOfWorkers.push(lastPlayer.id);
                            purpleVPUpdates.push({ playerId: lastPlayer.id, vp: 4, reason: 'last to run out of workers' });
                        }
                    }
                    
                    // Check for extra turn effect
                    const hasExtraTurn = currentPlayerObj.effects.some(effect => 
                        effect.includes('Will take an extra turn after this one')
                    );
                    
                    // Check if player has skipped turns
                    const hasSkippedTurns = state.skippedTurns[state.currentPlayer] > 0;
                    
                    if (hasExtraTurn) {
                        // Update skippedTurns - if player has skips, consume one instead of taking extra turn
                        const newSkippedTurns = { ...state.skippedTurns };
                        let logMessage = '';
                        
                        if (hasSkippedTurns) {
                            // Consume a skip instead of taking an extra turn
                            newSkippedTurns[state.currentPlayer]--;
                            logMessage = `Player ${state.currentPlayer}: Extra turn consumed by skip (${newSkippedTurns[state.currentPlayer]} skips remaining)`;
                        } else {
                            // No skips, so take the extra turn
                            logMessage = `Player ${state.currentPlayer}: Taking extra turn!`;
                        }
                        
                        // Remove the extra turn effect
                        const updatedPlayers = state.players.map(player => {
                            const vpUpdate = purpleVPUpdates.find(u => u.playerId === player.id);
                            return player.id === state.currentPlayer 
                                ? { 
                                    ...player, 
                                    effects: (player.effects || []).filter(effect => 
                                        !effect.includes('Will take an extra turn after this one')
                                    ),
                                    victoryPoints: player.victoryPoints + (vpUpdate ? vpUpdate.vp : 0)
                                }
                                : {
                                    ...player,
                                    victoryPoints: player.victoryPoints + (vpUpdate ? vpUpdate.vp : 0)
                                };
                        });
                        
                        // If player had skips, proceed to next player; otherwise stay on same player
                        if (hasSkippedTurns) {
                            // Continue to normal turn progression below
                        } else {
                            // Stay on same player for extra turn
                            return {
                                ...state,
                                players: updatedPlayers,
                                workerPlacedThisTurn: false,
                                workersToPlace: 1,
                                shopUsedBeforeWorkers: false,
                                shopUsedAfterWorkers: false,
                                playersOutOfWorkers: newPlayersOutOfWorkers,
                                skippedTurns: newSkippedTurns,
                                actionLog: [
                                    ...state.actionLog.slice(-9), 
                                    logMessage,
                                    ...purpleVPUpdates.map(u => `Player ${u.playerId}: +${u.vp} VP (${u.reason})`)
                                ].filter(Boolean)
                            };
                        }
                    }
                    
                    // If we processed an extra turn with skips above, use updated values
                    const effectiveSkippedTurns = hasExtraTurn && hasSkippedTurns 
                        ? { ...state.skippedTurns, [state.currentPlayer]: state.skippedTurns[state.currentPlayer] - 1 }
                        : state.skippedTurns;
                    const effectivePlayers = hasExtraTurn 
                        ? state.players.map(player => {
                            const vpUpdate = purpleVPUpdates.find(u => u.playerId === player.id);
                            return player.id === state.currentPlayer 
                                ? { 
                                    ...player, 
                                    effects: (player.effects || []).filter(effect => 
                                        !effect.includes('Will take an extra turn after this one')
                                    ),
                                    victoryPoints: player.victoryPoints + (vpUpdate ? vpUpdate.vp : 0)
                                }
                                : {
                                    ...player,
                                    victoryPoints: player.victoryPoints + (vpUpdate ? vpUpdate.vp : 0)
                                };
                        })
                        : state.players.map(player => {
                            const vpUpdate = purpleVPUpdates.find(u => u.playerId === player.id);
                            return vpUpdate ? {
                                ...player,
                                victoryPoints: player.victoryPoints + vpUpdate.vp
                            } : player;
                        });
                    
                    // Add log message if extra turn was consumed by skip
                    const extraTurnLogMessages = [];
                    if (hasExtraTurn && hasSkippedTurns) {
                        extraTurnLogMessages.push(`Player ${state.currentPlayer}: Extra turn consumed by skip (${effectiveSkippedTurns[state.currentPlayer]} skips remaining)`);
                    }
                    
                    // Check if any waiting players should now play all workers
                    let waitingPlayersUpdates = [];
                    let newWaitingForOthers = { ...state.waitingForOthers };
                    
                    // If all non-waiting players are out of workers, activate waiting players
                    const nonWaitingPlayersWithWorkers = state.players.filter(p => 
                        !state.waitingForOthers[p.id] && p.workersLeft > 0
                    );
                    
                    if (nonWaitingPlayersWithWorkers.length === 0) {
                        // All non-waiting players are out, activate waiting players
                        Object.keys(state.waitingForOthers).forEach(playerId => {
                            if (state.waitingForOthers[playerId]) {
                                const waitingPlayer = state.players.find(p => p.id === parseInt(playerId));
                                if (waitingPlayer && waitingPlayer.workersLeft > 0) {
                                    waitingPlayersUpdates.push({
                                        playerId: parseInt(playerId),
                                        workers: waitingPlayer.workersLeft
                                    });
                                    delete newWaitingForOthers[playerId];
                                }
                            }
                        });
                    }
                    
                    // Find next player considering skips and waiting players
                    let nextPlayer;
                    let nextDirection = state.turnDirection;
                    let attempts = 0;
                    const maxAttempts = state.players.length * 2;
                    
                    do {
                        const currentIndex = state.turnOrder.indexOf(attempts === 0 ? state.currentPlayer : nextPlayer);
                        
                        if (state.turnDirection === 1) {
                            if (currentIndex === state.turnOrder.length - 1) {
                                nextDirection = -1;
                                nextPlayer = state.turnOrder[currentIndex];
                            } else {
                                nextPlayer = state.turnOrder[currentIndex + 1];
                            }
                        } else {
                            if (currentIndex === 0) {
                                nextDirection = 1;
                                nextPlayer = state.turnOrder[currentIndex];
                            } else {
                                nextPlayer = state.turnOrder[currentIndex - 1];
                            }
                        }
                        
                        attempts++;
                        if (attempts > maxAttempts) break; // Prevent infinite loop
                        
                        // Check if player should skip
                        const shouldSkip = effectiveSkippedTurns[nextPlayer] > 0;
                        // Check if player is waiting for others
                        const isWaiting = newWaitingForOthers[nextPlayer];
                        // Check if player has workers
                        const hasWorkers = state.players.find(p => p.id === nextPlayer).workersLeft > 0;
                        
                    } while ((effectiveSkippedTurns[nextPlayer] > 0 || newWaitingForOthers[nextPlayer] || 
                             !state.players.find(p => p.id === nextPlayer).workersLeft > 0) && 
                             attempts < maxAttempts);
                    
                    // Update skip counts
                    const newSkippedTurns = { ...effectiveSkippedTurns };
                    if (newSkippedTurns[nextPlayer] > 0) {
                        newSkippedTurns[nextPlayer]--;
                    }
                    
                    // Set workers to place for waiting players who are now active
                    const waitingPlayerUpdate = waitingPlayersUpdates.find(u => u.playerId === nextPlayer);
                    const workersToPlace = waitingPlayerUpdate ? waitingPlayerUpdate.workers : 1;
                    
                    return {
                        ...state,
                        currentPlayer: nextPlayer,
                        turnDirection: nextDirection,
                        workerPlacedThisTurn: false,
                        workersToPlace: workersToPlace,
                        shopUsedBeforeWorkers: false,
                        shopUsedAfterWorkers: false,
                        skippedTurns: newSkippedTurns,
                        waitingForOthers: newWaitingForOthers,
                        playersOutOfWorkers: newPlayersOutOfWorkers,
                        players: effectivePlayers,
                        actionLog: [
                            ...state.actionLog.slice(-9),
                            ...extraTurnLogMessages,
                            ...purpleVPUpdates.map(u => `Player ${u.playerId}: +${u.vp} VP (${u.reason})`),
                            ...waitingPlayersUpdates.map(u => `Player ${u.playerId}: Can now play all ${u.workers} workers!`)
                        ].filter(Boolean)
                    };
                
                case 'ADVANCE_ROUND':
                    // Calculate automatic VPs before advancing round
                    const vpMessages = [];
                    const playersWithAutomaticVP = state.players.map(player => {
                        let vpGained = 0;
                        const newVpSources = { ...player.vpSources };
                        
                        // Yellow automatic VP - 1 VP per different color resource
                        const differentColors = Object.entries(player.resources)
                            .filter(([color, amount]) => amount > 0)
                            .length;
                        
                        if (differentColors > 0) {
                            vpGained += differentColors;
                            newVpSources.yellowDiversity = (player.vpSources?.yellowDiversity || 0) + differentColors;
                            vpMessages.push(`Player ${player.id}: +${differentColors} VP for ${differentColors} different color resources`);
                        }
                        
                        // Gold automatic VP - 1 VP per gold resource
                        const goldAmount = player.resources.gold || 0;
                        if (goldAmount > 0) {
                            vpGained += goldAmount;
                            newVpSources.goldAutomatic = (player.vpSources?.goldAutomatic || 0) + goldAmount;
                            vpMessages.push(`Player ${player.id}: +${goldAmount} VP for ${goldAmount} gold resources`);
                        }
                        
                        if (vpGained > 0) {
                            return {
                                ...player,
                                victoryPoints: player.victoryPoints + vpGained,
                                vpSources: newVpSources
                            };
                        }
                        return player;
                    });
                    
                    // SILVER automatic VP - Player(s) with most VP get 3 Silver, others get 2 VP
                    let maxVP = Math.max(...playersWithAutomaticVP.map(p => p.victoryPoints));
                    const playersWithMostVP = playersWithAutomaticVP.filter(p => p.victoryPoints === maxVP);
                    const playersWithMostVPIds = playersWithMostVP.map(p => p.id);
                    
                    const playersAfterSilverAuto = playersWithAutomaticVP.map(player => {
                        if (playersWithMostVPIds.includes(player.id)) {
                            // Players with most VP get 3 Silver
                            vpMessages.push(`Player ${player.id}: +3 Silver (most VP)`);
                            return {
                                ...player,
                                resources: {
                                    ...player.resources,
                                    silver: (player.resources.silver || 0) + 3
                                }
                            };
                        } else {
                            // Other players get 2 VP
                            vpMessages.push(`Player ${player.id}: +2 VP (Silver automatic)`);
                            return {
                                ...player,
                                victoryPoints: player.victoryPoints + 2,
                                vpSources: {
                                    ...player.vpSources,
                                    silverAutomatic: (player.vpSources?.silverAutomatic || 0) + 2
                                }
                            };
                        }
                    });
                    
                    // Open shops for the new round
                    const newRound = state.round + 1;
                    const updatedClosedShops = { ...state.closedShops };
                    const shopColors = ['red', 'yellow', 'blue', 'purple', 'gold', 'white', 'black', 'silver'];
                    
                    // Remove shops for the new round from closedShops (making them available)
                    shopColors.forEach(color => {
                        delete updatedClosedShops[`${color}${newRound}`];
                    });
                    
                    return {
                        ...state,
                        round: newRound,
                        closedShops: updatedClosedShops,
                        players: playersAfterSilverAuto.map(player => {
                            const baseWorkers = 3 + (state.round + 1);
                            const hasExtraWorkers = (player.effects || []).some(effect => 
                                effect.includes('Will get 2 extra workers next round')
                            );
                            const extraWorkers = hasExtraWorkers ? 2 : 0;
                            
                            return {
                                ...player,
                                workersLeft: baseWorkers + extraWorkers,
                                effects: (player.effects || []).filter(effect => 
                                    !effect.includes('Will get 2 extra workers next round')
                                )
                            };
                        }),
                        occupiedSpaces: {},
                        currentPlayer: 1,
                        turnDirection: 1,
                        workerPlacedThisTurn: false,
                        workersToPlace: 1,
                        shopUsedBeforeWorkers: false, // Reset shop usage for new round
                        shopUsedAfterWorkers: false, // Reset shop usage for new round
                        shopCostModifier: 0, // Reset cost modifier each round
                        playersOutOfWorkers: [], // Reset for new round
                        skippedTurns: {}, // Reset skip turns
                        waitingForOthers: {}, // Reset waiting status
                        roundActions: [], // Reset actions for new round
                        actionLog: [...state.actionLog.slice(-9), ...vpMessages, `Round ${state.round + 1} started! Extra workers applied.`]
                    };
                
                case 'ADD_LOG':
                    return {
                        ...state,
                        actionLog: [...state.actionLog.slice(-9), action.message] // Keep last 10 messages
                    };
                
                case 'RESET_GAME':
                    // Preserve player emojis on reset
                    const newEmojis = getRandomPlayerEmojis(4);
                    return {
                        ...initialState,
                        players: initialState.players.map((player, index) => ({
                            ...player,
                            emoji: action.preserveEmojis && state.players[index] ? state.players[index].emoji : newEmojis[index]
                        }))
                    };
                
                case 'SHOW_MODAL':
                    return {
                        ...state,
                        modal: action.modal
                    };
                
                case 'HIDE_MODAL':
                    return {
                        ...state,
                        modal: null
                    };
                
                case 'UPDATE_OCCUPIED_SPACES':
                    return {
                        ...state,
                        occupiedSpaces: action.occupiedSpaces
                    };
                
                case 'SET_TURN_ORDER':
                    return {
                        ...state,
                        turnOrder: action.turnOrder
                    };
                
                case 'CLOSE_SHOP':
                    return {
                        ...state,
                        closedShops: {
                            ...state.closedShops,
                            [action.shopId]: true
                        }
                    };
                
                case 'OPEN_SHOP':
                    // Remove the shop from closedShops (or set to false)
                    const newClosedShops = { ...state.closedShops };
                    delete newClosedShops[action.shopId];
                    return {
                        ...state,
                        closedShops: newClosedShops
                    };
                
                case 'FLIP_ALL_SHOPS':
                    const flippedShops = {};
                    // Flip all regular shops from active game layers only
                    const colors = state.gameLayers ? Object.keys(state.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
                    const rounds = [1, 2, 3];
                    colors.forEach(color => {
                        rounds.forEach(round => {
                            const shopId = `${color}${round}`;
                            flippedShops[shopId] = !state.closedShops[shopId];
                        });
                        // Also flip victory shops
                        const vpShopId = `${color}vp`;
                        flippedShops[vpShopId] = !state.closedShops[vpShopId];
                    });
                    return {
                        ...state,
                        closedShops: flippedShops
                    };
                
                case 'SET_SHOP_COST_MODIFIER':
                    return {
                        ...state,
                        shopCostModifier: action.modifier
                    };
                
                case 'ADD_SHOP_COST_MODIFIER':
                    return {
                        ...state,
                        shopCostModifier: state.shopCostModifier + action.modifier
                    };
                
                case 'USE_SHOP':
                    // Mark that shop was used appropriately
                    if (!state.workerPlacedThisTurn) {
                        // Used shop before placing any workers
                        return {
                            ...state,
                            shopUsedBeforeWorkers: true
                        };
                    } else if (state.workersToPlace === 0) {
                        // Used shop after placing all workers for turn
                        return {
                            ...state,
                            shopUsedAfterWorkers: true
                        };
                    }
                    return state;
                
                
                // Multiplayer actions
                case 'SET_ROOM_INFO':
                    return {
                        ...state,
                        roomCode: action.roomCode,
                        isHost: action.isHost
                    };
                
                case 'SET_MY_PLAYER_INFO':
                    return {
                        ...state,
                        myPlayerId: action.playerId,
                        myPlayerName: action.playerName
                    };
                
                case 'UPDATE_CONNECTED_PLAYERS':
                    return {
                        ...state,
                        connectedPlayers: action.connectedPlayers
                    };
                
                case 'START_GAME':
                    // Initialize future round shops as closed
                    const initialClosedShops = {};
                    const gameColors = state.gameLayers ? Object.keys(state.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
                    const currentRound = state.round || 1;
                    
                    gameColors.forEach(color => {
                        // Close shops from future rounds
                        if (currentRound < 2) initialClosedShops[`${color}2`] = true;
                        if (currentRound < 3) initialClosedShops[`${color}3`] = true;
                    });
                    
                    // WHITE AUTOMATIC VP: If white is in play, all players start with 5 VP
                    let playersWithInitialVP = state.players;
                    if (state.gameLayers && state.gameLayers.white) {
                        playersWithInitialVP = state.players.map(player => ({
                            ...player,
                            victoryPoints: player.victoryPoints + 5,
                            vpSources: {
                                ...player.vpSources,
                                whiteStarting: 5
                            }
                        }));
                    }
                    
                    return {
                        ...state,
                        gameStarted: true,
                        closedShops: initialClosedShops,
                        players: playersWithInitialVP
                    };
                
                case 'SET_GAME_LAYERS':
                    return {
                        ...state,
                        gameLayers: action.layers
                    };
                
                case 'SET_GAME_MODE':
                    return {
                        ...state,
                        gameMode: action.mode
                    };
                
                case 'UPDATE_CONNECTION_STATUS':
                    return {
                        ...state,
                        connectionStatus: action.status
                    };
                
                case 'SET_SKIPPED_TURNS':
                    return {
                        ...state,
                        skippedTurns: action.skippedTurns
                    };
                
                case 'SET_WAITING_FOR_OTHERS':
                    return {
                        ...state,
                        waitingForOthers: action.waitingForOthers
                    };
                
                case 'REMOVE_WORKER':
                    const newOccupiedSpaces = { ...state.occupiedSpaces };
                    delete newOccupiedSpaces[action.actionId];
                    return {
                        ...state,
                        occupiedSpaces: newOccupiedSpaces,
                        players: state.players.map(player => 
                            player.id === action.playerId
                                ? { ...player, workersLeft: player.workersLeft + 1 }
                                : player
                        )
                    };
                
                case 'SYNC_GAME_STATE':
                    // Merge remote game state while preserving local multiplayer state
                    return {
                        ...state,
                        ...action.gameState,
                        // Ensure all players have effects array
                        players: action.gameState.players ? action.gameState.players.map(player => ({
                            ...player,
                            effects: player.effects || [],
                            resources: {
                                red: 0, yellow: 0, blue: 0, purple: 0,
                                ...(player.resources || {})
                            }
                        })) : state.players,
                        roomCode: state.roomCode,
                        myPlayerId: state.myPlayerId,
                        myPlayerName: state.myPlayerName,
                        connectedPlayers: state.connectedPlayers,
                        isHost: state.isHost,
                        gameStarted: action.gameState.gameStarted !== undefined ? action.gameState.gameStarted : state.gameStarted,
                        connectionStatus: state.connectionStatus,
                        // Sync game layers if provided
                        gameLayers: action.gameState.gameLayers || state.gameLayers
                    };
                
                default:
                    return state;
            }
        }

        function GameProvider({ children }) {
            const [state, dispatch] = useReducer(gameReducer, initialState);
            
            return React.createElement(GameContext.Provider, { value: { state, dispatch } }, children);
        }

        function useGame() {
            const context = useContext(GameContext);
            if (!context) {
                throw new Error('useGame must be used within a GameProvider');
            }
            return context;
        }
        
        // Multiplayer Functions
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }
        
        function createRoom(dispatch, playerName) {
            const roomCode = generateRoomCode();
            const playerId = 1; // Host is always player 1
            
            if (database) {
                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connecting' });
                
                const roomRef = database.ref(`rooms/${roomCode}`);
                
                // Add timeout to prevent infinite loading
                const timeout = setTimeout(() => {
                    console.error('Room creation timeout');
                    alert('Failed to create room - connection timeout. Please try local mode or set up Firebase.');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                }, 5000); // 5 second timeout
                
                roomRef.set({
                    host: playerId,
                    gameState: {
                        ...initialState,
                        gameStarted: false
                    },
                    players: {
                        [playerId]: {
                            id: playerId,
                            name: playerName,
                            connected: true,
                            joinedAt: Date.now()
                        }
                    }
                }).then(() => {
                    clearTimeout(timeout);
                    dispatch({ type: 'SET_ROOM_INFO', roomCode, isHost: true });
                    dispatch({ type: 'SET_MY_PLAYER_INFO', playerId, playerName });
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connected' });
                    
                    // Listen for player updates
                    setupRoomListeners(roomCode, dispatch, playerId);
                }).catch(error => {
                    clearTimeout(timeout);
                    console.error('Error creating room:', error);
                    alert('Failed to create room. Firebase is not properly configured. Please use local mode for now.');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                });
            } else {
                alert('Multiplayer requires Firebase setup. Please use local mode for now.');
                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
            }
        }
        
        function joinRoom(dispatch, roomCode, playerName) {
            if (database) {
                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connecting' });
                
                // Add timeout to prevent infinite loading
                const timeout = setTimeout(() => {
                    console.error('Room join timeout');
                    alert('Failed to join room - connection timeout. Please try local mode or check the room code.');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                }, 5000); // 5 second timeout
                
                const roomRef = database.ref(`rooms/${roomCode}`);
                roomRef.once('value').then(snapshot => {
                    clearTimeout(timeout);
                    if (snapshot.exists()) {
                        const roomData = snapshot.val();
                        const players = roomData.players || {};
                        
                        // Find available player slot (1-4)
                        let playerId = null;
                        for (let i = 1; i <= 4; i++) {
                            if (!players[i] || !players[i].connected) {
                                playerId = i;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            // Join the room
                            roomRef.child(`players/${playerId}`).set({
                                id: playerId,
                                name: playerName,
                                connected: true,
                                joinedAt: Date.now()
                            }).then(() => {
                                dispatch({ type: 'SET_ROOM_INFO', roomCode, isHost: false });
                                dispatch({ type: 'SET_MY_PLAYER_INFO', playerId, playerName });
                                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connected' });
                                
                                // Load current game state
                                if (roomData.gameState) {
                                    dispatch({ type: 'SYNC_GAME_STATE', gameState: roomData.gameState });
                                }
                                
                                // Listen for updates
                                setupRoomListeners(roomCode, dispatch, playerId);
                            });
                        } else {
                            alert('Room is full (4 players max)');
                            dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                        }
                    } else {
                        alert('Room not found');
                        dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                    }
                }).catch(error => {
                    console.error('Error joining room:', error);
                    alert('Failed to join room');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                });
            } else {
                alert('Firebase not available. Using local mode.');
            }
        }
        
        function setupRoomListeners(roomCode, dispatch, myPlayerId) {
            if (!database) return;
            
            const roomRef = database.ref(`rooms/${roomCode}`);
            
            // Listen for player changes
            roomRef.child('players').on('value', snapshot => {
                const players = snapshot.val() || {};
                dispatch({ type: 'UPDATE_CONNECTED_PLAYERS', connectedPlayers: players });
                
                // Check if host disconnected and transfer host status
                const connectedPlayers = Object.values(players).filter(p => p.connected);
                const currentHost = connectedPlayers.find(p => p.id === 1);
                
                if (!currentHost && connectedPlayers.length > 0) {
                    // Original host (player 1) disconnected, make lowest ID the new host
                    const newHost = connectedPlayers.reduce((lowest, player) => 
                        player.id < lowest.id ? player : lowest
                    );
                    
                    if (newHost.id === myPlayerId) {
                        // I become the new host
                        dispatch({ type: 'SET_ROOM_INFO', roomCode: roomCode, isHost: true });
                        console.log(`Player ${myPlayerId} is now the host`);
                    }
                }
            });
            
            // Listen for game state changes
            roomRef.child('gameState').on('value', snapshot => {
                const gameState = snapshot.val();
                if (gameState) {
                    dispatch({ type: 'SYNC_GAME_STATE', gameState });
                }
            });
            
            // Handle disconnection
            roomRef.child(`players/${myPlayerId}/connected`).onDisconnect().set(false);
        }
        
        function syncGameState(roomCode, gameState) {
            if (database && roomCode) {
                database.ref(`rooms/${roomCode}/gameState`).set(gameState);
            }
        }
        
        function startMultiplayerGame(roomCode) {
            if (database && roomCode) {
                // Get current connected players and initialize proper game state
                database.ref(`rooms/${roomCode}/players`).once('value', (snapshot) => {
                    const connectedPlayers = snapshot.val() || {};
                    const playerCount = Object.keys(connectedPlayers).length;
                    
                    // Create proper player objects with all required fields
                    const players = [];
                    Object.values(connectedPlayers).forEach((player, index) => {
                        players.push({
                            id: player.id,
                            name: player.name,
                            resources: { red: 0, yellow: 0, blue: 0, purple: 0, gold: 0, white: 0, black: 0, silver: 0 },
                            workersLeft: 4,
                            effects: [],
                            victoryPoints: 0
                        });
                    });
                    
                    // Initialize complete game state
                    const gameState = {
                        currentPlayer: 1,
                        turnDirection: 1,
                        players: players,
                        occupiedSpaces: {},
                        round: 1,
                        turnOrder: players.map(p => p.id),
                        workerPlacedThisTurn: false,
                        workersToPlace: 1,
                        actionLog: [],
                        gameStarted: true
                    };
                    
                    database.ref(`rooms/${roomCode}/gameState`).set(gameState);
                });
            }
        }

        // Room Lobby Component
        function RoomLobby() {
            const { state, dispatch } = useGame();
            const [playerName, setPlayerName] = useState('');
            const [roomCodeInput, setRoomCodeInput] = useState('');
            const [mode, setMode] = useState('menu'); // 'menu', 'create', 'join', 'gameMode'
            const [selectedGameMode, setSelectedGameMode] = useState(null); // 'basic' or 'advanced'
            
            const handleCreateRoom = () => {
                if (!playerName.trim()) {
                    alert('Please enter your name');
                    return;
                }
                createRoom(dispatch, playerName.trim());
            };
            
            const handleJoinRoom = () => {
                if (!playerName.trim()) {
                    alert('Please enter your name');
                    return;
                }
                if (!roomCodeInput.trim()) {
                    alert('Please enter room code');
                    return;
                }
                joinRoom(dispatch, roomCodeInput.trim().toUpperCase(), playerName.trim());
            };
            
            const handlePlayLocal = () => {
                setMode('gameMode');
            };
            
            const handleStartWithMode = (gameMode) => {
                // For local play, use 4 players
                const selectedLayers = selectGameLayers(4, gameMode);
                dispatch({ type: 'SET_GAME_MODE', mode: gameMode });
                dispatch({ type: 'SET_GAME_LAYERS', layers: selectedLayers });
                dispatch({ type: 'START_GAME' });
            };
            
            return React.createElement('div', { 
                className: 'min-h-screen flex items-center justify-center p-4'
            }, React.createElement('div', {
                className: 'glass rounded-xl shadow-2xl p-8 max-w-md w-full'
            }, [
                React.createElement('div', { key: 'header', className: 'text-center mb-8' }, [
                    React.createElement('h1', { 
                        key: 'title',
                        className: 'text-3xl font-bold text-gray-800 mb-2' 
                    }, 'Patrons'),
                    React.createElement('p', { 
                        key: 'subtitle',
                        className: 'text-gray-600' 
                    }, 'Choose your game mode')
                ]),
                
                mode === 'menu' && React.createElement('div', { key: 'menu', className: 'space-y-4' }, [
                    React.createElement('input', {
                        key: 'name',
                        type: 'text',
                        placeholder: 'Enter your name',
                        value: playerName,
                        onChange: (e) => setPlayerName(e.target.value),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent'
                    }),
                    React.createElement('button', {
                        key: 'create',
                        onClick: () => setMode('create'),
                        className: 'w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, '🎮 Create Online Game'),
                    React.createElement('button', {
                        key: 'join',
                        onClick: () => setMode('join'),
                        className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, '🚪 Join Online Game'),
                    React.createElement('button', {
                        key: 'local',
                        onClick: handlePlayLocal,
                        className: 'w-full bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, '💻 Play Local (Same Device)')
                ]),
                
                mode === 'create' && React.createElement('div', { key: 'create', className: 'space-y-4' }, [
                    React.createElement('h3', { 
                        key: 'title',
                        className: 'text-xl font-bold text-center mb-4' 
                    }, 'Create Room'),
                    React.createElement('input', {
                        key: 'name',
                        type: 'text',
                        placeholder: 'Enter your name',
                        value: playerName,
                        onChange: (e) => setPlayerName(e.target.value),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent'
                    }),
                    React.createElement('button', {
                        key: 'create',
                        onClick: handleCreateRoom,
                        disabled: state.connectionStatus === 'connecting',
                        className: 'w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200 disabled:transform-none'
                    }, state.connectionStatus === 'connecting' ? 'Creating...' : 'Create Room'),
                    React.createElement('button', {
                        key: 'back',
                        onClick: () => setMode('menu'),
                        className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Back')
                ]),
                
                mode === 'join' && React.createElement('div', { key: 'join', className: 'space-y-4' }, [
                    React.createElement('h3', { 
                        key: 'title',
                        className: 'text-xl font-bold text-center mb-4' 
                    }, 'Join Room'),
                    React.createElement('input', {
                        key: 'name',
                        type: 'text',
                        placeholder: 'Enter your name',
                        value: playerName,
                        onChange: (e) => setPlayerName(e.target.value),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent'
                    }),
                    React.createElement('input', {
                        key: 'code',
                        type: 'text',
                        placeholder: 'Enter room code',
                        value: roomCodeInput,
                        onChange: (e) => setRoomCodeInput(e.target.value.toUpperCase()),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent'
                    }),
                    React.createElement('button', {
                        key: 'join',
                        onClick: handleJoinRoom,
                        disabled: state.connectionStatus === 'connecting',
                        className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200 disabled:transform-none'
                    }, state.connectionStatus === 'connecting' ? 'Joining...' : 'Join Room'),
                    React.createElement('button', {
                        key: 'back',
                        onClick: () => setMode('menu'),
                        className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Back')
                ]),
                
                mode === 'gameMode' && React.createElement('div', { key: 'gameMode', className: 'space-y-4' }, [
                    React.createElement('h3', { 
                        key: 'title',
                        className: 'text-xl font-bold text-center mb-4' 
                    }, 'Select Game Mode'),
                    React.createElement('div', { 
                        key: 'description',
                        className: 'text-sm text-gray-600 text-center mb-6 space-y-2' 
                    }, [
                        React.createElement('p', { key: 'basic' }, 
                            'Basic: Play with the classic 4 colors (Red, Yellow, Blue, Purple)'),
                        React.createElement('p', { key: 'advanced' }, 
                            'Advanced: Play with 4 randomly selected colors from all 8 available')
                    ]),
                    React.createElement('button', {
                        key: 'basic',
                        onClick: () => handleStartWithMode('basic'),
                        className: 'w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, '🎯 Basic Mode'),
                    React.createElement('button', {
                        key: 'advanced',
                        onClick: () => handleStartWithMode('advanced'),
                        className: 'w-full bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, '🚀 Advanced Mode'),
                    React.createElement('button', {
                        key: 'back',
                        onClick: () => setMode('menu'),
                        className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Back')
                ])
            ]));
        }
        
        // Connected Players Component
        function ConnectedPlayers() {
            const { state, dispatch } = useGame();
            const connectedCount = Object.keys(state.connectedPlayers).length;
            const [showGameModeSelection, setShowGameModeSelection] = useState(false);
            const [selectedGameMode, setSelectedGameMode] = useState('basic');
            
            const handleStartGame = () => {
                if (connectedCount >= 2) {
                    setShowGameModeSelection(true);
                } else {
                    alert('Need at least 2 players to start');
                }
            };
            
            const handleLeaveRoom = () => {
                if (confirm('Are you sure you want to leave the room?')) {
                    window.location.reload();
                }
            };
            
            // Only show the full connected players card before game starts
            if (!state.gameStarted) {
                return React.createElement('div', {
                    className: 'glass rounded-lg p-4 mb-6'
                }, [
                React.createElement('div', { key: 'header', className: 'flex justify-between items-center mb-4' }, [
                    React.createElement('div', { key: 'info' }, [
                        React.createElement('h3', { 
                            key: 'title',
                            className: 'text-lg font-bold text-gray-800' 
                        }, `Room: ${state.roomCode}`),
                        React.createElement('p', { 
                            key: 'count',
                            className: 'text-sm text-gray-600' 
                        }, `${connectedCount}/4 players connected`)
                    ]),
                    React.createElement('button', {
                        key: 'leave',
                        onClick: handleLeaveRoom,
                        className: 'bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm'
                    }, 'Leave')
                ]),
                React.createElement('div', { key: 'players', className: 'grid grid-cols-2 gap-2 mb-4' }, 
                    Object.values(state.connectedPlayers).map(player => 
                        React.createElement('div', {
                            key: player.id,
                            className: `p-2 rounded border-2 ${player.connected ? 'border-green-400 bg-green-50' : 'border-gray-300 bg-gray-50'} ${player.id === state.myPlayerId ? 'ring-2 ring-blue-400' : ''}`
                        }, [
                            React.createElement('div', { 
                                key: 'name',
                                className: 'font-semibold' 
                            }, `Player ${player.id}: ${player.name}`),
                            React.createElement('div', { 
                                key: 'status',
                                className: `text-xs ${player.connected ? 'text-green-600' : 'text-gray-500'}` 
                            }, player.connected ? '🟢 Connected' : '🔴 Disconnected'),
                            player.id === state.myPlayerId && React.createElement('div', { 
                                key: 'you',
                                className: 'text-xs text-blue-600 font-bold' 
                            }, '(You)')
                        ])
                    )
                ),
                state.isHost && !state.gameStarted && !showGameModeSelection && React.createElement('button', {
                    key: 'start',
                    onClick: handleStartGame,
                    disabled: connectedCount < 2,
                    className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200'
                }, connectedCount >= 2 ? 'Start Game' : 'Need 2+ Players to Start'),
                
                showGameModeSelection && React.createElement('div', { key: 'gameMode', className: 'space-y-3 mt-4' }, [
                    React.createElement('h4', { 
                        key: 'title',
                        className: 'text-md font-bold text-center' 
                    }, 'Select Game Mode'),
                    React.createElement('div', { key: 'buttons', className: 'flex gap-2' }, [
                        React.createElement('button', {
                            key: 'basic',
                            onClick: () => {
                                console.log('Starting game with', connectedCount, 'players in basic mode');
                                const selectedLayers = selectGameLayers(connectedCount, 'basic');
                                console.log('Selected layers:', Object.keys(selectedLayers));
                                dispatch({ type: 'SET_GAME_MODE', mode: 'basic' });
                                dispatch({ type: 'SET_GAME_LAYERS', layers: selectedLayers });
                                startMultiplayerGame(state.roomCode);
                                dispatch({ type: 'START_GAME' });
                                console.log('Game started successfully');
                            },
                            className: 'flex-1 bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-3 rounded-lg text-sm'
                        }, 'Basic'),
                        React.createElement('button', {
                            key: 'advanced',
                            onClick: () => {
                                console.log('Starting game with', connectedCount, 'players in advanced mode');
                                const selectedLayers = selectGameLayers(connectedCount, 'advanced');
                                console.log('Selected layers:', Object.keys(selectedLayers));
                                dispatch({ type: 'SET_GAME_MODE', mode: 'advanced' });
                                dispatch({ type: 'SET_GAME_LAYERS', layers: selectedLayers });
                                startMultiplayerGame(state.roomCode);
                                dispatch({ type: 'START_GAME' });
                                console.log('Game started successfully');
                            },
                            className: 'flex-1 bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-3 rounded-lg text-sm'
                        }, 'Advanced'),
                        React.createElement('button', {
                            key: 'cancel',
                            onClick: () => setShowGameModeSelection(false),
                            className: 'bg-gray-500 hover:bg-gray-600 text-white px-3 py-2 rounded-lg text-sm'
                        }, 'Cancel')
                    ])
                ])
            ]);
            }
            
            // During game, return null (room code will be shown in header)
            return null;
        }

        // Action Space Component - Enhanced with compact mode and round indicators
        function ActionSpace({ actionId, title, description, round, available = true, compact = false }) {
            const { state, dispatch } = useGame();
            const isOccupied = state.occupiedSpaces[actionId];
            const occupyingPlayer = isOccupied ? state.players.find(p => p.id === isOccupied) : null;
            
            const handleClick = async () => {
                if (isOccupied || !available) return;
                
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                if (currentPlayer.workersLeft <= 0) return;
                
                if (state.workersToPlace <= 0) {
                    alert('You have already placed all your workers this turn. End your turn or buy from shops.');
                    return;
                }
                
                dispatch({ type: 'PLACE_WORKER', actionId });
                
                // Get fresh state after worker placement for repeat actions
                const freshState = { ...state, occupiedSpaces: { ...state.occupiedSpaces, [actionId]: state.currentPlayer } };
                await executeAction(actionId, currentPlayer, dispatch, freshState, state.gameLayers);
                
                const message = `Action completed: ${actionId} for Player ${currentPlayer.id}`;
                dispatch({ type: 'ADD_LOG', message });
                console.log(message);
            };
            
            const getRoundStyle = () => {
                if (round === 1) return 'bg-gray-100 border-gray-300';
                if (round === 2) return 'bg-green-100 border-green-500';
                if (round === 3) return 'bg-yellow-100 border-yellow-500';
                return 'bg-gray-100 border-gray-300';
            };
            
            const getAvailabilityStyle = () => {
                if (!available) return 'opacity-40 cursor-not-allowed';
                if (isOccupied) return 'bg-red-100 border-red-400 cursor-not-allowed';
                return 'hover:bg-blue-50 hover:border-blue-400 cursor-pointer transform hover:scale-105';
            };
            
            const getRoundIndicator = () => {
                const baseStyle = "absolute top-1 left-1 px-2 py-1 rounded-full text-xs font-bold text-white";
                switch (round) {
                    case 1: return `${baseStyle} bg-gray-500`;
                    case 2: return `${baseStyle} bg-green-500`;
                    case 3: return `${baseStyle} bg-yellow-600`;
                    default: return `${baseStyle} bg-gray-500`;
                }
            };
            
            const getCardSize = () => {
                return compact ? 'p-2 min-h-14' : 'p-3 min-h-20';
            };
            
            const getTextSize = () => {
                return compact ? {
                    title: 'text-xs',
                    desc: 'text-xs'
                } : {
                    title: 'text-sm',
                    desc: 'text-xs'
                };
            };
            
            const textSizes = getTextSize();
            
            return React.createElement('div', {
                className: `relative ${getCardSize()} border-2 rounded-lg flex flex-col justify-center text-center transition-all duration-200 ${getRoundStyle()} ${getAvailabilityStyle()}`,
                onClick: handleClick
            }, [
                React.createElement('div', { key: 'title', className: `font-bold ${textSizes.title} mb-1 ${!available ? 'text-gray-500' : ''}` }, title),
                React.createElement('div', { key: 'desc', className: `${textSizes.desc} ${!available ? 'text-gray-400' : 'text-gray-600'} leading-tight` }, description),
                occupyingPlayer && React.createElement('div', {
                    key: 'worker',
                    className: `absolute top-1 right-1 flex items-center justify-center text-2xl`
                }, occupyingPlayer.emoji || occupyingPlayer.id),
                React.createElement('div', { 
                    key: 'round-indicator', 
                    className: getRoundIndicator() 
                }, `R${round}`)
            ]);
        }

        // Simplified action execution
        async function executeAction(actionId, player, dispatch, currentState, gameLayers, recursionDepth = 0) {
            // Prevent infinite loops
            if (recursionDepth > 5) {
                dispatch({ type: 'ADD_LOG', message: 'Max recursion depth reached - stopping to prevent infinite loop' });
                return;
            }
            
            const basicGains = {
                'gain3red': { red: 3 },
                'gain2red': { red: 2 },
                'gain3blue': { blue: 3 },
                'gain2blue': { blue: 2 },
                'gain3purple': { purple: 3 },
                'gain2purple': { purple: 2 },
                'gain2gold': { gold: 2 },
                'gain1gold': { gold: 1 },
                'gain3white': { white: 3 },
                'gain2white': { white: 2 },
                'gain3black': { black: 3 },
                'gain2black': { black: 2 },
                'gain3silver': { silver: 3 },
                'gain2silver': { silver: 2 }
                // Note: gain3yellow and gain2yellow are NOT basic gains - they have special logic
            };
            
            if (basicGains[actionId]) {
                let resources = { ...basicGains[actionId] };
                
                // Check for doubling effect
                const hasDoubleEffect = (player.effects || []).some(effect => effect.includes('Next gain will be doubled'));
                if (hasDoubleEffect) {
                    // Double all gains
                    Object.keys(resources).forEach(color => {
                        resources[color] *= 2;
                    });
                    
                    // Remove the doubling effect after use
                    dispatch({
                        type: 'UPDATE_PLAYER_EFFECTS',
                        playerId: player.id,
                        effects: (player.effects || []).filter(effect => !effect.includes('Next gain will be doubled'))
                    });
                    
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')} (DOUBLED!)`;
                    dispatch({ type: 'ADD_LOG', message });
                } else {
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: resources
                });
                
                // RED AUTOMATIC VP: Award 1 VP for red layer actions
                if (actionId.includes('red')) {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: player.id,
                        vp: 1,
                        source: 'redAction'
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action` });
                }
                
                return;
            }
            
            // Yellow layer actions with player choice
            if (actionId === 'gain3yellow') {
                const selectedGems = await showGemSelection(dispatch, 'Select 3 Resources (⭐ Colors)', 3);
                
                if (!selectedGems) {
                    // If cancelled, give default resources
                    const resources = { red: 1, yellow: 1, blue: 1 };
                    dispatch({ type: 'GAIN_RESOURCES', playerId: player.id, resources });
                    return;
                }
                
                const resources = selectedGems;
                
                // Check for doubling effect
                const hasDoubleEffect = (player.effects || []).some(effect => effect.includes('Next gain will be doubled'));
                if (hasDoubleEffect) {
                    // Double all gains
                    Object.keys(resources).forEach(color => {
                        resources[color] *= 2;
                    });
                    
                    // Remove the doubling effect after use
                    dispatch({
                        type: 'UPDATE_PLAYER_EFFECTS',
                        playerId: player.id,
                        effects: (player.effects || []).filter(effect => !effect.includes('Next gain will be doubled'))
                    });
                    
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')} (DOUBLED!)`;
                    dispatch({ type: 'ADD_LOG', message });
                } else {
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources
                });
                return;
            }
            
            // Similar implementation for gain2yellow
            if (actionId === 'gain2yellow') {
                const selectedGems = await showGemSelection(dispatch, 'Select 2 Resources (⭐ Colors)', 2);
                
                if (!selectedGems) {
                    // If cancelled, give default resources
                    const resources = { red: 1, yellow: 1 };
                    dispatch({ type: 'GAIN_RESOURCES', playerId: player.id, resources });
                    return;
                }
                
                const resources = selectedGems;
                
                // Check for doubling effect
                const hasDoubleEffect = (player.effects || []).some(effect => effect.includes('Next gain will be doubled'));
                if (hasDoubleEffect) {
                    // Double all gains
                    Object.keys(resources).forEach(color => {
                        resources[color] *= 2;
                    });
                    
                    // Remove the doubling effect after use
                    dispatch({
                        type: 'UPDATE_PLAYER_EFFECTS',
                        playerId: player.id,
                        effects: (player.effects || []).filter(effect => !effect.includes('Next gain will be doubled'))
                    });
                    
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')} (DOUBLED!)`;
                    dispatch({ type: 'ADD_LOG', message });
                } else {
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources
                });
                return;
            }
            
            
            // Purple layer - Play two workers (immediately)
            if (actionId === 'playTwoWorkers') {
                // Add 2 more workers that can be placed this turn
                dispatch({
                    type: 'ADD_WORKERS_TO_PLACE',
                    count: 2
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Can place 2 more workers this turn'
                });
                
                const message = `Player ${player.id}: playTwoWorkers → Can now place 2 MORE workers this turn`;
                dispatch({ type: 'ADD_LOG', message });
                console.log(message);
                return;
            }
            
            // NEW PURPLE LAYER ACTIONS
            if (actionId === 'gain4purpleSkip') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 4 }
                });
                
                // Set skip for next turn
                const newSkippedTurns = { ...currentState.skippedTurns };
                newSkippedTurns[player.id] = (newSkippedTurns[player.id] || 0) + 1;
                dispatch({
                    type: 'SET_SKIPPED_TURNS',
                    skippedTurns: newSkippedTurns
                });
                
                const message = `Player ${player.id}: gain4purpleSkip → +4 purple, will skip next turn`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (actionId === 'gain2purpleTakeBack') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 2 }
                });
                
                // Find workers on different quad (non-purple)
                const occupiedByPlayer = Object.entries(currentState.occupiedSpaces || {})
                    .filter(([actionId, playerId]) => {
                        if (playerId !== player.id) return false;
                        // Check if this action is in the purple quad
                        const actionData = Object.values(currentState.gameSetup.actions).flat()
                            .find(action => action.id === actionId);
                        const isPurpleAction = actionData && Object.keys(currentState.gameSetup.actions)
                            .find(quadType => currentState.gameSetup.actions[quadType]
                                .some(a => a.id === actionId)) === 'purple';
                        return !isPurpleAction;
                    });
                
                if (occupiedByPlayer.length > 0) {
                    // Group by layer
                    const workersByLayer = {};
                    occupiedByPlayer.forEach(([actionId, playerId]) => {
                        const layer = Object.keys(gameLayers).find(color => 
                            gameLayers[color].actions.some(a => a.id === actionId)
                        );
                        if (layer) {
                            if (!workersByLayer[layer]) workersByLayer[layer] = [];
                            workersByLayer[layer].push(actionId);
                        }
                    });
                    
                    // Show options from different layers
                    const options = [];
                    Object.entries(workersByLayer).forEach(([layer, actions]) => {
                        actions.forEach(actionId => {
                            const action = gameLayers[layer].actions.find(a => a.id === actionId);
                            if (action) {
                                options.push({
                                    label: `${layer} - ${action.title}`,
                                    value: actionId
                                });
                            }
                        });
                    });
                    
                    if (options.length > 0) {
                        const choice = await showChoice(dispatch, 'Choose a worker to take back', options);
                        if (choice) {
                            // Remove worker and give it back
                            dispatch({
                                type: 'REMOVE_WORKER',
                                actionId: choice,
                                playerId: player.id
                            });
                            dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Took back worker from ${choice}` });
                        }
                    }
                }
                
                const message = `Player ${player.id}: gain2purpleTakeBack → +2 purple + take back worker`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (actionId === 'gain5purpleSkip') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 5 }
                });
                
                // Set skip for this turn (immediately)
                const newSkippedTurns = { ...currentState.skippedTurns };
                newSkippedTurns[player.id] = (newSkippedTurns[player.id] || 0) + 1;
                dispatch({
                    type: 'SET_SKIPPED_TURNS',
                    skippedTurns: newSkippedTurns
                });
                
                const message = `Player ${player.id}: gain5purpleSkip → +5 purple, skipping turn`;
                dispatch({ type: 'ADD_LOG', message });
                
                // Force end turn
                setTimeout(() => dispatch({ type: 'END_TURN' }), 100);
                return;
            }
            
            if (actionId === 'playThreeWorkers') {
                // Add 3 more workers that can be placed this turn
                dispatch({
                    type: 'ADD_WORKERS_TO_PLACE',
                    count: 3
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Can place 3 more workers this turn'
                });
                
                const message = `Player ${player.id}: playThreeWorkers → Can now place 3 MORE workers this turn`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (actionId === 'gain4purpleWaitAll') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 4 }
                });
                
                // Set waiting status
                const newWaitingForOthers = { ...currentState.waitingForOthers };
                newWaitingForOthers[player.id] = true;
                dispatch({
                    type: 'SET_WAITING_FOR_OTHERS',
                    waitingForOthers: newWaitingForOthers
                });
                
                const message = `Player ${player.id}: gain4purpleWaitAll → +4 purple, waiting for others to run out`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Purple layer - Extra workers next round
            if (actionId === 'extraWorkers') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 1 }
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Will get 2 extra workers next round'
                });
                
                console.log(`Player ${player.id} will get 2 extra workers next round`);
                return;
            }
            
            // Purple layer - ⭐ Round 1 Shop Benefit
            if (actionId === 'purpleShopHybrid') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 1 }
                });
                
                const shopOptions = [
                    { label: '🔴 R1: Repeat worker action', value: 'red1' },
                    { label: '🟡 R1: Double next gain', value: 'yellow1' },
                    { label: '🔵 R1: Close ⭐ shop this round', value: 'blue1' },
                    { label: '🟣 R1: Take an extra turn after this one', value: 'purple1' }
                ];
                
                const choice = await showChoice(dispatch, 
                    'Choose ⭐ Round 1 shop benefit', 
                    shopOptions
                );
                
                if (choice) {
                    switch(choice) {
                        case 'red1':
                            // Execute repeat action immediately
                            await executeRepeatAction(player, dispatch, currentState, gameLayers);
                            break;
                        case 'yellow1':
                            dispatch({
                                type: 'ADD_EFFECT',
                                playerId: player.id,
                                effect: 'Next gain will be doubled'
                            });
                            break;
                        case 'blue1':
                            dispatch({
                                type: 'ADD_EFFECT',
                                playerId: player.id,
                                effect: 'Can close ⭐ shop this round'
                            });
                            break;
                        case 'purple1':
                            dispatch({
                                type: 'ADD_EFFECT',
                                playerId: player.id,
                                effect: 'Will take an extra turn after this one'
                            });
                            break;
                    }
                    
                    const effectNames = {
                        'red1': 'Repeat worker action',
                        'yellow1': 'Double next gain',
                        'blue1': 'Close shop ability',
                        'purple1': 'Extra turn'
                    };
                    
                    const message = `Player ${player.id}: purpleShopHybrid → +1 purple + ${effectNames[choice]}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                return;
            }
            
            // Purple layer - Choose turn order
            if (actionId === 'purpleHybrid2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 1 }
                });
                
                const orderOptions = [
                    { label: '1 → 2 → 3 → 4', value: [1, 2, 3, 4] },
                    { label: '4 → 3 → 2 → 1', value: [4, 3, 2, 1] },
                    { label: '2 → 1 → 4 → 3', value: [2, 1, 4, 3] },
                    { label: '3 → 4 → 1 → 2', value: [3, 4, 1, 2] }
                ];
                
                const newOrder = await showChoice(dispatch, 
                    'Choose new turn order for next round', 
                    orderOptions
                );
                
                if (newOrder) {
                    // Apply the turn order change immediately for next round
                    dispatch({
                        type: 'SET_TURN_ORDER',
                        turnOrder: newOrder
                    });
                    
                    const message = `Player ${player.id}: purpleHybrid2 → +1 purple + set turn order to ${newOrder.join(' → ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                return;
            }
            
            // Red layer - Repeat an action
            if (actionId === 'redRepeatAction') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { red: 1 }
                });
                
                // RED AUTOMATIC VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action` });
                
                const logMessage = `DEBUG: Occupied spaces: ${JSON.stringify(currentState.occupiedSpaces)}`;
                dispatch({ type: 'ADD_LOG', message: logMessage });
                
                // Find all occupied spaces that belong to the current player (excluding this repeat action)
                const playerSpaces = Object.entries(currentState.occupiedSpaces)
                    .filter(([spaceId, playerId]) => playerId === player.id && spaceId !== 'redRepeatAction')
                    .map(([spaceId]) => spaceId);
                
                const debugMessage = `DEBUG: Player spaces to repeat: ${playerSpaces.join(', ')}`;
                dispatch({ type: 'ADD_LOG', message: debugMessage });
                
                if (playerSpaces.length === 0) {
                    const message = `Player ${player.id}: redRepeatAction → +1 red (no other workers to repeat)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                if (playerSpaces.length === 1) {
                    // Only one option, auto-select it
                    const spaceId = playerSpaces[0];
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    
                    const message = `Player ${player.id}: redRepeatAction → +1 red + repeating ${actionTitle}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    // Execute the action again
                    await executeAction(spaceId, player, dispatch, currentState, gameLayers, recursionDepth + 1);
                    return;
                }
                
                // Multiple options, let player choose
                const repeatOptions = playerSpaces.map(spaceId => {
                    // Find the action details
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    return {
                        label: `Repeat: ${actionTitle}`,
                        value: spaceId
                    };
                });
                
                const choice = await showChoice(dispatch, 
                    'Choose an action to repeat', 
                    repeatOptions
                );
                
                if (choice) {
                    const message = `Player ${player.id}: redRepeatAction → +1 red + repeating ${choice}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    // Execute the chosen action again
                    await executeAction(choice, player, dispatch, currentState, gameLayers, recursionDepth + 1);
                }
                return;
            }
            
            // RED LAYER ACTIONS
            
            // Red hybrid actions - swap workers
            if (actionId === 'redHybrid1' || actionId === 'redHybrid2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { red: 1 }
                });
                
                // RED AUTOMATIC VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action` });
                
                // Find workers that can be swapped
                const allWorkers = Object.entries(currentState.occupiedSpaces);
                if (allWorkers.length < 2) {
                    const message = `Player ${player.id}: ${actionId} → +1 red (not enough workers to swap)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const workerOptions = allWorkers.map(([spaceId, playerId]) => ({
                    label: `Player ${playerId}'s worker on ${spaceId}`,
                    value: { spaceId, playerId }
                }));
                
                const worker1 = await showChoice(dispatch, 'Choose first worker to swap', workerOptions);
                if (!worker1) return;
                
                const remainingWorkers = workerOptions.filter(w => 
                    !(w.value.spaceId === worker1.spaceId && w.value.playerId === worker1.playerId)
                );
                
                const worker2 = await showChoice(dispatch, 'Choose second worker to swap', remainingWorkers);
                if (!worker2) return;
                
                // Perform the swap
                const newOccupiedSpaces = { ...currentState.occupiedSpaces };
                newOccupiedSpaces[worker1.spaceId] = worker2.playerId;
                newOccupiedSpaces[worker2.spaceId] = worker1.playerId;
                
                dispatch({
                    type: 'UPDATE_OCCUPIED_SPACES',
                    occupiedSpaces: newOccupiedSpaces
                });
                
                // Execute actions for the affected players
                if (actionId === 'redHybrid1') {
                    // Both players get actions
                    await executeAction(worker1.spaceId, currentState.players.find(p => p.id === worker2.playerId), dispatch, currentState, gameLayers, recursionDepth + 1);
                    await executeAction(worker2.spaceId, currentState.players.find(p => p.id === worker1.playerId), dispatch, currentState, gameLayers, recursionDepth + 1);
                } else {
                    // Only current player gets actions
                    await executeAction(worker1.spaceId, player, dispatch, currentState, gameLayers, recursionDepth + 1);
                    await executeAction(worker2.spaceId, player, dispatch, currentState, gameLayers, recursionDepth + 1);
                }
                
                const message = `Player ${player.id}: ${actionId} → +1 red + swapped workers`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Force red placement
            if (actionId === 'forceRedPlacement') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { red: 1 }
                });
                
                // RED AUTOMATIC VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action` });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Other players must place on red layer until full'
                });
                
                const message = `Player ${player.id}: forceRedPlacement → +1 red + forcing red placement`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Red R3 - Repeat all your worker actions
            if (actionId === 'redRepeatAll') {
                // RED AUTOMATIC VP for the action itself
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action` });
                
                // Find all spaces occupied by current player
                const playerSpaces = Object.entries(currentState.occupiedSpaces)
                    .filter(([spaceId, occupyingPlayerId]) => occupyingPlayerId === player.id && spaceId !== 'redRepeatAll')
                    .map(([spaceId]) => spaceId);
                
                if (playerSpaces.length === 0) {
                    const message = `Player ${player.id}: redRepeatAll → No other workers to repeat`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: redRepeatAll → Repeating ${playerSpaces.length} actions` });
                
                // Execute each action (this will also award VP for red actions)
                for (const spaceId of playerSpaces) {
                    await executeAction(spaceId, player, dispatch, currentState, gameLayers, recursionDepth + 1);
                }
                
                return;
            }
            
            // YELLOW LAYER ACTIONS
            
            // Steal resource actions
            if (actionId === 'steal2Gems' || actionId === 'steal3Gems') {
                const stealCount = actionId === 'steal2Gems' ? 2 : 3;
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                
                if (otherPlayers.length === 0) {
                    const message = `Player ${player.id}: ${actionId} → No other players to steal from`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Filter players who have resources
                const targetOptions = otherPlayers
                    .filter(p => Object.values(p.resources).some(amount => amount > 0))
                    .map(p => ({
                        label: `Player ${p.id} (${Object.entries(p.resources).filter(([,amt]) => amt > 0).map(([color, amt]) => `${amt} ${color}`).join(', ')})`,
                        value: p.id
                    }));
                
                if (targetOptions.length === 0) {
                    const message = `Player ${player.id}: ${actionId} → No players have resources to steal`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Choose target player
                const targetId = await showChoice(dispatch, 'Choose player to steal from', targetOptions);
                if (!targetId) {
                    const message = `Player ${player.id}: ${actionId} → Cancelled`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const targetPlayer = otherPlayers.find(p => p.id === targetId);
                
                // Use the StealGemsModal to select resources
                const selectedGems = await showStealGems(
                    dispatch, 
                    `Steal up to ${stealCount} resources from Player ${targetId}`,
                    targetPlayer,
                    stealCount
                );
                
                if (!selectedGems) {
                    const message = `Player ${player.id}: ${actionId} → Cancelled`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Transfer the resources
                const stolenResources = [];
                Object.entries(selectedGems).forEach(([color, count]) => {
                    if (count > 0) {
                        dispatch({
                            type: 'UPDATE_RESOURCES',
                            playerId: targetId,
                            resources: { [color]: -count }
                        });
                        
                        dispatch({
                            type: 'UPDATE_RESOURCES',
                            playerId: player.id,
                            resources: { [color]: count }
                        });
                        
                        stolenResources.push(`${count} ${color}`);
                    }
                });
                
                const message = `Player ${player.id}: ${actionId} → Stole ${stolenResources.join(', ')} from Player ${targetId}`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Yellow hybrid actions
            if (actionId === 'yellowHybrid1') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { yellow: 1 }
                });
                
                // Trade any number of resources
                const totalGems = Object.values(player.resources).reduce((sum, amount) => sum + amount, 0);
                if (totalGems === 0) {
                    const message = `Player ${player.id}: yellowHybrid1 → +1 yellow (no resources to trade)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Ask how many resources to trade
                const numberOptions = [];
                for (let i = 1; i <= Math.min(totalGems, 10); i++) {
                    numberOptions.push({ label: `Trade ${i} resource${i > 1 ? 's' : ''}`, value: i });
                }
                
                const numberToTrade = await showChoice(dispatch, 'How many resources do you want to trade?', numberOptions);
                if (!numberToTrade) {
                    const message = `Player ${player.id}: yellowHybrid1 → +1 yellow (no trade)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Choose resources to trade away
                const tradeCost = {};
                for (let i = 0; i < numberToTrade; i++) {
                    const availableColors = Object.entries(player.resources)
                        .filter(([color, amount]) => amount + (tradeCost[color] || 0) > 0)
                        .map(([color, amount]) => ({
                            label: `${color.charAt(0).toUpperCase() + color.slice(1)} (${amount + (tradeCost[color] || 0)} available)`,
                            value: color
                        }));
                    
                    const colorToTrade = await showChoice(dispatch, `Choose resource to trade away (${i + 1}/${numberToTrade})`, availableColors);
                    if (colorToTrade) {
                        tradeCost[colorToTrade] = (tradeCost[colorToTrade] || 0) - 1;
                    }
                }
                
                // Choose resources to gain (same number) using GemSelectionModal
                const gemsToGain = await showGemSelection(
                    dispatch,
                    `Choose ${numberToTrade} resource${numberToTrade > 1 ? 's' : ''} to gain`,
                    numberToTrade
                );
                
                if (!gemsToGain) {
                    const message = `Player ${player.id}: yellowHybrid1 → +1 yellow (trade cancelled)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const tradeGain = gemsToGain;
                
                // Apply the trade
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { ...tradeCost, ...tradeGain }
                });
                
                const message = `Player ${player.id}: yellowHybrid1 → +1 yellow + traded ${numberToTrade} resources`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (actionId === 'yellowHybrid2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { yellow: 1 }
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Next gain will be doubled'
                });
                
                const message = `Player ${player.id}: yellowHybrid2 → +1 yellow + next gain doubled`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Yellow R3 - Swap all resources with another player
            if (actionId === 'yellowSwapResources') {
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                
                if (otherPlayers.length === 0) {
                    const message = `Player ${player.id}: yellowSwapResources → No other players to swap with`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const swapOptions = otherPlayers.map(p => ({
                    label: `Player ${p.id} (${Object.entries(p.resources).filter(([,amt]) => amt > 0).map(([color, amt]) => `${amt} ${color}`).join(', ') || 'no resources'})`,
                    value: p.id
                }));
                
                const targetPlayerId = await showChoice(dispatch, 'Choose player to swap all resources with', swapOptions);
                
                if (targetPlayerId) {
                    const targetPlayer = otherPlayers.find(p => p.id === targetPlayerId);
                    const playerResources = { ...player.resources };
                    const targetResources = { ...targetPlayer.resources };
                    
                    // Swap resources
                    dispatch({
                        type: 'SET_RESOURCES',
                        playerId: player.id,
                        resources: targetResources
                    });
                    
                    dispatch({
                        type: 'SET_RESOURCES',
                        playerId: targetPlayerId,
                        resources: playerResources
                    });
                    
                    const message = `Player ${player.id}: yellowSwapResources → Swapped all resources with Player ${targetPlayerId}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                return;
            }
            
            // BLUE LAYER ACTIONS
            
            // Blue shop benefit actions - gain any shop benefit even if closed
            // Blue R1 shop benefit action
            if (actionId === 'blueR1ShopBenefit') {
                // List all available R1 shops from active game layers only
                const shopOptions = [];
                const colors = currentState.gameLayers ? Object.keys(currentState.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
                
                const colorEmojis = {
                    red: '🔴', yellow: '🟡', blue: '🔵', purple: '🟣',
                    gold: '🟨', white: '⚪', black: '⚫', silver: '🩶'
                };
                
                const quadGroups = {
                    'red': 'Red/Yellow',
                    'yellow': 'Red/Yellow',
                    'blue': 'Blue/Purple',
                    'purple': 'Blue/Purple',
                    'gold': 'Gold/White',
                    'white': 'Gold/White',
                    'black': 'Black/Silver',
                    'silver': 'Black/Silver'
                };
                
                colors.forEach(color => {
                    // Get shop data for description
                    const shopInfo = {
                        red: { 1: 'Repeat a worker\'s action' },
                        yellow: { 1: 'Double your next gain action' },
                        blue: { 1: 'Close any shop this round' },
                        purple: { 1: 'Take an extra turn after this one' },
                        gold: { 1: '1 Gold + 1 ⭐ = 2 Gold' },
                        white: { 1: 'Lose 1 VP, Gain 1 ⚪' },
                        black: { 1: 'Destroy 2 resources from any player' },
                        silver: { 1: 'Look at and rearrange turn order' }
                    };
                    
                    const group = quadGroups[color];
                    
                    shopOptions.push({
                        label: `${color} R1: ${shopInfo[color][1]}`,
                        shortLabel: `${colorEmojis[color]} ${shopInfo[color][1]}`,
                        value: { color, round: 1 },
                        group: group
                    });
                });
                
                const choice = await showChoice(dispatch, 'Choose any R1 shop benefit (ignores closed status)', shopOptions, true);
                
                if (choice) {
                    // Execute the shop benefit without paying cost
                    await executeShopBenefit(choice.color, choice.round, player, dispatch, state);
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Executed ${choice.color} R1 shop benefit` });
                    
                    // BLUE AUTOMATIC VP: Player gets 1 VP when using any shop benefit
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: player.id,
                        vp: 1,
                        source: 'blueShopUsage'
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP (used a shop benefit)` });
                }
                
                return;
            }
            
            // Blue any shop benefit action (R3)
            if (actionId === 'blueAnyShopBenefit') {
                // List all available shops from active game layers only
                const shopOptions = [];
                const colors = currentState.gameLayers ? Object.keys(currentState.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
                
                const shopInfo = {
                    red: {
                        1: 'Repeat a worker\'s action',
                        2: 'Place the next player\'s worker',
                        3: 'Repeat all actions taken this round'
                    },
                    yellow: {
                        1: 'Double your next gain action',
                        2: 'Gain 5⭐',
                        3: 'Gain 9⭐'
                    },
                    blue: {
                        1: 'Close any shop this round',
                        2: 'Flip all shops status',
                        3: 'Gain any shop benefit'
                    },
                    purple: {
                        1: 'Take an extra turn',
                        2: 'Play 2 more workers',
                        3: 'Play all remaining workers'
                    },
                    gold: {
                        1: '1 Gold + 1 ⭐ = 2 Gold',
                        2: '2 Gold + 2 ⭐ = 4 Gold',
                        3: '3 Gold + 3 ⭐ = Double Your Gold'
                    },
                    white: {
                        1: 'Cost 1 VP + 1 ⭐ = Lose 1 VP, Gain 1 ⭐',
                        2: 'Cost 3 VP + 2 ⭐ = Lose 3 VP, Skip Next Player\'s Turn',
                        3: 'Cost 5 VP + 3 ⭐ = Lose 5 VP, Move Worker to Unclaimed Action'
                    },
                    black: {
                        1: 'Destroy 2 gems from any player',
                        2: 'Curse a player: -1 to all gains',
                        3: 'All players lose 3 gems of your choice'
                    },
                    silver: {
                        1: '1 Silver + 1 ⭐ = 2 VP',
                        2: 'Gain 4 VP, Pick Another Player to Gain 4 VP',
                        3: 'Gain 7 Silver, Each Other Player Gains 2 Silver'
                    }
                };
                
                const colorEmojis = {
                    red: '🔴', yellow: '🟡', blue: '🔵', purple: '🟣',
                    gold: '🟨', white: '⚪', black: '⚫', silver: '🩶'
                };
                
                const quadGroups = {
                    'red': 'Red/Yellow',
                    'yellow': 'Red/Yellow',
                    'blue': 'Blue/Purple',
                    'purple': 'Blue/Purple',
                    'gold': 'Gold/White',
                    'white': 'Gold/White',
                    'black': 'Black/Silver',
                    'silver': 'Black/Silver'
                };
                
                colors.forEach(color => {
                    const group = quadGroups[color];
                    
                    // R1 shops
                    shopOptions.push({
                        label: `${color} R1: ${shopInfo[color][1]}`,
                        shortLabel: `R1: ${colorEmojis[color]} ${shopInfo[color][1].substring(0, 20)}...`,
                        value: { color, round: 1 },
                        group: group
                    });
                    // R2 shops
                    shopOptions.push({
                        label: `${color} R2: ${shopInfo[color][2]}`,
                        shortLabel: `R2: ${colorEmojis[color]} ${shopInfo[color][2].substring(0, 20)}...`,
                        value: { color, round: 2 },
                        group: group
                    });
                    // R3 shops
                    shopOptions.push({
                        label: `${color} R3: ${shopInfo[color][3]}`,
                        shortLabel: `R3: ${colorEmojis[color]} ${shopInfo[color][3].substring(0, 20)}...`,
                        value: { color, round: 3 },
                        group: group
                    });
                    // Victory shops
                    const vpCost = color === 'purple' ? '6' : (color === 'yellow' ? '5 any' : '5');
                    shopOptions.push({
                        label: `${color} Victory: ${vpCost} ${color === 'yellow' ? '' : color} → 3 VP`,
                        shortLabel: `VP: ${colorEmojis[color]} 3 Victory Points`,
                        value: { color, round: 'vp' },
                        group: group
                    });
                });
                
                const choice = await showChoice(dispatch, 'Choose any shop benefit (ignores closed status)', shopOptions, true);
                
                if (choice) {
                    // Execute the shop benefit without paying cost
                    if (choice.round === 'vp') {
                        // Grant 3 VP
                        dispatch({
                            type: 'UPDATE_VP',
                            playerId: player.id,
                            vp: 3
                        });
                        dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Gained 3 VP from ${choice.color} victory shop` });
                    } else {
                        // Execute regular shop effect
                        await executeShopBenefit(choice.color, choice.round, player, dispatch, state);
                        dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Executed ${choice.color} R${choice.round} shop benefit` });
                    }
                    
                    // BLUE AUTOMATIC VP: Player gets 1 VP when using any shop benefit
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: player.id,
                        vp: 1,
                        source: 'blueShopUsage'
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP (used a shop benefit)` });
                }
                
                return;
            }
            
            // Blue reduce costs action
            if (actionId === 'blueReduceCosts') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { blue: 1 }
                });
                
                // Add cost reduction for this round
                dispatch({
                    type: 'ADD_SHOP_COST_MODIFIER',
                    modifier: -1
                });
                
                const message = `Player ${player.id}: blueReduceCosts → +1 blue + shop costs reduced by 1 ⭐`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Blue increase costs action
            if (actionId === 'blueIncreaseCosts') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { blue: 2 }
                });
                
                // Add cost increase for this round
                dispatch({
                    type: 'ADD_SHOP_COST_MODIFIER',
                    modifier: 1
                });
                
                const message = `Player ${player.id}: blueIncreaseCosts → +2 blue + shop costs increased by 1 ⭐`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Blue toggle shops action
            if (actionId === 'blueToggleShops') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { blue: 1 }
                });
                
                // Toggle all shops (flip status)
                dispatch({
                    type: 'FLIP_ALL_SHOPS'
                });
                
                const message = `Player ${player.id}: blueToggleShops → +1 blue + all shops toggled`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // GOLD LAYER ACTIONS
            
            // Convert 2 ⭐ to 2 Gold
            if (actionId === 'convert2AnyTo2Gold') {
                const totalGems = Object.values(player.resources).reduce((sum, amount) => sum + amount, 0);
                if (totalGems < 2) {
                    const message = `Player ${player.id}: convert2AnyTo2Gold → Need at least 2 gems`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Choose 2 gems to convert
                const selectedGems = await showStealGems(dispatch, 'Choose 2 gems to convert to Gold', player, 2);
                
                if (!selectedGems) {
                    const message = `Player ${player.id}: convert2AnyTo2Gold → Cancelled`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Remove selected gems and add 2 gold
                const resources = { gold: 2 };
                Object.entries(selectedGems).forEach(([color, amount]) => {
                    resources[color] = -amount;
                });
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: resources
                });
                
                const message = `Player ${player.id}: convert2AnyTo2Gold → Converted 2 gems to 2 gold`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Convert 1 ⭐ to 1 Gold
            if (actionId === 'convert1AnyTo1Gold') {
                const totalGems = Object.values(player.resources).reduce((sum, amount) => sum + amount, 0);
                if (totalGems < 1) {
                    const message = `Player ${player.id}: convert1AnyTo1Gold → Need at least 1 gem`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Choose 1 gem to convert
                const selectedGems = await showStealGems(dispatch, 'Choose 1 gem to convert to Gold', player, 1);
                
                if (!selectedGems) {
                    const message = `Player ${player.id}: convert1AnyTo1Gold → Cancelled`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Remove selected gem and add 1 gold
                const resources = { gold: 1 };
                Object.entries(selectedGems).forEach(([color, amount]) => {
                    resources[color] = -amount;
                });
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: resources
                });
                
                const message = `Player ${player.id}: convert1AnyTo1Gold → Converted 1 gem to 1 gold`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Gain 3 Gold, Skip Next Turn
            if (actionId === 'gain3goldSkip') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { gold: 3 }
                });
                
                // Set skip for next turn
                const newSkippedTurns = { ...currentState.skippedTurns };
                newSkippedTurns[player.id] = (newSkippedTurns[player.id] || 0) + 1;
                dispatch({
                    type: 'SET_SKIPPED_TURNS',
                    skippedTurns: newSkippedTurns
                });
                
                const message = `Player ${player.id}: gain3goldSkip → +3 gold, will skip next turn`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Convert 3 ⭐ to 3 Gold
            if (actionId === 'convert3AnyTo3Gold') {
                const totalGems = Object.values(player.resources).reduce((sum, amount) => sum + amount, 0);
                if (totalGems < 3) {
                    const message = `Player ${player.id}: convert3AnyTo3Gold → Need at least 3 gems`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Choose 3 gems to convert
                const selectedGems = await showStealGems(dispatch, 'Choose 3 gems to convert to Gold', player, 3);
                
                if (!selectedGems) {
                    const message = `Player ${player.id}: convert3AnyTo3Gold → Cancelled`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Remove selected gems and add 3 gold
                const resources = { gold: 3 };
                Object.entries(selectedGems).forEach(([color, amount]) => {
                    resources[color] = -amount;
                });
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: resources
                });
                
                const message = `Player ${player.id}: convert3AnyTo3Gold → Converted 3 gems to 3 gold`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Gain VP for Each Gold You Have
            if (actionId === 'goldVPPerGold') {
                const goldAmount = player.resources.gold || 0;
                if (goldAmount > 0) {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: player.id,
                        vp: goldAmount,
                        source: 'goldVPPerGold'
                    });
                    const message = `Player ${player.id}: goldVPPerGold → +${goldAmount} VP (1 per gold)`;
                    dispatch({ type: 'ADD_LOG', message });
                } else {
                    const message = `Player ${player.id}: goldVPPerGold → No gold, no VP gained`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                return;
            }
            
            // WHITE LAYER ACTIONS - Victory Points
            
            // Gain 3 VP
            if (actionId === 'gain3vp') {
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 3,
                    source: 'whiteAction'
                });
                const message = `Player ${player.id}: gain3vp → +3 VP`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Gain 2 VP
            if (actionId === 'gain2vp') {
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 2,
                    source: 'whiteAction'
                });
                const message = `Player ${player.id}: gain2vp → +2 VP`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Spend 1 ⭐ for 2 VP
            if (actionId === 'spend1AnyFor2VP') {
                const totalGems = Object.values(player.resources).reduce((sum, amount) => sum + amount, 0);
                if (totalGems < 1) {
                    const message = `Player ${player.id}: spend1AnyFor2VP → Need at least 1 gem`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Choose 1 gem to spend
                const selectedGems = await showStealGems(dispatch, 'Choose 1 gem to spend for 2 VP', player, 1);
                
                if (!selectedGems) {
                    const message = `Player ${player.id}: spend1AnyFor2VP → Cancelled`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Remove selected gem
                const resources = {};
                Object.entries(selectedGems).forEach(([color, amount]) => {
                    resources[color] = -amount;
                });
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: resources
                });
                
                // Gain 2 VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 2,
                    source: 'whiteAction'
                });
                
                const message = `Player ${player.id}: spend1AnyFor2VP → Spent 1 gem for 2 VP`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Spend 2 ⭐ for 3 VP
            if (actionId === 'spend2AnyFor3VP') {
                const totalGems = Object.values(player.resources).reduce((sum, amount) => sum + amount, 0);
                if (totalGems < 2) {
                    const message = `Player ${player.id}: spend2AnyFor3VP → Need at least 2 gems`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Choose 2 gems to spend
                const selectedGems = await showStealGems(dispatch, 'Choose 2 gems to spend for 3 VP', player, 2);
                
                if (!selectedGems) {
                    const message = `Player ${player.id}: spend2AnyFor3VP → Cancelled`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Remove selected gems
                const resources = {};
                Object.entries(selectedGems).forEach(([color, amount]) => {
                    resources[color] = -amount;
                });
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: resources
                });
                
                // Gain 3 VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 3,
                    source: 'whiteAction'
                });
                
                const message = `Player ${player.id}: spend2AnyFor3VP → Spent 2 gems for 3 VP`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Lose 1 VP, Gain 2 ⭐
            if (actionId === 'lose1VPGain2Any') {
                if (player.victoryPoints < 1) {
                    const message = `Player ${player.id}: lose1VPGain2Any → Need at least 1 VP`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Lose 1 VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: -1,
                    source: 'whiteAction'
                });
                
                // Choose 2 gems to gain
                const selectedGems = await showGemSelection(dispatch, 'Choose 2 gems to gain', 2);
                
                if (!selectedGems) {
                    // If cancelled, give default resources
                    const resources = { red: 1, blue: 1 };
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: player.id, resources });
                    const message = `Player ${player.id}: lose1VPGain2Any → -1 VP, +1 red +1 blue (default)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: selectedGems
                });
                
                const message = `Player ${player.id}: lose1VPGain2Any → -1 VP, gained 2 gems`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Lose 2 VP, Gain 4 ⭐
            if (actionId === 'lose2VPGain4Any') {
                if (player.victoryPoints < 2) {
                    const message = `Player ${player.id}: lose2VPGain4Any → Need at least 2 VP`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Lose 2 VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: -2,
                    source: 'whiteAction'
                });
                
                // Choose 4 gems to gain
                const selectedGems = await showGemSelection(dispatch, 'Choose 4 gems to gain', 4);
                
                if (!selectedGems) {
                    // If cancelled, give default resources
                    const resources = { red: 1, yellow: 1, blue: 1, purple: 1 };
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: player.id, resources });
                    const message = `Player ${player.id}: lose2VPGain4Any → -2 VP, +1 of each color (default)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: selectedGems
                });
                
                const message = `Player ${player.id}: lose2VPGain4Any → -2 VP, gained 4 gems`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Gain 5 VP and 5 ⭐
            if (actionId === 'gain5VPAnd5Any') {
                // Gain 5 VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 5,
                    source: 'whiteAction'
                });
                
                // Choose 5 gems to gain
                const selectedGems = await showGemSelection(dispatch, 'Choose 5 gems to gain', 5);
                
                if (!selectedGems) {
                    // If cancelled, give default resources
                    const resources = { red: 1, yellow: 1, blue: 1, purple: 1, gold: 1 };
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: player.id, resources });
                    const message = `Player ${player.id}: gain5VPAnd5Any → +5 VP, +1 of each color (default)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: selectedGems
                });
                
                const message = `Player ${player.id}: gain5VPAnd5Any → +5 VP and 5 gems`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // BLACK LAYER ACTIONS
            
            // Steal 1 VP from another player
            if (actionId === 'blackSteal1VP') {
                // Give 1 black resource
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { black: 1 }
                });
                
                // Choose a player to steal from
                const otherPlayers = currentState.players.filter(p => p.id !== player.id && p.victoryPoints > 0);
                
                if (otherPlayers.length === 0) {
                    const message = `Player ${player.id}: blackSteal1VP → +1 black (no valid targets to steal VP from)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const targetPlayer = await showPlayerSelection(dispatch, 'Choose a player to steal 1 VP from', otherPlayers);
                
                if (!targetPlayer) {
                    const message = `Player ${player.id}: blackSteal1VP → +1 black (cancelled)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Remove 1 VP from target
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: targetPlayer.id,
                    vp: -1,
                    source: 'blackSteal'
                });
                
                // Add 1 VP to current player
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1,
                    source: 'blackSteal'
                });
                
                const message = `Player ${player.id}: blackSteal1VP → +1 black, stole 1 VP from Player ${targetPlayer.id}`;
                dispatch({ type: 'ADD_LOG', message });
                
                // BLACK AUTOMATIC VP: Gain 1 VP when stealing
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1,
                    source: 'blackAutomatic'
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP (Black automatic: stealing bonus)` });
                
                return;
            }
            
            // Steal 2 ⭐ from another player
            if (actionId === 'blackSteal2Any') {
                // Choose a player to steal from
                const otherPlayers = currentState.players.filter(p => {
                    if (p.id === player.id) return false;
                    const totalGems = Object.values(p.resources).reduce((sum, amount) => sum + amount, 0);
                    return totalGems > 0;
                });
                
                if (otherPlayers.length === 0) {
                    const message = `Player ${player.id}: blackSteal2Any → No players with gems to steal from`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const targetPlayer = await showPlayerSelection(dispatch, 'Choose a player to steal 2 gems from', otherPlayers);
                
                if (!targetPlayer) {
                    const message = `Player ${player.id}: blackSteal2Any → Cancelled`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Choose gems to steal
                const targetTotalGems = Object.values(targetPlayer.resources).reduce((sum, amount) => sum + amount, 0);
                const stealCount = Math.min(2, targetTotalGems);
                
                if (stealCount === 0) {
                    const message = `Player ${player.id}: blackSteal2Any → Player ${targetPlayer.id} has no gems`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const stolenGems = await showStealGems(dispatch, `Choose ${stealCount} gems to steal from Player ${targetPlayer.id}`, targetPlayer, stealCount);
                
                if (!stolenGems) {
                    const message = `Player ${player.id}: blackSteal2Any → Cancelled`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Remove gems from target
                const negativeResources = {};
                Object.entries(stolenGems).forEach(([color, amount]) => {
                    negativeResources[color] = -amount;
                });
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: targetPlayer.id,
                    resources: negativeResources
                });
                
                // Add gems to current player
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: stolenGems
                });
                
                const message = `Player ${player.id}: blackSteal2Any → Stole ${Object.entries(stolenGems).map(([color, amount]) => `${amount} ${color}`).join(', ')} from Player ${targetPlayer.id}`;
                dispatch({ type: 'ADD_LOG', message });
                
                // BLACK AUTOMATIC VP: Gain 1 VP when stealing
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1,
                    source: 'blackAutomatic'
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP (Black automatic: stealing bonus)` });
                
                return;
            }
            
            // Steal a Worker from another player
            if (actionId === 'blackStealWorker') {
                // Give 1 black resource
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { black: 1 }
                });
                
                // Choose a player to steal from
                const otherPlayers = currentState.players.filter(p => p.id !== player.id && p.workersLeft > 0);
                
                if (otherPlayers.length === 0) {
                    const message = `Player ${player.id}: blackStealWorker → +1 black (no players with workers to steal)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const targetPlayer = await showPlayerSelection(dispatch, 'Choose a player to steal a worker from', otherPlayers);
                
                if (!targetPlayer) {
                    const message = `Player ${player.id}: blackStealWorker → +1 black (cancelled)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Remove 1 worker from target
                dispatch({
                    type: 'UPDATE_PLAYER',
                    playerId: targetPlayer.id,
                    updates: { workersLeft: targetPlayer.workersLeft - 1 }
                });
                
                // Add 1 worker to current player
                dispatch({
                    type: 'UPDATE_PLAYER',
                    playerId: player.id,
                    updates: { workersLeft: player.workersLeft + 1 }
                });
                
                const message = `Player ${player.id}: blackStealWorker → +1 black, stole 1 worker from Player ${targetPlayer.id}`;
                dispatch({ type: 'ADD_LOG', message });
                
                // BLACK AUTOMATIC VP: Gain 1 VP when stealing
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1,
                    source: 'blackAutomatic'
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP (Black automatic: stealing bonus)` });
                
                return;
            }
            
            // All other players lose 2 VP
            if (actionId === 'blackAllLose2VP') {
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                
                otherPlayers.forEach(otherPlayer => {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: otherPlayer.id,
                        vp: -2,
                        source: 'blackPenalty'
                    });
                });
                
                const message = `Player ${player.id}: blackAllLose2VP → All other players lose 2 VP`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // All other players lose 4 VP
            if (actionId === 'blackAllLose4VP') {
                // Give 1 black resource
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { black: 1 }
                });
                
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                
                otherPlayers.forEach(otherPlayer => {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: otherPlayer.id,
                        vp: -4,
                        source: 'blackPenalty'
                    });
                });
                
                const message = `Player ${player.id}: blackAllLose4VP → +1 black, all other players lose 4 VP`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // SILVER LAYER ACTIONS
            
            // +4 Silver, Other Players Get +1 Silver
            if (actionId === 'silver4Others1') {
                // Give current player 4 silver
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { silver: 4 }
                });
                
                // Give other players 1 silver each
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                otherPlayers.forEach(otherPlayer => {
                    dispatch({
                        type: 'UPDATE_RESOURCES',
                        playerId: otherPlayer.id,
                        resources: { silver: 1 }
                    });
                });
                
                const message = `Player ${player.id}: silver4Others1 → +4 silver, all other players +1 silver`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // +3 Silver, Other Players Get +1 Silver
            if (actionId === 'silver3Others1') {
                // Give current player 3 silver
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { silver: 3 }
                });
                
                // Give other players 1 silver each
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                otherPlayers.forEach(otherPlayer => {
                    dispatch({
                        type: 'UPDATE_RESOURCES',
                        playerId: otherPlayer.id,
                        resources: { silver: 1 }
                    });
                });
                
                const message = `Player ${player.id}: silver3Others1 → +3 silver, all other players +1 silver`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // +2 Silver + 1 ⭐ Color, Other Players Get 1 of Same Color
            if (actionId === 'silver2Plus1Others') {
                // Give current player 2 silver
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { silver: 2 }
                });
                
                // Choose 1 gem of any color
                const selectedGems = await showGemSelection(dispatch, 'Choose 1 gem (others will get the same)', 1);
                
                if (!selectedGems) {
                    // If cancelled, give default red
                    const resources = { red: 1 };
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: player.id, resources });
                    
                    // Give other players 1 red
                    const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                    otherPlayers.forEach(otherPlayer => {
                        dispatch({
                            type: 'UPDATE_RESOURCES',
                            playerId: otherPlayer.id,
                            resources: { red: 1 }
                        });
                    });
                    
                    const message = `Player ${player.id}: silver2Plus1Others → +2 silver +1 red, others +1 red`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Give current player the selected gem
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: selectedGems
                });
                
                // Give other players the same color
                const chosenColor = Object.keys(selectedGems)[0];
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                otherPlayers.forEach(otherPlayer => {
                    dispatch({
                        type: 'UPDATE_RESOURCES',
                        playerId: otherPlayer.id,
                        resources: { [chosenColor]: 1 }
                    });
                });
                
                const message = `Player ${player.id}: silver2Plus1Others → +2 silver +1 ${chosenColor}, others +1 ${chosenColor}`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // +2 VP, Pick Another Player to Also Gain +2 VP
            if (actionId === 'silver2VPBoth') {
                // Give current player 2 VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 2,
                    source: 'silverAction'
                });
                
                // Choose another player to give 2 VP
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                const targetPlayer = await showPlayerSelection(dispatch, 'Choose a player to also gain 2 VP', otherPlayers);
                
                if (!targetPlayer) {
                    // If cancelled, pick first other player
                    const firstOther = otherPlayers[0];
                    if (firstOther) {
                        dispatch({
                            type: 'UPDATE_VP',
                            playerId: firstOther.id,
                            vp: 2,
                            source: 'silverAction'
                        });
                        const message = `Player ${player.id}: silver2VPBoth → +2 VP, Player ${firstOther.id} +2 VP`;
                        dispatch({ type: 'ADD_LOG', message });
                    } else {
                        const message = `Player ${player.id}: silver2VPBoth → +2 VP (no other players)`;
                        dispatch({ type: 'ADD_LOG', message });
                    }
                    return;
                }
                
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: targetPlayer.id,
                    vp: 2,
                    source: 'silverAction'
                });
                
                const message = `Player ${player.id}: silver2VPBoth → +2 VP, Player ${targetPlayer.id} +2 VP`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // +2 Silver, Take Back Two Workers, Each Other Player Takes Back One
            if (actionId === 'silverTakeBack2') {
                // Give current player 2 silver
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { silver: 2 }
                });
                
                // Take back 2 workers for current player
                const occupiedByPlayer = Object.entries(currentState.occupiedSpaces || {})
                    .filter(([actionId, playerId]) => playerId === player.id);
                
                let workersReturned = 0;
                for (let i = 0; i < Math.min(2, occupiedByPlayer.length); i++) {
                    const [workerAction] = occupiedByPlayer[i];
                    dispatch({
                        type: 'REMOVE_WORKER',
                        actionId: workerAction,
                        playerId: player.id
                    });
                    workersReturned++;
                }
                
                // Each other player takes back 1 worker
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                otherPlayers.forEach(otherPlayer => {
                    const theirWorkers = Object.entries(currentState.occupiedSpaces || {})
                        .filter(([actionId, playerId]) => playerId === otherPlayer.id);
                    
                    if (theirWorkers.length > 0) {
                        const [workerAction] = theirWorkers[0];
                        dispatch({
                            type: 'REMOVE_WORKER',
                            actionId: workerAction,
                            playerId: otherPlayer.id
                        });
                    }
                });
                
                const message = `Player ${player.id}: silverTakeBack2 → +2 silver, took back ${workersReturned} workers, others took back 1`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // +3 Silver + 2 ⭐ Color, Other Players Get 1 of That Color
            if (actionId === 'silver3Plus2Others1') {
                // Give current player 3 silver
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { silver: 3 }
                });
                
                // Choose 2 gems of any color
                const selectedGems = await showGemSelection(dispatch, 'Choose 2 gems (others will get 1 of that color)', 2);
                
                if (!selectedGems) {
                    // If cancelled, give default red
                    const resources = { red: 2 };
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: player.id, resources });
                    
                    // Give other players 1 red
                    const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                    otherPlayers.forEach(otherPlayer => {
                        dispatch({
                            type: 'UPDATE_RESOURCES',
                            playerId: otherPlayer.id,
                            resources: { red: 1 }
                        });
                    });
                    
                    const message = `Player ${player.id}: silver3Plus2Others1 → +3 silver +2 red, others +1 red`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Give current player the selected gems
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: selectedGems
                });
                
                // Give other players 1 of the chosen color (if multiple colors chosen, use the first)
                const chosenColor = Object.keys(selectedGems)[0];
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                otherPlayers.forEach(otherPlayer => {
                    dispatch({
                        type: 'UPDATE_RESOURCES',
                        playerId: otherPlayer.id,
                        resources: { [chosenColor]: 1 }
                    });
                });
                
                const message = `Player ${player.id}: silver3Plus2Others1 → +3 silver +2 gems, others +1 ${chosenColor}`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // +8 VP, Each Other Player Gets +3 Silver
            if (actionId === 'silver8VPOthers3S') {
                // Give current player 8 VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 8,
                    source: 'silverAction'
                });
                
                // Give other players 3 silver each
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                otherPlayers.forEach(otherPlayer => {
                    dispatch({
                        type: 'UPDATE_RESOURCES',
                        playerId: otherPlayer.id,
                        resources: { silver: 3 }
                    });
                });
                
                const message = `Player ${player.id}: silver8VPOthers3S → +8 VP, all other players +3 silver`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            console.log(`Player ${player.id} executed action: ${actionId}`);
        }

        // Custom Modal Components
        function Modal({ isOpen, onClose, children }) {
            if (!isOpen) return null;
            
            return React.createElement('div', {
                className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
                onClick: onClose
            }, React.createElement('div', {
                className: 'glass rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl',
                onClick: (e) => e.stopPropagation()
            }, children));
        }

        function ChoiceModal({ title, options, onSelect, onCancel, columnMode = false }) {
            const { dispatch } = useGame();
            
            const handleSelect = (option) => {
                dispatch({ type: 'HIDE_MODAL' });
                onSelect(option);
            };
            
            const handleCancel = () => {
                dispatch({ type: 'HIDE_MODAL' });
                if (onCancel) onCancel();
            };
            
            // If columnMode is true and options have groups, render in columns
            if (columnMode && options.some(opt => opt.group)) {
                // Group options by their group property
                const groupedOptions = options.reduce((groups, option) => {
                    const group = option.group || 'Other';
                    if (!groups[group]) groups[group] = [];
                    groups[group].push(option);
                    return groups;
                }, {});
                
                const quadColors = {
                    'Red/Yellow': 'from-red-400 to-yellow-400',
                    'Blue/Purple': 'from-blue-400 to-purple-400',
                    'Gold/White': 'from-yellow-500 to-gray-100',
                    'Black/Silver': 'from-gray-800 to-gray-400',
                    // Individual quad colors
                    'Red Quad': 'from-red-400 to-red-500',
                    'Yellow Quad': 'from-yellow-400 to-yellow-500',
                    'Blue Quad': 'from-blue-400 to-blue-500',
                    'Purple Quad': 'from-purple-400 to-purple-500',
                    'Gold Quad': 'from-yellow-500 to-yellow-600',
                    'White Quad': 'from-gray-100 to-gray-200',
                    'Black Quad': 'from-gray-800 to-gray-900',
                    'Silver Quad': 'from-gray-400 to-gray-500'
                };
                
                return React.createElement('div', { className: 'text-center' }, [
                    React.createElement('h3', { 
                        key: 'title', 
                        className: 'text-xl font-bold text-gray-800 mb-4' 
                    }, title),
                    React.createElement('div', { 
                        key: 'columns', 
                        className: 'grid grid-cols-2 md:grid-cols-4 gap-4 mb-6 max-h-96 overflow-y-auto' 
                    }, Object.entries(groupedOptions).map(([groupName, groupOptions]) => 
                        React.createElement('div', {
                            key: groupName,
                            className: 'space-y-2'
                        }, [
                            React.createElement('h4', {
                                key: 'header',
                                className: `text-sm font-bold text-gray-700 mb-2 p-1 rounded bg-gradient-to-r ${quadColors[groupName] || 'from-gray-200 to-gray-300'}`
                            }, groupName),
                            ...groupOptions.map((option, index) => 
                                React.createElement('button', {
                                    key: `${groupName}-${index}`,
                                    onClick: () => handleSelect(option.value || option),
                                    className: 'w-full text-xs bg-gradient-to-r from-gray-100 to-gray-200 hover:from-gray-200 hover:to-gray-300 text-gray-800 font-semibold py-2 px-2 rounded-md shadow-sm hover:shadow-md transform hover:scale-105 transition-all duration-200',
                                    title: option.label || option
                                }, option.shortLabel || option.label || option)
                            )
                        ])
                    )),
                    React.createElement('button', {
                        key: 'cancel',
                        onClick: handleCancel,
                        className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Cancel')
                ]);
            }
            
            // Default single column mode
            return React.createElement('div', { className: 'text-center' }, [
                React.createElement('h3', { 
                    key: 'title', 
                    className: 'text-xl font-bold text-gray-800 mb-4' 
                }, title),
                React.createElement('div', { 
                    key: 'options', 
                    className: 'space-y-2 mb-6' 
                }, options.map((option, index) => 
                    React.createElement('button', {
                        key: index,
                        onClick: () => handleSelect(option.value || option),
                        className: 'w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, option.label || option)
                )),
                React.createElement('button', {
                    key: 'cancel',
                    onClick: handleCancel,
                    className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                }, 'Cancel')
            ]);
        }

        function ConfirmModal({ title, message, onConfirm, onCancel }) {
            const { dispatch } = useGame();
            
            const handleConfirm = () => {
                dispatch({ type: 'HIDE_MODAL' });
                onConfirm();
            };
            
            const handleCancel = () => {
                dispatch({ type: 'HIDE_MODAL' });
                if (onCancel) onCancel();
            };
            
            return React.createElement('div', { className: 'text-center' }, [
                React.createElement('h3', { 
                    key: 'title', 
                    className: 'text-xl font-bold text-gray-800 mb-2' 
                }, title),
                React.createElement('p', { 
                    key: 'message', 
                    className: 'text-gray-600 mb-6' 
                }, message),
                React.createElement('div', { 
                    key: 'buttons', 
                    className: 'flex gap-3' 
                }, [
                    React.createElement('button', {
                        key: 'cancel',
                        onClick: handleCancel,
                        className: 'flex-1 bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Cancel'),
                    React.createElement('button', {
                        key: 'confirm',
                        onClick: handleConfirm,
                        className: 'flex-1 bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Confirm')
                ])
            ]);
        }

        // Gem Selection Modal Component
        function GemSelectionModal({ title, maxGems, onSelect, onCancel }) {
            const { state, dispatch } = useGame();
            const [selectedGems, setSelectedGems] = React.useState({});
            const [totalSelected, setTotalSelected] = React.useState(0);
            
            // Get active colors from game layers
            const activeColors = state.gameLayers ? Object.keys(state.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
            
            // Initialize selectedGems with active colors
            React.useEffect(() => {
                const initialGems = {};
                activeColors.forEach(color => {
                    initialGems[color] = 0;
                });
                setSelectedGems(initialGems);
            }, []);
            
            const gemColorData = {
                red: { emoji: '🔴', gradient: 'from-red-500 to-red-600' },
                yellow: { emoji: '🟡', gradient: 'from-yellow-400 to-yellow-500' },
                blue: { emoji: '🔵', gradient: 'from-blue-500 to-blue-600' },
                purple: { emoji: '🟣', gradient: 'from-purple-500 to-purple-600' },
                gold: { emoji: '🟨', gradient: 'from-yellow-600 to-yellow-700' },
                white: { emoji: '⚪', gradient: 'from-gray-200 to-gray-300' },
                black: { emoji: '⚫', gradient: 'from-gray-700 to-gray-900' },
                silver: { emoji: '🩶', gradient: 'from-gray-400 to-gray-500' }
            };
            
            const gemColors = activeColors.map(color => ({
                color,
                emoji: gemColorData[color].emoji,
                gradient: gemColorData[color].gradient
            }));
            
            const handleGemClick = (color) => {
                if (totalSelected < maxGems) {
                    const newSelectedGems = { ...selectedGems, [color]: selectedGems[color] + 1 };
                    const newTotal = totalSelected + 1;
                    setSelectedGems(newSelectedGems);
                    setTotalSelected(newTotal);
                    
                    // Auto-close when limit reached
                    if (newTotal === maxGems) {
                        setTimeout(() => {
                            dispatch({ type: 'HIDE_MODAL' });
                            onSelect(newSelectedGems);
                        }, 300);
                    }
                }
            };
            
            const handleRemoveGem = (color) => {
                if (selectedGems[color] > 0) {
                    setSelectedGems({ ...selectedGems, [color]: selectedGems[color] - 1 });
                    setTotalSelected(totalSelected - 1);
                }
            };
            
            const handleConfirm = () => {
                dispatch({ type: 'HIDE_MODAL' });
                onSelect(selectedGems);
            };
            
            const handleCancel = () => {
                dispatch({ type: 'HIDE_MODAL' });
                if (onCancel) onCancel();
            };
            
            return React.createElement('div', { className: 'text-center' }, [
                React.createElement('h3', { 
                    key: 'title', 
                    className: 'text-xl font-bold text-gray-800 mb-2' 
                }, title),
                React.createElement('p', { 
                    key: 'progress', 
                    className: 'text-gray-600 mb-4'
                }, `Selected: ${totalSelected}/${maxGems}`),
                
                // Gem selection grid
                React.createElement('div', {
                    key: 'gem-grid',
                    className: 'grid grid-cols-4 gap-4 mb-4'
                }, gemColors.map(({ color, emoji, gradient }) => 
                    React.createElement('div', {
                        key: color,
                        className: 'text-center'
                    }, [
                        React.createElement('button', {
                            key: `${color}-button`,
                            onClick: () => handleGemClick(color),
                            disabled: totalSelected >= maxGems,
                            className: `w-16 h-16 rounded-lg bg-gradient-to-r ${gradient} ${totalSelected >= maxGems ? 'opacity-50 cursor-not-allowed' : 'hover:scale-110'} transition-all duration-200 flex items-center justify-center text-2xl shadow-lg`
                        }, emoji),
                        React.createElement('div', {
                            key: `${color}-count`,
                            className: 'mt-2 font-semibold text-gray-700'
                        }, selectedGems[color] > 0 ? `×${selectedGems[color]}` : '')
                    ])
                )),
                
                // Selected gems display
                totalSelected > 0 && React.createElement('div', {
                    key: 'selected-display',
                    className: 'mb-4 p-3 bg-gray-100 rounded-lg'
                }, [
                    React.createElement('p', {
                        key: 'selected-label',
                        className: 'text-sm text-gray-600 mb-2'
                    }, 'Selected gems:'),
                    React.createElement('div', {
                        key: 'selected-gems',
                        className: 'flex justify-center gap-2 flex-wrap'
                    }, Object.entries(selectedGems).flatMap(([color, count]) => 
                        Array(count).fill(null).map((_, i) => {
                            const gemInfo = gemColors.find(g => g.color === color);
                            return React.createElement('button', {
                                key: `${color}-${i}`,
                                onClick: () => handleRemoveGem(color),
                                className: 'text-xl hover:scale-125 transition-transform cursor-pointer',
                                title: 'Click to remove'
                            }, gemInfo.emoji);
                        })
                    ))
                ]),
                
                // Buttons
                React.createElement('div', { 
                    key: 'buttons', 
                    className: 'flex gap-3' 
                }, [
                    React.createElement('button', {
                        key: 'cancel',
                        onClick: handleCancel,
                        className: 'flex-1 bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Cancel'),
                    React.createElement('button', {
                        key: 'confirm',
                        onClick: handleConfirm,
                        disabled: totalSelected === 0,
                        className: `flex-1 bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200 ${totalSelected === 0 ? 'opacity-50 cursor-not-allowed' : ''}`
                    }, 'Confirm')
                ])
            ]);
        }

        // Steal Gems Modal Component
        function StealGemsModal({ title, targetPlayer, maxGems, onSelect, onCancel }) {
            const { state, dispatch } = useGame();
            const [selectedGems, setSelectedGems] = React.useState({});
            const [totalSelected, setTotalSelected] = React.useState(0);
            
            // Get active colors from game layers
            const activeColors = state.gameLayers ? Object.keys(state.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
            
            // Initialize selectedGems with active colors
            React.useEffect(() => {
                const initialGems = {};
                activeColors.forEach(color => {
                    initialGems[color] = 0;
                });
                setSelectedGems(initialGems);
            }, []);
            
            const gemColorData = {
                red: { emoji: '🔴', gradient: 'from-red-500 to-red-600' },
                yellow: { emoji: '🟡', gradient: 'from-yellow-400 to-yellow-500' },
                blue: { emoji: '🔵', gradient: 'from-blue-500 to-blue-600' },
                purple: { emoji: '🟣', gradient: 'from-purple-500 to-purple-600' },
                gold: { emoji: '🟨', gradient: 'from-yellow-600 to-yellow-700' },
                white: { emoji: '⚪', gradient: 'from-gray-200 to-gray-300' },
                black: { emoji: '⚫', gradient: 'from-gray-700 to-gray-900' },
                silver: { emoji: '🩶', gradient: 'from-gray-400 to-gray-500' }
            };
            
            const gemColors = activeColors.map(color => ({
                color,
                emoji: gemColorData[color].emoji,
                gradient: gemColorData[color].gradient
            }));
            
            const handleGemClick = (color) => {
                const availableCount = targetPlayer.resources[color] || 0;
                const alreadySelected = selectedGems[color];
                
                if (totalSelected < maxGems && alreadySelected < availableCount) {
                    const newSelectedGems = { ...selectedGems, [color]: selectedGems[color] + 1 };
                    const newTotal = totalSelected + 1;
                    setSelectedGems(newSelectedGems);
                    setTotalSelected(newTotal);
                    
                    // Auto-close when limit reached
                    if (newTotal === maxGems) {
                        setTimeout(() => {
                            dispatch({ type: 'HIDE_MODAL' });
                            onSelect(newSelectedGems);
                        }, 300);
                    }
                }
            };
            
            const handleRemoveGem = (color) => {
                if (selectedGems[color] > 0) {
                    setSelectedGems({ ...selectedGems, [color]: selectedGems[color] - 1 });
                    setTotalSelected(totalSelected - 1);
                }
            };
            
            const handleConfirm = () => {
                dispatch({ type: 'HIDE_MODAL' });
                onSelect(selectedGems);
            };
            
            const handleCancel = () => {
                dispatch({ type: 'HIDE_MODAL' });
                if (onCancel) onCancel();
            };
            
            return React.createElement('div', { className: 'text-center' }, [
                React.createElement('h3', { 
                    key: 'title', 
                    className: 'text-xl font-bold text-gray-800 mb-2' 
                }, title),
                React.createElement('p', { 
                    key: 'target', 
                    className: 'text-gray-600 mb-2'
                }, `Stealing from Player ${targetPlayer.id}`),
                React.createElement('p', { 
                    key: 'progress', 
                    className: 'text-gray-600 mb-4'
                }, `Selected: ${totalSelected}/${maxGems}`),
                
                // Target player's available gems
                React.createElement('div', {
                    key: 'available-label',
                    className: 'text-sm text-gray-600 mb-2'
                }, 'Available gems:'),
                
                // Gem selection grid
                React.createElement('div', {
                    key: 'gem-grid',
                    className: 'grid grid-cols-4 gap-4 mb-4'
                }, gemColors.map(({ color, emoji, gradient }) => {
                    const available = targetPlayer.resources[color] || 0;
                    const selected = selectedGems[color];
                    const remaining = available - selected;
                    const canSelect = totalSelected < maxGems && remaining > 0;
                    
                    return React.createElement('div', {
                        key: color,
                        className: 'text-center'
                    }, [
                        React.createElement('button', {
                            key: `${color}-button`,
                            onClick: () => handleGemClick(color),
                            disabled: !canSelect,
                            className: `w-16 h-16 rounded-lg bg-gradient-to-r ${gradient} ${!canSelect ? 'opacity-50 cursor-not-allowed' : 'hover:scale-110'} transition-all duration-200 flex items-center justify-center text-2xl shadow-lg relative`
                        }, [
                            React.createElement('span', { key: 'emoji' }, emoji),
                            available > 0 && React.createElement('span', {
                                key: 'count',
                                className: 'absolute -top-2 -right-2 bg-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center shadow-md'
                            }, available)
                        ]),
                        React.createElement('div', {
                            key: `${color}-info`,
                            className: 'mt-2 text-sm text-gray-700'
                        }, selected > 0 ? `Taking ${selected}` : remaining > 0 ? `${remaining} left` : 'None')
                    ]);
                })),
                
                // Selected gems display
                totalSelected > 0 && React.createElement('div', {
                    key: 'selected-display',
                    className: 'mb-4 p-3 bg-gray-100 rounded-lg'
                }, [
                    React.createElement('p', {
                        key: 'selected-label',
                        className: 'text-sm text-gray-600 mb-2'
                    }, 'Gems to steal:'),
                    React.createElement('div', {
                        key: 'selected-gems',
                        className: 'flex justify-center gap-2 flex-wrap'
                    }, Object.entries(selectedGems).flatMap(([color, count]) => 
                        Array(count).fill(null).map((_, i) => {
                            const gemInfo = gemColors.find(g => g.color === color);
                            return React.createElement('button', {
                                key: `${color}-${i}`,
                                onClick: () => handleRemoveGem(color),
                                className: 'text-xl hover:scale-125 transition-transform cursor-pointer',
                                title: 'Click to remove'
                            }, gemInfo.emoji);
                        })
                    ))
                ]),
                
                // Buttons
                React.createElement('div', { 
                    key: 'buttons', 
                    className: 'flex gap-3' 
                }, [
                    React.createElement('button', {
                        key: 'cancel',
                        onClick: handleCancel,
                        className: 'flex-1 bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Cancel'),
                    React.createElement('button', {
                        key: 'confirm',
                        onClick: handleConfirm,
                        disabled: totalSelected === 0,
                        className: `flex-1 bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200 ${totalSelected === 0 ? 'opacity-50 cursor-not-allowed' : ''}`
                    }, 'Confirm')
                ])
            ]);
        }

        // Helper functions for custom prompts
        function showChoice(dispatch, title, options, columnMode = false) {
            return new Promise((resolve) => {
                dispatch({
                    type: 'SHOW_MODAL',
                    modal: {
                        type: 'choice',
                        title,
                        options,
                        columnMode,
                        onSelect: resolve,
                        onCancel: () => resolve(null)
                    }
                });
            });
        }

        function showConfirm(dispatch, title, message) {
            return new Promise((resolve) => {
                dispatch({
                    type: 'SHOW_MODAL',
                    modal: {
                        type: 'confirm',
                        title,
                        message,
                        onConfirm: () => resolve(true),
                        onCancel: () => resolve(false)
                    }
                });
            });
        }

        function showGemSelection(dispatch, title, maxGems) {
            return new Promise((resolve) => {
                dispatch({
                    type: 'SHOW_MODAL',
                    modal: {
                        type: 'gemSelection',
                        title,
                        maxGems,
                        onSelect: resolve,
                        onCancel: () => resolve(null)
                    }
                });
            });
        }

        function showStealGems(dispatch, title, targetPlayer, maxGems) {
            return new Promise((resolve) => {
                dispatch({
                    type: 'SHOW_MODAL',
                    modal: {
                        type: 'stealGems',
                        title,
                        targetPlayer,
                        maxGems,
                        onSelect: resolve,
                        onCancel: () => resolve(null)
                    }
                });
            });
        }

        // End Turn Button Component
        function EndTurnButton({ onEndTurn }) {
            const { state, dispatch } = useGame();
            const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
            
            // Phase should automatically change to shop2 when all workers for turn are placed
            // This button is a fallback in case something goes wrong
            
            const getButtonText = () => {
                return 'End Turn';
            };
            
            // Button should be disabled if no worker placed (unless special conditions)
            const canEndWithoutWorker = currentPlayer && currentPlayer.workersLeft === 0;
            const isButtonDisabled = !state.workerPlacedThisTurn && !canEndWithoutWorker;
            
            return React.createElement('div', { className: 'mt-3 text-center' }, 
                React.createElement('button', {
                    onClick: onEndTurn,
                    disabled: isButtonDisabled,
                    className: `w-full font-bold py-2 px-4 rounded-lg shadow-lg transition-all duration-200 ${
                        isButtonDisabled 
                            ? 'bg-gray-400 text-gray-200 cursor-not-allowed' 
                            : 'bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white hover:shadow-xl transform hover:scale-105'
                    }`
                }, getButtonText())
            );
        }

        // Execute repeat action from red shop
        async function executeRepeatAction(player, dispatch, state, gameLayers) {
            const playerSpaces = Object.entries(state.occupiedSpaces)
                .filter(([spaceId, pid]) => pid === player.id)
                .map(([spaceId]) => spaceId);
            
            if (playerSpaces.length === 0) {
                const message = `Player ${player.id}: Red shop → No workers to repeat`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (playerSpaces.length === 1) {
                // Auto-select the only option
                const spaceId = playerSpaces[0];
                let actionTitle = spaceId;
                for (const layerData of Object.values(gameLayers)) {
                    const action = layerData.actions.find(a => a.id === spaceId);
                    if (action) {
                        actionTitle = action.title;
                        break;
                    }
                }
                
                const message = `Player ${player.id}: Red shop → Repeating ${actionTitle}`;
                dispatch({ type: 'ADD_LOG', message });
                
                await executeAction(spaceId, player, dispatch, state, gameLayers, 0);
            } else {
                // Multiple options, let player choose
                const repeatOptions = playerSpaces.map(spaceId => {
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    return {
                        label: `Repeat: ${actionTitle}`,
                        value: spaceId
                    };
                });
                
                const choice = await showChoice(dispatch, 
                    'Choose an action to repeat', 
                    repeatOptions
                );
                
                if (choice) {
                    const message = `Player ${player.id}: Red shop → Repeating ${choice}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    await executeAction(choice, player, dispatch, state, gameLayers, 0);
                }
            }
        }

        // Execute yellow 3 shop effect
        async function executeYellow3Shop(player, dispatch, state) {
            // Gain 9 resources ⭐ colors - using GemSelectionModal
            const selectedGems = await showGemSelection(
                dispatch,
                'Choose 9 gems of any color',
                9
            );
            
            if (!selectedGems) {
                const message = `Player ${player.id}: Yellow R3 shop → Cancelled`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            dispatch({
                type: 'UPDATE_RESOURCES',
                playerId: player.id,
                resources: selectedGems
            });
            
            // Each other player gains 1 gem of buyer's choice
            for (const otherPlayer of state.players) {
                if (otherPlayer.id !== player.id) {
                    const colorForOther = await showChoice(dispatch, 
                        `Choose a gem color for Player ${otherPlayer.id} to gain`, 
                        colors.map(color => ({
                            label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                            value: color
                        }))
                    );
                    
                    if (colorForOther) {
                        dispatch({
                            type: 'UPDATE_RESOURCES',
                            playerId: otherPlayer.id,
                            resources: { [colorForOther]: 1 }
                        });
                    }
                }
            }
            
            const message = `Player ${player.id}: Yellow R3 shop → Gained 9 gems, each other player gained 1 gem`;
            dispatch({ type: 'ADD_LOG', message });
        }
        
        // Execute yellow 2 shop effect
        async function executeYellow2Shop(player, dispatch, state) {
            // Gain 5 resources ⭐ colors - using GemSelectionModal
            const selectedGems = await showGemSelection(
                dispatch,
                'Choose 5 gems of any color',
                5
            );
            
            if (!selectedGems) {
                const message = `Player ${player.id}: Yellow R2 shop → Cancelled`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            dispatch({
                type: 'UPDATE_RESOURCES',
                playerId: player.id,
                resources: selectedGems
            });
            
            // Everyone gains 1 gem of buyer's choice
            const colorForOthers = await showChoice(dispatch, 
                `Choose a gem color for all other players to gain`, 
                colors.map(color => ({
                            label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                            value: color
                        }))
                    );
                    
            if (colorForOthers) {
                for (const otherPlayer of state.players) {
                    if (otherPlayer.id !== player.id) {
                        dispatch({
                            type: 'UPDATE_RESOURCES',
                            playerId: otherPlayer.id,
                            resources: { [colorForOthers]: 1 }
                        });
                    }
                }
            }
            
            const message = `Player ${player.id}: Yellow R2 shop → Gained 5 gems, everyone gained 1 ${colorForOthers || 'gem'}`;
            dispatch({ type: 'ADD_LOG', message });
        }
        
        // Execute blue 1 shop effect - Toggle any shop (open/closed)
        async function executeBlue1Shop(player, dispatch, state) {
            // List all shops from active game layers only
            const shopOptions = [];
            const colors = state.gameLayers ? Object.keys(state.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
            
            const shopData = {
                red: {
                    1: 'Repeat a worker\'s action',
                    2: 'Place the next player\'s worker',
                    3: 'Repeat all actions taken this round'
                },
                yellow: {
                    1: 'Double your next gain action',
                    2: 'Gain 5⭐',
                    3: 'Gain 9⭐'
                },
                blue: {
                    1: 'Toggle any shop (open/closed)',
                    2: 'Flip all shop statuses',
                    3: 'Gain any shop benefit'
                },
                purple: {
                    1: 'Take an extra turn',
                    2: 'Play 2 more workers this turn',
                    3: 'Play all remaining workers'
                },
                gold: {
                    1: '1 Gold + 1 Any = 2 Gold',
                    2: '2 Gold + 2 Any = 4 Gold',
                    3: '3 Gold + 3 Any = Double Your Gold'
                },
                white: {
                    1: 'Lose 1 VP, Gain 1 ⭐',
                    2: 'Lose 3 VP, Skip next player\'s turn',
                    3: 'Lose 5 VP, Move worker to action'
                },
                black: {
                    1: 'Destroy 2 gems from any player',
                    2: 'Curse a player: -1 to all gains',
                    3: 'All players lose 3 gems'
                },
                silver: {
                    1: 'Look at and rearrange turn order',
                    2: 'See all hands and steal 1 gem',
                    3: 'Control turn order'
                }
            };
            
            const shopCosts = {
                red: { 1: '1🔴+2⭐', 2: '2🔴+2⭐', 3: '3🔴+3⭐' },
                yellow: { 1: '1🟡+1⭐', 2: '2🟡+2⭐', 3: '3🟡+3⭐' },
                blue: { 1: '1🔵+1⭐', 2: '2🔵+2⭐', 3: '3🔵+3⭐' },
                purple: { 1: '1🟣+1⭐', 2: '2🟣+2⭐', 3: '3🟣+3⭐' },
                gold: { 1: '1🟨+1⭐', 2: '2🟨+2⭐', 3: '3🟨+3⭐' },
                white: { 1: '1VP+1⭐', 2: '3VP+2⭐', 3: '5VP+3⭐' },
                black: { 1: '1⚫+1⭐', 2: '2⚫+2⭐', 3: '3⚫+3⭐' },
                silver: { 1: '1🩶+1⭐', 2: '2🩶+2⭐', 3: '3🩶+3⭐' }
            };
            
            const colorEmojis = {
                red: '🔴', yellow: '🟡', blue: '🔵', purple: '🟣',
                gold: '🟨', white: '⚪', black: '⚫', silver: '🩶'
            };
            
            // Map of quad display names
            const quadNames = {
                'red': 'Red Quad',
                'yellow': 'Yellow Quad',
                'blue': 'Blue Quad',
                'purple': 'Purple Quad',
                'gold': 'Gold Quad',
                'white': 'White Quad',
                'black': 'Black Quad',
                'silver': 'Silver Quad'
            };
            
            // Organize shops by individual quad (color)
            colors.forEach(color => {
                const quadName = quadNames[color] || color;
                
                // R1 shops
                const isClosedR1 = state.closedShops[`${color}1`];
                const availableR1 = state.round >= 1;
                shopOptions.push({
                    label: `${isClosedR1 ? 'Closed' : 'Open'} ${shopCosts[color][1]} - ${shopData[color][1]}${!availableR1 ? ' (Round 1)' : ''}`,
                    shortLabel: `${isClosedR1 ? '🚫' : '✅'} R1: ${shopCosts[color][1]}`,
                    value: `${color}1`,
                    group: quadName
                });
                
                // R2 shops - show all but indicate if not available
                const isClosedR2 = state.closedShops[`${color}2`];
                const availableR2 = state.round >= 2;
                shopOptions.push({
                    label: `${isClosedR2 ? 'Closed' : 'Open'} ${shopCosts[color][2]} - ${shopData[color][2]}${!availableR2 ? ' (Round 2)' : ''}`,
                    shortLabel: `${isClosedR2 ? '🚫' : '✅'} R2: ${shopCosts[color][2]}`,
                    value: `${color}2`,
                    group: quadName
                });
                
                // R3 shops - show all but indicate if not available
                const isClosedR3 = state.closedShops[`${color}3`];
                const availableR3 = state.round >= 3;
                shopOptions.push({
                    label: `${isClosedR3 ? 'Closed' : 'Open'} ${shopCosts[color][3]} - ${shopData[color][3]}${!availableR3 ? ' (Round 3)' : ''}`,
                    shortLabel: `${isClosedR3 ? '🚫' : '✅'} R3: ${shopCosts[color][3]}`,
                    value: `${color}3`,
                    group: quadName
                });
                
                // Victory shops (always available)
                const isClosedVP = state.closedShops[`${color}vp`];
                const vpCost = color === 'purple' ? '4🟣' : (color === 'yellow' ? '4⭐' : `4${color === 'red' ? '🔴' : '🔵'}`);
                const vpPoints = color === 'yellow' ? '3' : '5';
                shopOptions.push({
                    label: `${isClosedVP ? 'Closed' : 'Open'} ${vpCost} - ${vpPoints} Victory Points`,
                    shortLabel: `${isClosedVP ? '🚫' : '✅'} VP: ${vpCost}`,
                    value: `${color}vp`,
                    group: quadName
                });
            });
            
            const choice = await showChoice(dispatch, 'Choose a shop to toggle (Closed/Open)', shopOptions, true);
            
            if (choice) {
                const isCurrentlyClosed = state.closedShops[choice];
                if (isCurrentlyClosed) {
                    // Open the shop
                    dispatch({
                        type: 'OPEN_SHOP',
                        shopId: choice
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Opened ${choice} shop` });
                } else {
                    // Close the shop
                    dispatch({
                        type: 'CLOSE_SHOP',
                        shopId: choice
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Closed ${choice} shop` });
                }
            }
        }
        
        // Execute blue 3 shop effect - ⭐ shop benefit
        async function executeBlue3Shop(player, dispatch, state) {
            // This is the same as blueAnyShopBenefit action
            // List all available shops from active game layers only
            const shopOptions = [];
            const colors = state.gameLayers ? Object.keys(state.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
            
            const shopInfo = {
                red: {
                    1: 'Repeat a worker\'s action',
                    2: 'Place the next player\'s worker',
                    3: 'Repeat all actions taken this round'
                },
                yellow: {
                    1: 'Double your next gain action',
                    2: 'Gain 5⭐',
                    3: 'Gain 9⭐'
                },
                blue: {
                    1: 'Close any shop this round',
                    2: 'Flip all shops status',
                    3: 'Gain any shop benefit'
                },
                purple: {
                    1: 'Take an extra turn',
                    2: 'Play 2 more workers',
                    3: 'Play all remaining workers'
                },
                gold: {
                    1: '1 Gold + 1 Any = 2 Gold',
                    2: '2 Gold + 2 Any = 4 Gold',
                    3: '3 Gold + 3 Any = Double Your Gold'
                }
            };
            
            const colorEmojis = {
                red: '🔴', yellow: '🟡', blue: '🔵', purple: '🟣', gold: '🟨'
            };
            
            const quadGroups = {
                'red': 'Red/Yellow',
                'yellow': 'Red/Yellow',
                'blue': 'Blue/Purple',
                'purple': 'Blue/Purple',
                'gold': 'Gold/White'
            };
            
            colors.forEach(color => {
                const group = quadGroups[color];
                
                // R1 shops
                shopOptions.push({
                    label: `${color} R1: ${shopInfo[color][1]}`,
                    shortLabel: `R1: ${colorEmojis[color]} ${shopInfo[color][1].substring(0, 20)}...`,
                    value: { color, round: 1 },
                    group: group
                });
                // R2 shops
                shopOptions.push({
                    label: `${color} R2: ${shopInfo[color][2]}`,
                    shortLabel: `R2: ${colorEmojis[color]} ${shopInfo[color][2].substring(0, 20)}...`,
                    value: { color, round: 2 },
                    group: group
                });
                // R3 shops
                shopOptions.push({
                    label: `${color} R3: ${shopInfo[color][3]}`,
                    shortLabel: `R3: ${colorEmojis[color]} ${shopInfo[color][3].substring(0, 20)}...`,
                    value: { color, round: 3 },
                    group: group
                });
                // Victory shops
                shopOptions.push({
                    label: `${color} Victory shop (3 VP)`,
                    shortLabel: `VP: ${colorEmojis[color]} 3 Victory Points`,
                    value: { color, round: 'vp' },
                    group: group
                });
            });
            
            const choice = await showChoice(dispatch, 'Choose any shop benefit (ignores closed status)', shopOptions, true);
            
            if (choice) {
                // Execute the shop benefit without paying cost
                if (choice.round === 'vp') {
                    // Grant 3 VP
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: player.id,
                        vp: 3
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Gained 3 VP from ${choice.color} victory shop` });
                } else {
                    // Execute regular shop effect
                    await executeShopBenefit(choice.color, choice.round, player, dispatch, state);
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Executed ${choice.color} R${choice.round} shop benefit` });
                }
                
                // BLUE AUTOMATIC VP: Player gets 1 VP when they activate a shop effect
                if (state.automaticVPs.blue) {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: player.id,
                        vp: 1,
                        source: 'blueAutomatic'
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP (activated a shop effect)` });
                }
            }
        }
        
        // Execute gold 1 shop effect - 1 Gold + 1 ⭐ = 2 Gold (gain 2 gold)
        async function executeGold1Shop(player, dispatch, state) {
            const goldAmount = player.resources.gold || 0;
            const otherGems = Object.entries(player.resources)
                .filter(([color, amount]) => color !== 'gold' && amount > 0)
                .reduce((sum, [, amount]) => sum + amount, 0);
            
            if (goldAmount < 1 || otherGems < 1) {
                const message = `Player ${player.id}: Gold R1 shop → Need 1 gold + 1 other gem`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Choose 1 gem to convert
            const selectedGems = await showStealGems(dispatch, 'Choose 1 gem (not gold) to pay', player, 1);
            
            if (!selectedGems || (selectedGems.gold || 0) > 0) {
                const message = `Player ${player.id}: Gold R1 shop → Cancelled or invalid selection`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Pay 1 gold and 1 other gem, gain 2 gold
            const resources = { gold: -1 + 2 }; // -1 cost + 2 gain = +1 net
            Object.entries(selectedGems).forEach(([color, amount]) => {
                resources[color] = -amount;
            });
            
            dispatch({
                type: 'UPDATE_RESOURCES',
                playerId: player.id,
                resources: resources
            });
            
            const message = `Player ${player.id}: Gold R1 shop → Paid 1 gold + 1 gem, gained 2 gold`;
            dispatch({ type: 'ADD_LOG', message });
        }
        
        // Execute gold 2 shop effect - 2 Gold + 2 ⭐ = 4 Gold (gain 4 gold)
        async function executeGold2Shop(player, dispatch, state) {
            const goldAmount = player.resources.gold || 0;
            const otherGems = Object.entries(player.resources)
                .filter(([color, amount]) => color !== 'gold' && amount > 0)
                .reduce((sum, [, amount]) => sum + amount, 0);
            
            if (goldAmount < 2 || otherGems < 2) {
                const message = `Player ${player.id}: Gold R2 shop → Need 2 gold + 2 other gems`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Choose 2 gems to convert
            const selectedGems = await showStealGems(dispatch, 'Choose 2 gems (not gold) to pay', player, 2);
            
            if (!selectedGems || (selectedGems.gold || 0) > 0) {
                const message = `Player ${player.id}: Gold R2 shop → Cancelled or invalid selection`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Pay 2 gold and 2 other gems, gain 4 gold
            const resources = { gold: -2 + 4 }; // -2 cost + 4 gain = +2 net
            Object.entries(selectedGems).forEach(([color, amount]) => {
                resources[color] = -amount;
            });
            
            dispatch({
                type: 'UPDATE_RESOURCES',
                playerId: player.id,
                resources: resources
            });
            
            const message = `Player ${player.id}: Gold R2 shop → Paid 2 gold + 2 gems, gained 4 gold`;
            dispatch({ type: 'ADD_LOG', message });
        }
        
        // Execute gold 3 shop effect - 3 Gold + 3 ⭐ = Double Your Gold (multiply current gold by 2)
        async function executeGold3Shop(player, dispatch, state) {
            const goldAmount = player.resources.gold || 0;
            const otherGems = Object.entries(player.resources)
                .filter(([color, amount]) => color !== 'gold' && amount > 0)
                .reduce((sum, [, amount]) => sum + amount, 0);
            
            if (goldAmount < 3 || otherGems < 3) {
                const message = `Player ${player.id}: Gold R3 shop → Need 3 gold + 3 other gems`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Choose 3 gems to convert
            const selectedGems = await showStealGems(dispatch, 'Choose 3 gems (not gold) to pay', player, 3);
            
            if (!selectedGems || (selectedGems.gold || 0) > 0) {
                const message = `Player ${player.id}: Gold R3 shop → Cancelled or invalid selection`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Pay 3 gold and 3 other gems, double gold
            const resources = { gold: -3 + (goldAmount * 2) }; // -3 cost + double current gold
            Object.entries(selectedGems).forEach(([color, amount]) => {
                resources[color] = -amount;
            });
            
            dispatch({
                type: 'UPDATE_RESOURCES',
                playerId: player.id,
                resources: resources
            });
            
            const message = `Player ${player.id}: Gold R3 shop → Paid 3 gold + 3 gems, doubled gold from ${goldAmount} to ${goldAmount * 2}`;
            dispatch({ type: 'ADD_LOG', message });
        }
        
        // Execute white 1 shop effect - Lose 1 VP, Gain 1 ⭐
        async function executeWhite1Shop(player, dispatch, state) {
            if (player.victoryPoints < 1) {
                const message = `Player ${player.id}: White R1 shop → Need at least 1 VP`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Lose 1 VP
            dispatch({
                type: 'UPDATE_VP',
                playerId: player.id,
                vp: -1,
                source: 'whiteShop'
            });
            
            // Choose 1 gem to gain
            const selectedGems = await showGemSelection(dispatch, 'Choose 1 gem to gain', 1);
            
            if (!selectedGems) {
                // If cancelled, give default gem
                const resources = { red: 1 };
                dispatch({ type: 'UPDATE_RESOURCES', playerId: player.id, resources });
                const message = `Player ${player.id}: White R1 shop → -1 VP, +1 red (default)`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            dispatch({
                type: 'UPDATE_RESOURCES',
                playerId: player.id,
                resources: selectedGems
            });
            
            const message = `Player ${player.id}: White R1 shop → -1 VP, gained 1 gem`;
            dispatch({ type: 'ADD_LOG', message });
        }
        
        // Execute white 2 shop effect - Lose 3 VP, Skip next player's turn
        async function executeWhite2Shop(player, dispatch, state) {
            if (player.victoryPoints < 3) {
                const message = `Player ${player.id}: White R2 shop → Need at least 3 VP`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Lose 3 VP
            dispatch({
                type: 'UPDATE_VP',
                playerId: player.id,
                vp: -3,
                source: 'whiteShop'
            });
            
            // Determine next player
            const currentIndex = state.turnOrder.indexOf(state.currentPlayer);
            const nextIndex = (currentIndex + state.turnDirection + state.turnOrder.length) % state.turnOrder.length;
            const nextPlayerId = state.turnOrder[nextIndex];
            
            // Set skip for next player
            const newSkippedTurns = { ...state.skippedTurns };
            newSkippedTurns[nextPlayerId] = (newSkippedTurns[nextPlayerId] || 0) + 1;
            dispatch({
                type: 'SET_SKIPPED_TURNS',
                skippedTurns: newSkippedTurns
            });
            
            const message = `Player ${player.id}: White R2 shop → -3 VP, Player ${nextPlayerId} will skip next turn`;
            dispatch({ type: 'ADD_LOG', message });
        }
        
        // Execute white 3 shop effect - Lose 5 VP, Move worker to unclaimed action
        async function executeWhite3Shop(player, dispatch, state) {
            if (player.victoryPoints < 5) {
                const message = `Player ${player.id}: White R3 shop → Need at least 5 VP`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Find player's workers
            const playerWorkers = Object.entries(state.occupiedSpaces)
                .filter(([actionId, playerId]) => playerId === player.id)
                .map(([actionId]) => actionId);
            
            if (playerWorkers.length === 0) {
                const message = `Player ${player.id}: White R3 shop → No workers to move`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Choose worker to move
            const workerOptions = playerWorkers.map(actionId => {
                // Find the action details
                let actionTitle = actionId;
                for (const [color, layer] of Object.entries(state.gameLayers || {})) {
                    const action = layer.actions.find(a => a.id === actionId);
                    if (action) {
                        actionTitle = `${color} - ${action.title}`;
                        break;
                    }
                }
                return {
                    label: actionTitle,
                    value: actionId
                };
            });
            
            const workerToMove = await showChoice(dispatch, 'Choose a worker to move', workerOptions);
            if (!workerToMove) return;
            
            // Find all unclaimed actions
            const allActions = [];
            Object.entries(state.gameLayers || {}).forEach(([color, layer]) => {
                layer.actions.forEach(action => {
                    if (action.round <= state.round && !state.occupiedSpaces[action.id]) {
                        allActions.push({
                            label: `${color} - ${action.title}`,
                            value: action.id,
                            color
                        });
                    }
                });
            });
            
            if (allActions.length === 0) {
                const message = `Player ${player.id}: White R3 shop → No unclaimed actions available`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            const newAction = await showChoice(dispatch, 'Choose an unclaimed action to move to', allActions);
            if (!newAction) return;
            
            // Lose 5 VP
            dispatch({
                type: 'UPDATE_VP',
                playerId: player.id,
                vp: -5,
                source: 'whiteShop'
            });
            
            // Move the worker
            const newOccupiedSpaces = { ...state.occupiedSpaces };
            delete newOccupiedSpaces[workerToMove];
            newOccupiedSpaces[newAction] = player.id;
            
            dispatch({
                type: 'UPDATE_OCCUPIED_SPACES',
                occupiedSpaces: newOccupiedSpaces
            });
            
            // Execute the new action
            await executeAction(newAction, player, dispatch, state, state.gameLayers, 0);
            
            const message = `Player ${player.id}: White R3 shop → -5 VP, moved worker to ${newAction}`;
            dispatch({ type: 'ADD_LOG', message });
        }
        
        // Execute black 1 shop effect - Steal 1 VP from another player
        async function executeBlack1Shop(player, dispatch, state) {
            const otherPlayers = state.players.filter(p => p.id !== player.id && p.victoryPoints > 0);
            
            if (otherPlayers.length === 0) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Black R1 shop → No valid targets to steal VP from` });
                return;
            }
            
            const targetPlayer = await showPlayerSelection(dispatch, 'Choose a player to steal 1 VP from', otherPlayers);
            
            if (!targetPlayer) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Black R1 shop → Cancelled` });
                return;
            }
            
            // Remove 1 VP from target
            dispatch({
                type: 'UPDATE_VP',
                playerId: targetPlayer.id,
                vp: -1,
                source: 'blackShop'
            });
            
            // Add 1 VP to current player
            dispatch({
                type: 'UPDATE_VP',
                playerId: player.id,
                vp: 1,
                source: 'blackShop'
            });
            
            dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Black R1 shop → Stole 1 VP from Player ${targetPlayer.id}` });
            
            // BLACK AUTOMATIC VP: Gain 1 VP when stealing
            dispatch({
                type: 'UPDATE_VP',
                playerId: player.id,
                vp: 1,
                source: 'blackAutomatic'
            });
            dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP (Black automatic: stealing bonus)` });
        }
        
        // Execute black 2 shop effect - Steal 3 VP from another player
        async function executeBlack2Shop(player, dispatch, state) {
            const otherPlayers = state.players.filter(p => p.id !== player.id && p.victoryPoints > 0);
            
            if (otherPlayers.length === 0) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Black R2 shop → No valid targets to steal VP from` });
                return;
            }
            
            const targetPlayer = await showPlayerSelection(dispatch, 'Choose a player to steal 3 VP from', otherPlayers);
            
            if (!targetPlayer) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Black R2 shop → Cancelled` });
                return;
            }
            
            const vpToSteal = Math.min(3, targetPlayer.victoryPoints);
            
            // Remove VP from target
            dispatch({
                type: 'UPDATE_VP',
                playerId: targetPlayer.id,
                vp: -vpToSteal,
                source: 'blackShop'
            });
            
            // Add VP to current player
            dispatch({
                type: 'UPDATE_VP',
                playerId: player.id,
                vp: vpToSteal,
                source: 'blackShop'
            });
            
            dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Black R2 shop → Stole ${vpToSteal} VP from Player ${targetPlayer.id}` });
            
            // BLACK AUTOMATIC VP: Gain 1 VP when stealing
            dispatch({
                type: 'UPDATE_VP',
                playerId: player.id,
                vp: 1,
                source: 'blackAutomatic'
            });
            dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP (Black automatic: stealing bonus)` });
        }
        
        // Execute black 3 shop effect - Steal 5 VP from another player
        async function executeBlack3Shop(player, dispatch, state) {
            const otherPlayers = state.players.filter(p => p.id !== player.id && p.victoryPoints > 0);
            
            if (otherPlayers.length === 0) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Black R3 shop → No valid targets to steal VP from` });
                return;
            }
            
            const targetPlayer = await showPlayerSelection(dispatch, 'Choose a player to steal 5 VP from', otherPlayers);
            
            if (!targetPlayer) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Black R3 shop → Cancelled` });
                return;
            }
            
            const vpToSteal = Math.min(5, targetPlayer.victoryPoints);
            
            // Remove VP from target
            dispatch({
                type: 'UPDATE_VP',
                playerId: targetPlayer.id,
                vp: -vpToSteal,
                source: 'blackShop'
            });
            
            // Add VP to current player
            dispatch({
                type: 'UPDATE_VP',
                playerId: player.id,
                vp: vpToSteal,
                source: 'blackShop'
            });
            
            dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Black R3 shop → Stole ${vpToSteal} VP from Player ${targetPlayer.id}` });
            
            // BLACK AUTOMATIC VP: Gain 1 VP when stealing
            dispatch({
                type: 'UPDATE_VP',
                playerId: player.id,
                vp: 1,
                source: 'blackAutomatic'
            });
            dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP (Black automatic: stealing bonus)` });
        }
        
        // Execute any shop benefit by shop ID
        async function executeShopBenefit(shopColor, shopRound, player, dispatch, state) {
            const shopId = `${shopColor}${shopRound}`;
            
            switch(shopId) {
                case 'red1':
                    // Repeat a worker's action
                    await executeRepeatAction(player, dispatch, state, state.gameLayers);
                    break;
                case 'red2':
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: player.id,
                        effect: 'Can place the next player\'s worker'
                    });
                    break;
                case 'red3':
                    // Repeat all actions taken this round
                    await executeRed3Shop(player, dispatch, state);
                    break;
                case 'yellow1':
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: player.id,
                        effect: 'Next gain will be doubled'
                    });
                    break;
                case 'yellow2':
                    await executeYellow2Shop(player, dispatch, state);
                    break;
                case 'yellow3':
                    await executeYellow3Shop(player, dispatch, state);
                    break;
                case 'blue1':
                    await executeBlue1Shop(player, dispatch, state);
                    break;
                case 'blue2':
                    // Flip all shops
                    dispatch({ type: 'FLIP_ALL_SHOPS' });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: All shops flipped!` });
                    break;
                case 'blue3':
                    await executeBlue3Shop(player, dispatch, state);
                    break;
                case 'purple1':
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: player.id,
                        effect: 'Will take an extra turn after this one'
                    });
                    break;
                case 'purple2':
                    dispatch({
                        type: 'ADD_WORKERS_TO_PLACE',
                        count: 2
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Can place 2 more workers this turn!` });
                    break;
                case 'purple3':
                    const workersRemaining = player.workersLeft;
                    if (workersRemaining > 0) {
                        dispatch({
                            type: 'ADD_WORKERS_TO_PLACE',
                            count: workersRemaining
                        });
                        dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Can place all ${workersRemaining} remaining workers!` });
                    }
                    break;
                case 'gold1':
                    // 1 Gold + 1 ⭐ = 2 Gold
                    await executeGold1Shop(player, dispatch, state);
                    break;
                case 'gold2':
                    // 2 Gold + 2 ⭐ = 4 Gold
                    await executeGold2Shop(player, dispatch, state);
                    break;
                case 'gold3':
                    // 3 Gold + 3 ⭐ = Double Your Gold
                    await executeGold3Shop(player, dispatch, state);
                    break;
                case 'white1':
                    // Lose 1 VP, Gain 1 ⭐
                    await executeWhite1Shop(player, dispatch, state);
                    break;
                case 'white2':
                    // Lose 3 VP, Skip next player's turn
                    await executeWhite2Shop(player, dispatch, state);
                    break;
                case 'white3':
                    // Lose 5 VP, Move worker to unclaimed action
                    await executeWhite3Shop(player, dispatch, state);
                    break;
                case 'black1':
                    // Steal 1 VP from another player
                    await executeBlack1Shop(player, dispatch, state);
                    break;
                case 'black2':
                    // Steal 3 VP from another player
                    await executeBlack2Shop(player, dispatch, state);
                    break;
                case 'black3':
                    // Steal 5 VP from another player
                    await executeBlack3Shop(player, dispatch, state);
                    break;
                default:
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Shop benefit ${shopId} not implemented yet` });
            }
        }
        
        // Execute red 3 shop effect - Repeat all actions taken this round
        async function executeRed3Shop(player, dispatch, state) {
            if (state.roundActions.length === 0) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: No actions have been taken this round!` });
                return;
            }
            
            // Show list of all actions taken this round
            const actionOptions = state.roundActions.map((roundAction, index) => {
                // Find the action details
                let actionTitle = roundAction.actionId;
                let layerColor = '';
                
                Object.entries(state.gameLayers || {}).forEach(([color, layer]) => {
                    const action = layer.actions.find(a => a.id === roundAction.actionId);
                    if (action) {
                        actionTitle = action.title;
                        layerColor = color;
                    }
                });
                
                return {
                    label: `Player ${roundAction.playerId}'s ${layerColor} action: ${actionTitle}`,
                    value: roundAction.actionId
                };
            });
            
            // Let player choose which actions to repeat
            const message = 'Choose actions to repeat (you can repeat all of them!)';
            let continueChoosing = true;
            const repeatedActions = [];
            
            while (continueChoosing && actionOptions.length > 0) {
                const choice = await showChoice(dispatch, message, [
                    ...actionOptions,
                    { label: 'Done repeating actions', value: 'done' }
                ]);
                
                if (!choice || choice === 'done') {
                    continueChoosing = false;
                } else {
                    repeatedActions.push(choice);
                    // Execute the action
                    await executeAction(choice, player, dispatch, state, state.gameLayers, 0);
                    
                    // RED AUTOMATIC VP: Gain 1 VP for red action
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: player.id,
                        vp: 1
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action (repeat)` });
                }
            }
            
            if (repeatedActions.length > 0) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Repeated ${repeatedActions.length} actions from this round!` });
            }
        }

        // Effect activation function
        async function activateEffect(effect, playerId, effectIndex, dispatch, state) {
            const player = state.players.find(p => p.id === playerId);
            
            if (effect.includes('Can repeat a worker\'s action')) {
                // Find all occupied spaces that belong to the player
                const playerSpaces = Object.entries(state.occupiedSpaces)
                    .filter(([spaceId, pid]) => pid === playerId)
                    .map(([spaceId]) => spaceId);
                
                if (playerSpaces.length === 0) {
                    alert('No workers to repeat!');
                    return;
                }
                
                if (playerSpaces.length === 1) {
                    // Auto-select the only option
                    const spaceId = playerSpaces[0];
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    
                    const message = `Player ${playerId}: Used shop effect to repeat ${actionTitle}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    // Execute the action again
                    await executeAction(spaceId, player, dispatch, state, gameLayers);
                } else {
                    // Multiple options, let player choose
                    const repeatOptions = playerSpaces.map(spaceId => {
                        let actionTitle = spaceId;
                        for (const layerData of Object.values(gameLayers)) {
                            const action = layerData.actions.find(a => a.id === spaceId);
                            if (action) {
                                actionTitle = action.title;
                                break;
                            }
                        }
                        return {
                            label: `Repeat: ${actionTitle}`,
                            value: spaceId
                        };
                    });
                    
                    const choice = await showChoice(dispatch, 
                        'Choose an action to repeat', 
                        repeatOptions
                    );
                    
                    if (choice) {
                        const message = `Player ${playerId}: Used shop effect to repeat ${choice}`;
                        dispatch({ type: 'ADD_LOG', message });
                        
                        // Execute the chosen action again
                        await executeAction(choice, player, dispatch, state, gameLayers);
                    }
                }
                
                // Remove the effect after use
                dispatch({
                    type: 'UPDATE_PLAYER_EFFECTS',
                    playerId: playerId,
                    effects: (player.effects || []).filter((_, i) => i !== effectIndex)
                });
                
            } else if (effect.includes('Can close ⭐ shop this round')) {
                // Choose which shop to close
                const shopOptions = [
                    { label: 'Red Shop', value: 'red' },
                    { label: 'Yellow Shop', value: 'yellow' },
                    { label: 'Blue Shop', value: 'blue' },
                    { label: 'Purple Shop', value: 'purple' }
                ];
                
                const shopToClose = await showChoice(dispatch, 'Choose shop to close this round', shopOptions);
                if (shopToClose) {
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: playerId,
                        effect: `${shopToClose.charAt(0).toUpperCase() + shopToClose.slice(1)} shop is closed this round`
                    });
                    
                    dispatch({ type: 'ADD_LOG', message: `Player ${playerId}: Closed ${shopToClose} shop for this round` });
                }
                
                // Remove the activatable effect
                dispatch({
                    type: 'UPDATE_PLAYER_EFFECTS',
                    playerId: playerId,
                    effects: (player.effects || []).filter((_, i) => i !== effectIndex)
                });
                
            } else if (effect.includes('Will take an extra turn after this one')) {
                // Check if player is already at the end of snake (would get 2 turns naturally)
                const currentIndex = state.turnOrder.indexOf(state.currentPlayer);
                const isAtSnakeEnd = (state.turnDirection === 1 && currentIndex === state.turnOrder.length - 1) ||
                                   (state.turnDirection === -1 && currentIndex === 0);
                
                if (isAtSnakeEnd) {
                    alert('You are already at the end of the turn snake and will get another turn naturally. Extra turn effect not needed.');
                } else {
                    // Apply extra turn effect
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: state.currentPlayer,
                        effect: 'Will take an extra turn after this one'
                    });
                    
                    dispatch({ type: 'ADD_LOG', message: `Player ${state.currentPlayer}: Will take an extra turn after this one` });
                }
                
                // Remove the activatable effect regardless
                dispatch({
                    type: 'UPDATE_PLAYER_EFFECTS',
                    playerId: playerId,
                    effects: (player.effects || []).filter((_, i) => i !== effectIndex)
                });
                
            } else if (effect.includes('Can place the next player\'s worker')) {
                alert('Place next player\'s worker effect not implemented yet');
            } else if (effect.includes('Can undo the last player\'s turn')) {
                alert('Undo turn effect not implemented yet');
            }
        }

        // Get effect button for activatable effects
        function getEffectButton(effect, playerId, effectIndex) {
            const { state, dispatch } = useGame();
            
            const activatableEffects = [
                'Can repeat a worker\'s action',
                'Can close ⭐ shop this round',
                'Will take an extra turn after this one',
                'Can place the next player\'s worker',
                'Can undo the last player\'s turn'
            ];
            
            const isActivatable = activatableEffects.some(ae => effect.includes(ae));
            const isCurrentPlayer = state.currentPlayer === playerId;
            
            if (isActivatable && isCurrentPlayer) {
                return React.createElement('button', {
                    key: 'activate',
                    onClick: () => activateEffect(effect, playerId, effectIndex, dispatch, state),
                    className: 'bg-blue-500 hover:bg-blue-600 text-white text-xs px-2 py-1 rounded ml-2'
                }, 'Use');
            }
            
            return null;
        }

        // Player Card Component
        function PlayerCard({ player, isCurrentPlayer, onEndTurn }) {
            const { state } = useGame();
            
            // Get active colors from current game layers
            const activeColors = state.gameLayers ? Object.keys(state.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
            
            const getPlayerStyle = () => {
                let baseStyle = "glass rounded-lg shadow-lg p-4 transition-all duration-300";
                if (isCurrentPlayer) {
                    baseStyle += " ring-4 ring-blue-400 ring-opacity-60 shadow-xl transform scale-105 pulse-current";
                }
                return baseStyle;
            };
            
            const getResourceIcon = (color, amount) => {
                const colors = {
                    red: 'bg-red-500',
                    yellow: 'bg-yellow-500', 
                    blue: 'bg-blue-500',
                    purple: 'bg-purple-500',
                    gold: 'bg-yellow-600',
                    white: 'bg-gray-100',
                    black: 'bg-gray-800',
                    silver: 'bg-gray-400'
                };
                
                const gemIcons = {
                    red: '🔴',
                    yellow: '🟡', 
                    blue: '🔵',
                    purple: '🟣',
                    gold: '🟨',
                    white: '⚪',
                    black: '⚫',
                    silver: '🩶'
                };
                
                const gemIcon = gemIcons[color] || '💎';
                
                return React.createElement('div', {
                    key: color,
                    className: `w-12 h-12 rounded-lg ${colors[color]} flex flex-col items-center justify-center text-white font-bold text-sm shadow-lg hover:shadow-xl transform hover:scale-110 transition-all`
                }, [
                    React.createElement('div', { key: 'icon', className: 'text-lg' }, gemIcon),
                    React.createElement('div', { key: 'amount', className: 'text-xs' }, amount)
                ]);
            };
            
            return React.createElement('div', { className: getPlayerStyle() }, [
                React.createElement('div', { key: 'header', className: 'flex items-center justify-between mb-4' }, [
                    React.createElement('div', { key: 'name-section' }, [
                        React.createElement('h3', { key: 'name', className: 'font-bold text-lg text-gray-800' }, [
                            player.name,
                            React.createElement('span', { key: 'emoji', className: 'ml-2 text-xl' }, player.emoji || '👤'),
                            isCurrentPlayer && React.createElement('span', { key: 'indicator', className: 'text-blue-500 ml-2' }, '🎯')
                        ]),
                        isCurrentPlayer && React.createElement('div', { key: 'phase', className: 'text-xs text-gray-600 mt-1' }, 
                            !state.workerPlacedThisTurn ? '🏪 Shop Available' :
                            state.workersToPlace > 0 ? '👷 Placing Workers' :
                            !state.shopUsedAfterWorkers ? '🏪 Shop Available' : '✅ Turn Complete'
                        )
                    ]),
                    React.createElement('div', { 
                        key: 'vp', 
                        className: 'text-2xl font-bold text-blue-600 bg-blue-100 px-3 py-1 rounded-lg relative group cursor-help',
                        title: getVPBreakdown(player.vpSources)
                    }, [
                        `${player.victoryPoints} VP`,
                        // VP breakdown tooltip
                        React.createElement('div', {
                            key: 'vp-tooltip',
                            className: 'absolute bottom-full right-0 mb-2 bg-gray-800 text-white text-xs p-2 rounded shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap z-10'
                        }, getVPBreakdownDisplay(player.vpSources))
                    ])
                ]),
                React.createElement('div', { key: 'resources', className: 'flex gap-3 mb-4 justify-center' }, 
                    activeColors.map(color => 
                        getResourceIcon(color, player.resources[color] || 0)
                    )
                ),
                React.createElement('div', { key: 'workers', className: 'text-center text-gray-700 font-semibold mb-3' }, [
                    React.createElement('div', { key: 'left', className: 'flex items-center justify-center gap-1' }, [
                        React.createElement('span', { key: 'label' }, 'Workers: '),
                        React.createElement('span', { key: 'emojis', className: 'text-2xl' }, 
                            Array(player.workersLeft).fill(player.emoji || '👤').join('')
                        )
                    ]),
                    isCurrentPlayer && state.workersToPlace > 1 && React.createElement('div', { 
                        key: 'toplace', 
                        className: 'text-purple-600 font-bold animate-pulse' 
                    }, `Can place ${state.workersToPlace} workers this turn!`)
                ]),
                // Status indicators
                (state.skippedTurns && state.skippedTurns[player.id] > 0) && React.createElement('div', { 
                    key: 'skip-status', 
                    className: 'bg-orange-100 border border-orange-300 rounded px-3 py-2 mb-3 text-sm font-medium text-orange-700 flex items-center justify-center gap-2' 
                }, [
                    React.createElement('span', { key: 'icon' }, '⏭️'),
                    React.createElement('span', { key: 'text' }, 'Skipping next turn')
                ]),
                (state.waitingForOthers && state.waitingForOthers[player.id]) && React.createElement('div', { 
                    key: 'waiting-status', 
                    className: 'bg-blue-100 border border-blue-300 rounded px-3 py-2 mb-3 text-sm font-medium text-blue-700 flex items-center justify-center gap-2' 
                }, [
                    React.createElement('span', { key: 'icon' }, '⏳'),
                    React.createElement('span', { key: 'text' }, 'Waiting for others')
                ]),
                (player.effects && player.effects.length > 0) && React.createElement('div', { key: 'effects', className: 'mb-3' }, [
                    React.createElement('div', { key: 'label', className: 'text-xs font-semibold text-gray-600 mb-1' }, 'Effects:'),
                    ...(player.effects || []).map((effect, index) => 
                        React.createElement('div', { 
                            key: `effect-${index}`, 
                            className: 'bg-yellow-100 border border-yellow-300 rounded px-2 py-1 mb-1 text-xs flex justify-between items-center' 
                        }, [
                            React.createElement('span', { key: 'text' }, effect),
                            getEffectButton(effect, player.id, index)
                        ])
                    )
                ]),
                isCurrentPlayer && React.createElement(EndTurnButton, { key: 'end-turn', onEndTurn })
            ]);
        }

        // Game Layer Component - Card-focused layout with shops at top
        function GameLayer({ color, title, icon, actions, round }) {
            const { state } = useGame();
            
            const getLayerStyle = () => {
                const baseStyle = "glass rounded-lg shadow-lg p-4 border-t-6 hover:shadow-xl transition-all duration-300 h-full flex flex-col";
                switch (color) {
                    case 'red': return `${baseStyle} border-t-red-500`;
                    case 'yellow': return `${baseStyle} border-t-yellow-500`;
                    case 'blue': return `${baseStyle} border-t-blue-500`;
                    case 'purple': return `${baseStyle} border-t-purple-500`;
                    case 'gold': return `${baseStyle} border-t-yellow-600`;
                    case 'white': return `${baseStyle} border-t-gray-300`;
                    case 'black': return `${baseStyle} border-t-gray-800`;
                    case 'silver': return `${baseStyle} border-t-gray-400`;
                    default: return `${baseStyle} border-t-gray-500`;
                }
            };
            
            const getIconColor = () => {
                switch (color) {
                    case 'red': return 'text-red-500';
                    case 'yellow': return 'text-yellow-500';
                    case 'blue': return 'text-blue-500';
                    case 'purple': return 'text-purple-500';
                    case 'gold': return 'text-yellow-600';
                    case 'white': return 'text-gray-600';
                    case 'black': return 'text-gray-800';
                    case 'silver': return 'text-gray-400';
                    default: return 'text-gray-500';
                }
            };
            
            // Show all actions, not just available ones
            const availableActions = actions; // Remove filtering to show all actions
            
            return React.createElement('div', { className: getLayerStyle() }, [
                // Card Header - Layer title and color
                React.createElement('div', { key: 'header', className: 'flex justify-between items-center mb-2' }, [
                    React.createElement('h2', { key: 'title', className: `text-xl font-bold ${getIconColor()}` }, 
                        `${icon} ${color.charAt(0).toUpperCase() + color.slice(1)}`),
                    React.createElement('span', { key: 'round', className: 'text-gray-600 text-sm bg-white px-2 py-1 rounded shadow' }, 
                        `Round ${round}`)
                ]),
                
                // Automatic VP Display
                React.createElement('div', { key: 'auto-vp', className: 'text-xs text-gray-700 bg-yellow-100 rounded p-1 mb-2' }, 
                    getAutomaticVPText(color)
                ),
                
                // Shops Section - Compact horizontal layout
                React.createElement('div', { key: 'shops', className: 'mb-3 bg-white bg-opacity-10 rounded-lg p-3' }, [
                    React.createElement('div', { key: 'shop-header', className: 'text-sm font-semibold text-gray-700 mb-1 flex items-center justify-between' }, [
                        React.createElement('span', { key: 'label' }, '🏪 Shops'),
                        state.shopCostModifier !== 0 && React.createElement('span', { 
                            key: 'modifier', 
                            className: `text-xs px-2 py-1 rounded ${state.shopCostModifier > 0 ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}`
                        }, `${state.shopCostModifier > 0 ? '+' : ''}${state.shopCostModifier} ⭐ cost`)
                    ]),
                    React.createElement('div', { key: 'shop-grid', className: 'grid grid-cols-4 gap-3' }, [
                        React.createElement(CompactShop, { key: 'shop-r1', color, round: 1, label: 'R1', currentRound: round }),
                        React.createElement(CompactShop, { key: 'shop-r2', color, round: 2, label: 'R2', currentRound: round }),
                        React.createElement(CompactShop, { key: 'shop-r3', color, round: 3, label: 'R3', currentRound: round }),
                        React.createElement(CompactVictoryShop, { key: 'shop-vp', color })
                    ])
                ]),
                
                // Action Spaces Section - Below shops
                React.createElement('div', { key: 'actions-section', className: 'flex-1' }, [
                    React.createElement('h3', { key: 'actions-title', className: 'text-lg font-semibold mb-3 text-gray-800' }, '⚡ Actions'),
                    React.createElement('div', { key: 'actions', className: 'grid grid-cols-2 gap-2' }, 
                        availableActions.map(action => 
                            React.createElement(ActionSpace, {
                                key: action.id,
                                actionId: action.id,
                                title: action.title,
                                description: action.description,
                                round: action.round,
                                available: action.round <= round,
                                compact: true // New prop for smaller action spaces
                            })
                        )
                    )
                ])
            ]);
        }

        // Regular Shop Component
        function RegularShop({ color, round }) {
            const { state, dispatch } = useGame();
            
            const shopData = {
                red: {
                    1: { cost: { red: 1, any: 2 }, effect: 'Repeat a worker\'s action' },
                    2: { cost: { red: 2, any: 2 }, effect: 'Place the next player\'s worker' },
                    3: { cost: { red: 3, any: 3 }, effect: 'Repeat all actions taken this round by ⭐ player' }
                },
                yellow: {
                    1: { cost: { yellow: 1, any: 1 }, effect: 'Double your next gain action' },
                    2: { cost: { yellow: 2, any: 2 }, effect: 'Gain 5⭐' },
                    3: { cost: { yellow: 3, any: 3 }, effect: 'Gain 9⭐' }
                },
                blue: {
                    1: { cost: { blue: 1, any: 1 }, effect: 'Close ⭐ shop this round' },
                    2: { cost: { blue: 2, any: 2 }, effect: 'Gain a shop benefit then close that shop' },
                    3: { cost: { blue: 3, any: 3 }, effect: 'Flip the status of all shops, including victory shops' }
                },
                purple: {
                    1: { cost: { purple: 1, any: 1 }, effect: 'Take an extra turn after this one' },
                    2: { cost: { purple: 2, any: 2 }, effect: 'Play 2 more workers this turn' },
                    3: { cost: { purple: 3, any: 3 }, effect: 'Play the rest of your workers' }
                },
                gold: {
                    1: { cost: { gold: 1, any: 1 }, effect: '1 Gold + 1 ⭐ = 2 Gold' },
                    2: { cost: { gold: 2, any: 2 }, effect: '2 Gold + 2 ⭐ = 4 Gold' },
                    3: { cost: { gold: 3, any: 3 }, effect: '3 Gold + 3 ⭐ = Double Your Gold' }
                },
                white: {
                    1: { cost: { vp: 1, any: 1 }, effect: 'Lose 1 VP, Gain 1 ⭐' },
                    2: { cost: { vp: 3, any: 2 }, effect: 'Lose 3 VP, Skip Next Player\'s Turn' },
                    3: { cost: { vp: 5, any: 3 }, effect: 'Lose 5 VP, Move Worker to Unclaimed Action' }
                },
                black: {
                    1: { cost: { black: 1, any: 1 }, effect: 'Steal 1 VP from another player' },
                    2: { cost: { black: 2, any: 2 }, effect: 'Steal 3 VP from another player' },
                    3: { cost: { black: 3, any: 3 }, effect: 'Steal 5 VP from another player' }
                },
                silver: {
                    1: { cost: { silver: 1, any: 1 }, effect: '1 Silver + 1 Any = 2 VP' },
                    2: { cost: { silver: 2, any: 2 }, effect: 'Gain 4 VP, Pick Another Player to Gain 4 VP' },
                    3: { cost: { silver: 3, any: 3 }, effect: 'Gain 7 Silver, Each Other Player Gains 2 Silver' }
                }
            };
            
            const handlePurchase = async (shopRound) => {
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                // Check if this shop is closed
                const shopId = `${color}${shopRound}`;
                if (state.closedShops[shopId]) {
                    alert(`${color.charAt(0).toUpperCase() + color.slice(1)} R${shopRound} shop is closed!`);
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                const shop = shopData[color][shopRound];
                
                // Check if player has enough resources
                const vpRequired = shop.cost.vp || 0;
                const colorRequired = shop.cost[color] || 0;
                let anyRequired = shop.cost.any || 0;
                
                // Apply cost modifier
                anyRequired = Math.max(0, anyRequired + state.shopCostModifier);
                
                // For WHITE shops that cost VP
                if (vpRequired > 0) {
                    if (currentPlayer.victoryPoints < vpRequired) {
                        alert(`Need ${vpRequired} VP. You have ${currentPlayer.victoryPoints}.`);
                        return;
                    }
                }
                
                // For shops that cost specific color resources
                if (colorRequired > 0 && currentPlayer.resources[color] < colorRequired) {
                    alert(`Need ${colorRequired} ${color} gems. You have ${currentPlayer.resources[color]}.`);
                    return;
                }
                
                if (anyRequired > 0) {
                    const totalAllGems = Object.values(currentPlayer.resources).reduce((sum, amount) => sum + amount, 0);
                    const totalAvailableForAny = totalAllGems - colorRequired; // Subtract the specific color requirement
                    
                    if (totalAvailableForAny < anyRequired) {
                        alert(`Need ${anyRequired} additional gems of ⭐ color. You have ${totalAvailableForAny} available.`);
                        return;
                    }
                }
                
                // Deduct VP cost if applicable
                if (vpRequired > 0) {
                    dispatch({ 
                        type: 'UPDATE_VP', 
                        playerId: currentPlayer.id, 
                        vp: -vpRequired,
                        source: 'shopCost'
                    });
                }
                
                // Deduct the specific color cost
                const resourceCost = {};
                if (colorRequired > 0) {
                    resourceCost[color] = -colorRequired;
                }
                
                // Deduct "any" cost - let player choose colors
                if (anyRequired > 0) {
                    let remaining = anyRequired;
                    
                    while (remaining > 0) {
                        const colorOptions = ['red', 'yellow', 'blue', 'purple']
                            .filter(c => {
                                const currentAmount = currentPlayer.resources[c];
                                const alreadySpent = resourceCost[c] ? -resourceCost[c] : 0;
                                return (currentAmount - alreadySpent) > 0;
                            })
                            .map(c => {
                                const currentAmount = currentPlayer.resources[c];
                                const alreadySpent = resourceCost[c] ? -resourceCost[c] : 0;
                                const available = currentAmount - alreadySpent;
                                return {
                                    label: `${c.charAt(0).toUpperCase() + c.slice(1)} (${available} available)`,
                                    value: c
                                };
                            });
                        
                        if (colorOptions.length === 0) break;
                        
                        const choice = await showChoice(dispatch, 
                            `Choose color to spend (${remaining} more needed)`, 
                            colorOptions
                        );
                        
                        if (choice) {
                            resourceCost[choice] = (resourceCost[choice] || 0) - 1;
                            remaining -= 1;
                        } else {
                            // If cancelled, auto-select first available
                            const autoChoice = colorOptions[0].value;
                            resourceCost[autoChoice] = (resourceCost[autoChoice] || 0) - 1;
                            remaining -= 1;
                        }
                    }
                }
                
                dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                
                // Apply the shop effect immediately
                switch(`${color}${shopRound}`) {
                    case 'red1':
                        // Repeat a worker's action - execute immediately
                        await executeRepeatAction(currentPlayer, dispatch, state, state.gameLayers);
                        break;
                    case 'red2':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Can place the next player\'s worker'
                        });
                        break;
                    case 'yellow1':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Next gain will be doubled'
                        });
                        break;
                    case 'yellow2':
                        // Gain 5 resources ⭐ colors + everyone gains resource - execute immediately
                        await executeYellow2Shop(currentPlayer, dispatch, state);
                        break;
                    case 'yellow3':
                        // Gain 9 resources ⭐ colors + everyone gains 1 each - execute immediately
                        await executeYellow3Shop(currentPlayer, dispatch, state);
                        break;
                    case 'red3':
                        // Repeat all actions taken this round by any player - execute immediately
                        await executeRed3Shop(currentPlayer, dispatch, state);
                        break;
                    case 'blue1':
                        // Close any shop this round - let player choose
                        await executeBlue1Shop(currentPlayer, dispatch, state);
                        break;
                    case 'blue2':
                        // Flip all shops immediately
                        dispatch({ type: 'FLIP_ALL_SHOPS' });
                        dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: All shops flipped!` });
                        break;
                    case 'blue3':
                        // Gain any shop benefit (even if closed) - execute immediately
                        await executeBlue3Shop(currentPlayer, dispatch, state);
                        break;
                    case 'purple1':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Will take an extra turn after this one'
                        });
                        break;
                    case 'purple2':
                        // Play 2 more workers this turn
                        dispatch({
                            type: 'SET_WORKERS_TO_PLACE',
                            count: 2
                        });
                        dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Can place 2 more workers this turn!` });
                        break;
                    case 'purple3':
                        // Play the rest of your workers
                        const workersRemaining = currentPlayer.workersLeft;
                        if (workersRemaining > 0) {
                            dispatch({
                                type: 'SET_WORKERS_TO_PLACE',
                                count: workersRemaining
                            });
                            dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Can place all ${workersRemaining} remaining workers!` });
                        }
                        break;
                    case 'silver1':
                        // 1 Silver + 1 ⭐ = 2 VP
                        dispatch({
                            type: 'UPDATE_VP',
                            playerId: currentPlayer.id,
                            vp: 2,
                            source: 'silverShop'
                        });
                        dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Silver R1 shop → +2 VP` });
                        break;
                    case 'silver2':
                        // Gain 4 VP, Pick Another Player to Gain 4 VP
                        dispatch({
                            type: 'UPDATE_VP',
                            playerId: currentPlayer.id,
                            vp: 4,
                            source: 'silverShop'
                        });
                        
                        // Choose another player to give 4 VP
                        const otherPlayers = state.players.filter(p => p.id !== currentPlayer.id);
                        const targetPlayer = await showPlayerSelection(dispatch, 'Choose a player to also gain 4 VP', otherPlayers);
                        
                        if (targetPlayer) {
                            dispatch({
                                type: 'UPDATE_VP',
                                playerId: targetPlayer.id,
                                vp: 4,
                                source: 'silverShop'
                            });
                            dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Silver R2 shop → +4 VP, Player ${targetPlayer.id} +4 VP` });
                        } else {
                            // If cancelled, pick first other player
                            const firstOther = otherPlayers[0];
                            if (firstOther) {
                                dispatch({
                                    type: 'UPDATE_VP',
                                    playerId: firstOther.id,
                                    vp: 4,
                                    source: 'silverShop'
                                });
                                dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Silver R2 shop → +4 VP, Player ${firstOther.id} +4 VP` });
                            } else {
                                dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Silver R2 shop → +4 VP (no other players)` });
                            }
                        }
                        break;
                    case 'silver3':
                        // Gain 7 Silver, Each Other Player Gains 2 Silver
                        dispatch({
                            type: 'UPDATE_RESOURCES',
                            playerId: currentPlayer.id,
                            resources: { silver: 7 }
                        });
                        
                        // Give other players 2 silver each
                        const otherPlayersSilver = state.players.filter(p => p.id !== currentPlayer.id);
                        otherPlayersSilver.forEach(otherPlayer => {
                            dispatch({
                                type: 'UPDATE_RESOURCES',
                                playerId: otherPlayer.id,
                                resources: { silver: 2 }
                            });
                        });
                        
                        dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Silver R3 shop → +7 silver, all other players +2 silver` });
                        break;
                }
                
                const message = `Player ${currentPlayer.id}: Bought ${color} R${shopRound} shop`;
                dispatch({ type: 'ADD_LOG', message });
                console.log(message);
                
                // BLUE AUTOMATIC VP: Player gets 1 VP when they activate a shop effect
                if (state.automaticVPs.blue) {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: currentPlayer.id,
                        vp: 1,
                        source: 'blueAutomatic'
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: +1 VP (activated a shop effect)` });
                }
            };
            
            const round1Shop = shopData[color][1];
            const round2Shop = shopData[color][2];
            
            return React.createElement('div', { 
                className: 'bg-gradient-to-br from-yellow-100 to-yellow-200 border-2 border-yellow-400 rounded-lg p-3 shadow-md hover:shadow-lg transition-all' 
            }, [
                React.createElement('div', { key: 'title', className: 'text-center font-bold text-yellow-700 mb-2 text-sm' }, `🛒 ${color.charAt(0).toUpperCase() + color.slice(1)}`),
                
                React.createElement('div', { key: 'round1', className: 'text-xs mb-2' }, [
                    React.createElement('div', { key: 'desc', className: 'mb-1 text-yellow-800' }, 
                        `R1: ${round1Shop.effect.length > 20 ? round1Shop.effect.substring(0, 20) + '...' : round1Shop.effect}`),
                    React.createElement('button', {
                        key: 'btn',
                        onClick: () => handlePurchase(1),
                        className: 'bg-yellow-600 hover:bg-yellow-700 text-white px-2 py-1 rounded text-xs transition-colors w-full'
                    }, 'Buy R1')
                ]),
                
                round >= 2 && React.createElement('div', { key: 'round2', className: 'text-xs' }, [
                    React.createElement('div', { key: 'desc', className: 'mb-1 text-yellow-800' }, 
                        `R2: ${round2Shop.effect.length > 20 ? round2Shop.effect.substring(0, 20) + '...' : round2Shop.effect}`),
                    React.createElement('button', {
                        key: 'btn',
                        onClick: () => handlePurchase(2),
                        className: 'bg-yellow-600 hover:bg-yellow-700 text-white px-2 py-1 rounded text-xs transition-colors w-full',
                        disabled: color === 'purple'
                    }, color === 'purple' ? 'TBD' : 'Buy R2')
                ])
            ]);
        }

        // Get automatic VP text for each layer
        function getAutomaticVPText(color) {
            switch(color) {
                case 'red':
                    return '🏆 +1 VP each time you use or repeat a red layer action';
                case 'yellow':
                    return '🏆 +1 VP per different color gem at end of each round';
                case 'blue':
                    return '🏆 Get 1 VP when you activate a shop effect';
                case 'purple':
                    return '🏆 First & last to run out of workers each round get 4 VP';
                case 'white':
                    return '🏆 All players start game with 5 VP when white is in play';
                case 'gold':
                    return '🏆 +1 VP per gold gem at end of each round';
                case 'black':
                    return '🏆 +1 VP whenever you steal from another player';
                case 'silver':
                    return '🏆 End of Round: Most VP get 3 Silver, others get 2 VP';
                default:
                    return '';
            }
        }
        
        // Get VP breakdown text for tooltip
        function getVPBreakdown(vpSources) {
            if (!vpSources || Object.keys(vpSources).length === 0) return 'No VP yet';
            return Object.entries(vpSources)
                .map(([source, amount]) => `${getVPSourceName(source)}: ${amount}`)
                .join(', ');
        }
        
        // Get VP breakdown display for hover tooltip
        function getVPBreakdownDisplay(vpSources) {
            if (!vpSources || Object.keys(vpSources).length === 0) {
                return React.createElement('div', {}, 'No VP yet');
            }
            
            return React.createElement('div', {}, 
                Object.entries(vpSources).map(([source, amount]) => 
                    React.createElement('div', { key: source }, 
                        `${getVPSourceName(source)}: ${amount} VP`
                    )
                )
            );
        }
        
        // Get friendly name for VP source
        function getVPSourceName(source) {
            switch(source) {
                case 'redAction': return '🔴 Red Actions';
                case 'yellowDiversity': return '🟡 Resource Diversity';
                case 'blueShopUsage': return '🔵 Shop Usage';
                case 'purpleWorkers': return '🟣 Worker Timing';
                case 'victoryShop': return '🏆 Victory Shops';
                case 'shopPurchase': return '🏪 Shop Purchases';
                case 'whiteStarting': return '⚪ Starting VP';
                case 'whiteAction': return '⚪ White Actions';
                case 'whiteShop': return '⚪ White Shops';
                case 'goldAutomatic': return '🟨 Gold Resources';
                case 'goldVPPerGold': return '🟨 Gold Action';
                case 'blackAutomatic': return '⚫ Stealing Bonus';
                case 'blackSteal': return '⚫ Stolen VP';
                case 'blackShop': return '⚫ Black Shop';
                case 'blackVictoryShop': return '⚫ Victory Shop';
                case 'blackPenalty': return '⚫ Black Penalty';
                case 'silverAutomatic': return '🩶 Silver Automatic';
                case 'silverAction': return '🩶 Silver Actions';
                case 'silverShop': return '🩶 Silver Shops';
                default: return '❓ Other';
            }
        }
        
        // Compact Shop Component
        function CompactShop({ color, round, label, currentRound }) {
            const { state, dispatch } = useGame();
            
            const shopData = {
                red: {
                    1: { cost: { red: 1, any: 1 }, effect: 'Repeat action', fullEffect: 'Repeat a worker\'s action' },
                    2: { cost: { red: 2, any: 2 }, effect: 'Place next', fullEffect: 'Place the next player\'s worker' },
                    3: { cost: { red: 3, any: 3 }, effect: 'Repeat all', fullEffect: 'Repeat all actions taken this round by any player' }
                },
                yellow: {
                    1: { cost: { yellow: 1, any: 1 }, effect: 'Double gain', fullEffect: 'Double your next gain action' },
                    2: { cost: { yellow: 2, any: 2 }, effect: 'Gain 5⭐', fullEffect: 'Gain 5⭐' },
                    3: { cost: { yellow: 3, any: 3 }, effect: 'Gain 9⭐', fullEffect: 'Gain 9⭐' }
                },
                blue: {
                    1: { cost: { blue: 1, any: 1 }, effect: 'Toggle shop', fullEffect: 'Toggle any shop (open/closed)' },
                    2: { cost: { blue: 2, any: 2 }, effect: 'Flip all', fullEffect: 'Flip the status of all shops, including victory shops' },
                    3: { cost: { blue: 3, any: 3 }, effect: '⭐ benefit', fullEffect: 'Gain any shop benefit (even if closed)' }
                },
                purple: {
                    1: { cost: { purple: 1, any: 1 }, effect: 'Extra turn', fullEffect: 'Take an extra turn after this one' },
                    2: { cost: { purple: 2, any: 2 }, effect: 'Play 2 more', fullEffect: 'Play 2 more workers this turn' },
                    3: { cost: { purple: 3, any: 3 }, effect: 'Play all', fullEffect: 'Play the rest of your workers' },
                },
                gold: {
                    1: { cost: { gold: 1, any: 1 }, effect: '3 gems→1 VP', fullEffect: 'Convert 3 gems to 1 VP' },
                    2: { cost: { gold: 2, any: 2 }, effect: '5 gems→1 VP', fullEffect: 'Gain 1 VP for every 5 gems you have' },
                    3: { cost: { gold: 3, any: 3 }, effect: 'Double VP', fullEffect: 'Double your current VP (max +5 VP)' }
                },
                white: {
                    1: { cost: { vp: 1, any: 1 }, effect: 'Lose 1 VP, Gain 1 ⭐', fullEffect: 'Lose 1 VP, Gain 1 ⭐ gem' },
                    2: { cost: { vp: 3, any: 2 }, effect: 'Lose 3 VP, Skip Next', fullEffect: 'Lose 3 VP, Skip next player\'s turn' },
                    3: { cost: { vp: 5, any: 3 }, effect: 'Lose 5 VP, Move Worker', fullEffect: 'Lose 5 VP, Move worker to unclaimed action' }
                },
                black: {
                    1: { cost: { black: 1, any: 1 }, effect: 'Steal 1 VP', fullEffect: 'Steal 1 VP from another player' },
                    2: { cost: { black: 2, any: 2 }, effect: 'Steal 3 VP', fullEffect: 'Steal 3 VP from another player' },
                    3: { cost: { black: 3, any: 3 }, effect: 'Steal 5 VP', fullEffect: 'Steal 5 VP from another player' }
                },
                silver: {
                    1: { cost: { silver: 1, any: 1 }, effect: 'See order', fullEffect: 'Look at and rearrange turn order for next round' },
                    2: { cost: { silver: 2, any: 2 }, effect: 'See & steal', fullEffect: 'See all player hands and steal 1 gem' },
                    3: { cost: { silver: 3, any: 3 }, effect: 'Control order', fullEffect: 'Control the turn order for the rest of this round' }
                }
            };
            
            const shop = shopData[color][round];
            const shopId = `${color}${round}`;
            const isClosed = state.closedShops[shopId];
            
            // A shop is available if it's not closed
            // Since we now initialize future shops as closed, opening them makes them available
            const isAvailable = !isClosed;
            const vpCost = shop.cost.vp || 0;
            const colorCost = shop.cost[color] || 0;
            const anyCost = Math.max(0, (shop.cost.any || 0) + state.shopCostModifier);
            
            const handlePurchase = async () => {
                if (isClosed) {
                    alert('This shop is closed!');
                    return;
                }
                
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                // Check shop availability based on intuitive rules
                if (!state.workerPlacedThisTurn) {
                    // Before placing any workers - can use shop if haven't already
                    if (state.shopUsedBeforeWorkers) {
                        alert('You have already used a shop before placing workers!');
                        return;
                    }
                } else if (state.workersToPlace === 0) {
                    // After placing all workers - can use shop if haven't already
                    if (state.shopUsedAfterWorkers) {
                        alert('You have already used a shop after placing workers!');
                        return;
                    }
                } else {
                    // Still have workers to place - cannot use shop
                    alert('You must finish placing all your workers before using a shop!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                
                // Check resources
                if (vpCost > 0) {
                    if (currentPlayer.victoryPoints < vpCost) {
                        alert(`Need ${vpCost} VP. You have ${currentPlayer.victoryPoints}.`);
                        return;
                    }
                } else if (currentPlayer.resources[color] < colorCost) {
                    alert(`Need ${colorCost} ${color} gems.`);
                    return;
                }
                
                const totalGems = Object.values(currentPlayer.resources).reduce((sum, amt) => sum + amt, 0);
                const requiredForAny = vpCost > 0 ? totalGems : totalGems - colorCost;
                if (requiredForAny < anyCost) {
                    alert(`Need ${anyCost} additional gems.`);
                    return;
                }
                
                // Deduct VP cost if applicable
                if (vpCost > 0) {
                    dispatch({ 
                        type: 'UPDATE_VP', 
                        playerId: currentPlayer.id, 
                        vp: -vpCost,
                        source: 'shopCost'
                    });
                }
                
                // Simple cost deduction (full implementation in RegularShop)
                const resourceCost = {};
                if (colorCost > 0) {
                    resourceCost[color] = -colorCost;
                }
                
                // Deduct any cost
                let remaining = anyCost;
                ['red', 'yellow', 'blue', 'purple'].forEach(c => {
                    if (remaining > 0 && (vpCost > 0 || c !== color)) {
                        const available = currentPlayer.resources[c];
                        const take = Math.min(available, remaining);
                        if (take > 0) {
                            resourceCost[c] = (resourceCost[c] || 0) - take;
                            remaining -= take;
                        }
                    }
                });
                
                dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                
                // Execute shop effect
                await executeShopBenefit(color, round, currentPlayer, dispatch, state);
                
                // Track shop usage
                dispatch({ type: 'USE_SHOP' });
                
                // Blue automatic VP - player gets VP when they activate a shop effect
                dispatch({ type: 'UPDATE_VP', playerId: currentPlayer.id, vp: 1, source: 'blueShopUsage' });
                dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: +1 VP (activated a shop effect)` });
            };
            
            const getColorEmoji = () => {
                switch(color) {
                    case 'red': return '🔴';
                    case 'yellow': return '🟡';
                    case 'blue': return '🔵';
                    case 'purple': return '🟣';
                    case 'gold': return '🟨';
                    case 'white': return '⚪';
                    case 'black': return '⚫';
                    case 'silver': return '🩶';
                    default: return '⚪';
                }
            };
            
            return React.createElement('div', { 
                className: `p-2 rounded ${!isAvailable ? 'bg-gray-100 opacity-40' : 'bg-white hover:bg-gray-50'} border transition-all flex flex-col`,
            }, [
                React.createElement('div', { key: 'top-row', className: 'flex items-center justify-between mb-2' }, [
                    React.createElement('div', { key: 'cost', className: 'text-sm font-bold' }, 
                        vpCost > 0 ? `${vpCost}VP+${anyCost}⭐` : `${colorCost}${getColorEmoji()}+${anyCost}⭐`
                    ),
                    React.createElement('button', {
                        key: 'btn',
                        onClick: handlePurchase,
                        className: `text-sm py-1 px-3 rounded ${!isAvailable ? 'bg-gray-300 cursor-not-allowed text-gray-500' : 'bg-blue-500 hover:bg-blue-600 text-white'}`,
                        disabled: !isAvailable
                    }, !isAvailable ? `R${round}` : 'Buy')
                ]),
                React.createElement('div', { key: 'effect', className: 'text-sm text-gray-700 font-medium leading-tight' }, 
                    shop.fullEffect
                )
            ]);
        }
        
        // Compact Victory Shop Component
        function CompactVictoryShop({ color }) {
            const { state, dispatch } = useGame();
            
            const shopData = {
                red: { cost: 4, vp: 5 },
                yellow: { cost: 4, vp: 3 },
                blue: { cost: 4, vp: 5 },
                purple: { cost: 4, vp: 5 },
                gold: { cost: 4, vp: 7 },
                white: { cost: 4, vp: 4 },
                black: { cost: 6, vp: 0, special: 'steal1FromEach' },
                silver: { cost: 4, vp: 4 }
            };
            
            const shop = shopData[color];
            const shopId = `${color}vp`;
            const isClosed = state.closedShops[shopId];
            const actualCost = color === 'yellow' ? Math.max(0, shop.cost + state.shopCostModifier) : shop.cost;
            
            const handlePurchase = () => {
                if (isClosed) {
                    alert('This shop is closed!');
                    return;
                }
                
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                // Check shop availability based on intuitive rules
                if (!state.workerPlacedThisTurn) {
                    // Before placing any workers - can use shop if haven't already
                    if (state.shopUsedBeforeWorkers) {
                        alert('You have already used a shop before placing workers!');
                        return;
                    }
                } else if (state.workersToPlace === 0) {
                    // After placing all workers - can use shop if haven't already
                    if (state.shopUsedAfterWorkers) {
                        alert('You have already used a shop after placing workers!');
                        return;
                    }
                } else {
                    // Still have workers to place - cannot use shop
                    alert('You must finish placing all your workers before using a shop!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                
                if (color === 'yellow') {
                    const totalGems = Object.values(currentPlayer.resources).reduce((sum, amt) => sum + amt, 0);
                    if (totalGems < actualCost) {
                        alert(`Need ${actualCost} gems total.`);
                        return;
                    }
                } else {
                    if (currentPlayer.resources[color] < actualCost) {
                        alert(`Need ${actualCost} ${color} gems.`);
                        return;
                    }
                }
                
                // Deduct cost (simplified)
                const resourceCost = {};
                if (color === 'yellow') {
                    let remaining = actualCost;
                    ['red', 'yellow', 'blue', 'purple'].forEach(c => {
                        const take = Math.min(currentPlayer.resources[c], remaining);
                        if (take > 0) {
                            resourceCost[c] = -take;
                            remaining -= take;
                        }
                    });
                } else {
                    resourceCost[color] = -actualCost;
                }
                
                dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                dispatch({ type: 'UPDATE_VP', playerId: currentPlayer.id, vp: shop.vp, source: 'victoryShop' });
                
                // Track shop usage
                dispatch({ type: 'USE_SHOP' });
                
                // Blue automatic VP - player gets VP when they activate a shop effect
                dispatch({ type: 'UPDATE_VP', playerId: currentPlayer.id, vp: 1, source: 'blueShopUsage' });
                dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: +1 VP (activated a shop effect)` });
            };
            
            const getColorEmoji = () => {
                switch(color) {
                    case 'red': return '🔴';
                    case 'yellow': return '🟡';
                    case 'blue': return '🔵';
                    case 'purple': return '🟣';
                    case 'gold': return '🟨';
                    case 'white': return '⚪';
                    case 'black': return '⚫';
                    case 'silver': return '🩶';
                    default: return '⚪';
                }
            };
            
            return React.createElement('div', { 
                className: `p-1 rounded ${isClosed ? 'bg-gray-200 opacity-50' : 'bg-green-100 hover:bg-green-200'} border border-green-400 transition-all flex items-center justify-between` 
            }, [
                React.createElement('div', { key: 'info', className: 'flex items-center gap-1' }, [
                    React.createElement('span', { key: 'cost', className: 'text-xs font-bold' }, 
                        color === 'yellow' ? `${actualCost}⭐` : `${actualCost}${getColorEmoji()}`),
                    React.createElement('span', { key: 'label', className: 'text-xs text-green-700' }, '→')
                ]),
                React.createElement('button', {
                    key: 'btn',
                    onClick: handlePurchase,
                    className: `text-xs py-0.5 px-2 rounded ${isClosed ? 'bg-gray-400 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700 text-white'}`,
                    disabled: isClosed
                }, color === 'black' && shop.special === 'steal1FromEach' ? 'Steal 1 Each' : `${shop.vp} VP`)
            ]);
        }
        
        // Victory Shop Component
        function VictoryShop({ color }) {
            const { state, dispatch } = useGame();
            
            const shopData = {
                red: { cost: { red: 4 }, vp: 5 },
                yellow: { cost: { any: 4 }, vp: 3 },
                blue: { cost: { blue: 4 }, vp: 5 },
                purple: { cost: { purple: 4 }, vp: 5 },
                gold: { cost: { gold: 10 }, vp: 15 },
                white: { cost: { white: 4 }, vp: 4 },
                black: { cost: { black: 6 }, vp: 0, special: 'steal1FromEach' },
                silver: { cost: { silver: 6 }, vp: 8 }
            };
            
            const shopId = `${color}vp`;
            const isClosed = state.closedShops[shopId];
            
            const handlePurchase = () => {
                // Check if shop is closed
                if (isClosed) {
                    alert('This shop is closed!');
                    return;
                }
                
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                const shop = shopData[color];
                
                if (color === 'yellow') {
                    // Yellow VP shop costs 4 ⭐ gems (modified by shopCostModifier)
                    const baseCost = 4;
                    const actualCost = Math.max(0, baseCost + state.shopCostModifier);
                    const totalGems = Object.values(currentPlayer.resources).reduce((sum, count) => sum + count, 0);
                    
                    if (totalGems < actualCost) {
                        alert(`Need ${actualCost} resources of ⭐ color. You have ${totalGems}.`);
                        return;
                    }
                    
                    // Deduct gems proportionally
                    const resourceCost = {};
                    let remaining = actualCost;
                    const colors = ['red', 'yellow', 'blue', 'purple', 'gold', 'white', 'black', 'silver'];
                    
                    for (const color of colors) {
                        const take = Math.min(currentPlayer.resources[color], remaining);
                        if (take > 0) {
                            resourceCost[color] = -take; // Negative to subtract
                        }
                        remaining -= take;
                        if (remaining === 0) break;
                    }
                    
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                } else {
                    const requiredAmount = shop.cost[color];
                    if (currentPlayer.resources[color] < requiredAmount) {
                        alert(`Need ${requiredAmount} ${color} gems. You have ${currentPlayer.resources[color]}.`);
                        return;
                    }
                    
                    const resourceCost = {};
                    resourceCost[color] = -requiredAmount; // Negative to subtract
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                }
                
                // Handle special BLACK victory shop
                if (color === 'black' && shop.special === 'steal1FromEach') {
                    // Steal 1 VP from each other player
                    const otherPlayers = state.players.filter(p => p.id !== currentPlayer.id);
                    let totalVPStolen = 0;
                    
                    otherPlayers.forEach(otherPlayer => {
                        if (otherPlayer.victoryPoints > 0) {
                            dispatch({
                                type: 'UPDATE_VP',
                                playerId: otherPlayer.id,
                                vp: -1,
                                source: 'blackVictoryShop'
                            });
                            totalVPStolen += 1;
                        }
                    });
                    
                    if (totalVPStolen > 0) {
                        dispatch({
                            type: 'UPDATE_VP',
                            playerId: currentPlayer.id,
                            vp: totalVPStolen,
                            source: 'blackVictoryShop'
                        });
                        console.log(`Player ${currentPlayer.id}: Black Victory Shop → Stole ${totalVPStolen} VP (1 from each player)`);
                        dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Black Victory Shop → Stole ${totalVPStolen} VP (1 from each player)` });
                        
                        // BLACK AUTOMATIC VP: Gain 1 VP when stealing
                        dispatch({
                            type: 'UPDATE_VP',
                            playerId: currentPlayer.id,
                            vp: 1,
                            source: 'blackAutomatic'
                        });
                        dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: +1 VP (Black automatic: stealing bonus)` });
                    } else {
                        console.log(`Player ${currentPlayer.id}: Black Victory Shop → No VP to steal`);
                        dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Black Victory Shop → No VP to steal` });
                    }
                } else {
                    // Normal victory shop
                    dispatch({ type: 'UPDATE_VP', playerId: currentPlayer.id, vp: shop.vp, source: 'victoryShop' });
                    console.log(`Player ${currentPlayer.id} bought ${shop.vp} victory points from ${color} shop`);
                }
                
                // BLUE AUTOMATIC VP: Player gets 1 VP when they activate a shop effect
                if (state.automaticVPs.blue) {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: currentPlayer.id,
                        vp: 1,
                        source: 'blueAutomatic'
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: +1 VP (activated a shop effect)` });
                }
            };
            
            const shop = shopData[color];
            const actualCost = color === 'yellow' ? Math.max(0, 4 + state.shopCostModifier) : shop.cost[color];
            
            return React.createElement('div', { 
                className: `bg-gradient-to-br from-green-100 to-green-200 border-2 ${isClosed ? 'border-red-400 opacity-60' : 'border-green-400'} rounded-lg p-3 shadow-md hover:shadow-lg transition-all` 
            }, [
                React.createElement('div', { key: 'title', className: 'text-center font-bold text-green-700 mb-2 text-sm' }, 
                    isClosed ? 'Victory (Closed)' : '🏆 Victory'),
                React.createElement('div', { key: 'cost', className: 'text-center text-xs mb-2 text-green-800' }, 
                    React.createElement('strong', {}, 
                        color === 'black' && shop.special === 'steal1FromEach' 
                            ? `6 Black: Steal 1 VP from Each Player`
                            : `${color === 'yellow' ? `${actualCost} ⭐` : `${shop.cost[color]} ${color.charAt(0).toUpperCase() + color.slice(1)}`}: ${shop.vp} VP`)),
                React.createElement('div', { key: 'button', className: 'text-center' }, 
                    React.createElement('button', {
                        onClick: handlePurchase,
                        className: `${isClosed ? 'bg-gray-400 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'} text-white px-3 py-1 rounded text-xs font-bold shadow-md hover:shadow-lg transform hover:scale-105 transition-all`
                    }, isClosed ? 'Closed' : 'Buy'))
            ]);
        }

        // All available game layers
        const allGameLayers = {
            red: {
                title: "Worker Manipulation",
                icon: "🔴",
                actions: [
                    { id: 'gain3red', title: 'Gain 3 🔴', description: '', round: 1 },
                    { id: 'gain2red', title: 'Gain 2 🔴', description: '', round: 1 },
                    { id: 'redHybrid1', title: '+1 🔴 + Swap Workers', description: '(Both players get actions)', round: 1 },
                    { id: 'redRepeatAction', title: 'Repeat an Action', description: '(That one of your workers is on)', round: 1 },
                    { id: 'forceRedPlacement', title: 'Other Players Must Place on Red', description: '(Until red layer is full)', round: 2 },
                    { id: 'redHybrid2', title: '+1 🔴 + Swap Workers', description: '(Only you get action)', round: 2 },
                    { id: 'redRepeatAll', title: 'Repeat All Your Worker Actions', description: '(In any order you choose)', round: 3 }
                ]
            },
            yellow: {
                title: "Resource Manipulation", 
                icon: "🟡",
                actions: [
                    { id: 'gain3yellow', title: 'Gain 3 ⭐', description: '', round: 1 },
                    { id: 'gain2yellow', title: 'Gain 2 ⭐', description: '', round: 1 },
                    { id: 'steal2Gems', title: 'Steal 2 Resources', description: '', round: 1 },
                    { id: 'yellowHybrid1', title: '+1 🟡 + Trade ⭐', description: '', round: 1 },
                    { id: 'steal3Gems', title: 'Steal 3 Resources', description: '', round: 2 },
                    { id: 'yellowHybrid2', title: '+1 🟡 + Double Next Gain', description: '(Doesn\'t stack with shop)', round: 2 },
                    { id: 'yellowSwapResources', title: 'Swap All Resources', description: '(Choose ⭐ player)', round: 3 }
                ]
            },
            blue: {
                title: "Shop Control",
                icon: "🔵", 
                actions: [
                    { id: 'gain3blue', title: 'Gain 3 🔵', description: '', round: 1 },
                    { id: 'gain2blue', title: 'Gain 2 🔵', description: '', round: 1 },
                    { id: 'blueR1ShopBenefit', title: 'Gain an R1 Shop Benefit', description: '(Even if closed)', round: 1 },
                    { id: 'blueReduceCosts', title: '+1 🔵 + Reduce All Shop Costs', description: '(By 1 ⭐ this round)', round: 1 },
                    { id: 'blueIncreaseCosts', title: '+2 🔵 + Increase All Shop Costs', description: '(By 1 ⭐ this round)', round: 2 },
                    { id: 'blueToggleShops', title: '+1 🔵 + Toggle All Shop Status', description: '(Including victory shops)', round: 2 },
                    { id: 'blueAnyShopBenefit', title: 'Gain ⭐ Shop Benefit', description: '(Even if closed)', round: 3 }
                ]
            },
            purple: {
                title: "Timing/Order",
                icon: "🟣",
                actions: [
                    { id: 'gain4purpleSkip', title: 'Gain 4 🟣, Skip Next Turn', description: '', round: 1 },
                    { id: 'gain3purple', title: 'Gain 3 🟣', description: '', round: 1 },
                    { id: 'gain2purpleTakeBack', title: 'Gain 2 🟣, Take Back Worker', description: '(From different quad)', round: 1 },
                    { id: 'playTwoWorkers', title: 'Play 2 More Workers', description: '(This turn)', round: 1 },
                    { id: 'gain5purpleSkip', title: 'Gain 5 🟣, Skip Turn', description: '', round: 2 },
                    { id: 'playThreeWorkers', title: 'Play 3 More Workers', description: '(This turn)', round: 2 },
                    { id: 'gain4purpleWaitAll', title: 'Gain 4 🟣, Wait Then Play All', description: '(Skip until others out, then play all)', round: 3 }
                ]
            },
            gold: {
                title: "Victory Points",
                icon: "🟨",
                actions: [
                    { id: 'gain2gold', title: 'Gain 2 Gold', description: '', round: 1 },
                    { id: 'convert2AnyTo2Gold', title: 'Turn 2 Any to 2 Gold', description: '', round: 1 },
                    { id: 'gain1gold', title: 'Gain 1 Gold', description: '', round: 1 },
                    { id: 'convert1AnyTo1Gold', title: 'Turn 1 Any to 1 Gold', description: '', round: 1 },
                    { id: 'gain3goldSkip', title: 'Gain 3 Gold, Skip Next Turn', description: '', round: 2 },
                    { id: 'convert3AnyTo3Gold', title: 'Turn 3 Any to 3 Gold', description: '', round: 2 },
                    { id: 'goldVPPerGold', title: 'Gain VP for Each Gold You Have', description: '', round: 3 }
                ]
            },
            white: {
                title: "White - VP Trading",
                icon: "⚪",
                actions: [
                    { id: 'gain3vp', title: 'Gain 3 VP', description: '', round: 1 },
                    { id: 'gain2vp', title: 'Gain 2 VP', description: '', round: 1 },
                    { id: 'spend1AnyFor2VP', title: 'Spend 1 ⭐ for 2 VP', description: '', round: 1 },
                    { id: 'spend2AnyFor3VP', title: 'Spend 2 ⭐ for 3 VP', description: '', round: 1 },
                    { id: 'lose1VPGain2Any', title: 'Lose 1 VP, Gain 2 ⭐', description: '', round: 2 },
                    { id: 'lose2VPGain4Any', title: 'Lose 2 VP, Gain 4 ⭐', description: '', round: 2 },
                    { id: 'gain5VPAnd5Any', title: 'Gain 5 VP and 5 ⭐', description: '', round: 3 }
                ]
            },
            black: {
                title: "Destruction/Penalty",
                icon: "⚫",
                actions: [
                    { id: 'gain3black', title: 'Gain 3 ⚫', description: '', round: 1 },
                    { id: 'gain2black', title: 'Gain 2 ⚫', description: '', round: 1 },
                    { id: 'blackSteal1VP', title: '+1 ⚫, Steal 1 VP', description: '(From another player)', round: 1 },
                    { id: 'blackSteal2Any', title: 'Steal 2 ⭐', description: '(From another player)', round: 1 },
                    { id: 'blackStealWorker', title: '+1 ⚫, Steal Worker', description: '(Gain one of their remaining workers)', round: 2 },
                    { id: 'blackAllLose2VP', title: 'All Others Lose 2 VP', description: '', round: 2 },
                    { id: 'blackAllLose4VP', title: '+1 ⚫, All Others Lose 4 VP', description: '', round: 3 }
                ]
            },
            silver: {
                title: "Information/Planning",
                icon: "🩶",
                actions: [
                    { id: 'silver4Others1', title: '+4 Silver, Others +1', description: '(Other players get +1 Silver)', round: 1 },
                    { id: 'silver3Others1', title: '+3 Silver, Others +1', description: '(Other players get +1 Silver)', round: 1 },
                    { id: 'silver2Plus1Others', title: '+2 Silver + 1 ⭐', description: '(Others get 1 of same color)', round: 1 },
                    { id: 'silver2VPBoth', title: '+2 VP, Pick Another +2 VP', description: '(Choose another player)', round: 1 },
                    { id: 'silverTakeBack2', title: '+2 Silver, Take Back 2', description: '(Others take back 1 worker)', round: 2 },
                    { id: 'silver3Plus2Others1', title: '+3 Silver + 2 ⭐', description: '(Others get 1 of that color)', round: 2 },
                    { id: 'silver8VPOthers3S', title: '+8 VP, Others +3 Silver', description: '(Each other player gets +3 Silver)', round: 3 }
                ]
            }
        };
        
        // Function to select random layers based on player count and game mode
        function selectGameLayers(playerCount, gameMode = 'advanced') {
            let availableLayers;
            
            if (gameMode === 'basic') {
                // Basic mode always uses the original 4 colors
                availableLayers = ['red', 'yellow', 'blue', 'purple'];
            } else {
                // Advanced mode uses all 8 colors
                availableLayers = Object.keys(allGameLayers);
            }
            
            const shuffled = [...availableLayers].sort(() => Math.random() - 0.5);
            const selectedLayerKeys = shuffled.slice(0, playerCount);
            
            const gameData = {};
            selectedLayerKeys.forEach(key => {
                gameData[key] = allGameLayers[key];
            });
            
            return gameData;
        }

        // Main Game Board Component
        function GameBoard() {
            const { state, dispatch } = useGame();
            
            // Sync state to Firebase whenever state changes
            useEffect(() => {
                if (state.roomCode && state.gameStarted) {
                    syncGameState(state.roomCode, {
                        currentPlayer: state.currentPlayer,
                        turnDirection: state.turnDirection,
                        players: state.players,
                        occupiedSpaces: state.occupiedSpaces,
                        round: state.round,
                        turnOrder: state.turnOrder,
                        workerPlacedThisTurn: state.workerPlacedThisTurn,
                        workersToPlace: state.workersToPlace,
                        actionLog: state.actionLog,
                        gameStarted: state.gameStarted,
                        gameLayers: state.gameLayers
                    });
                }
            }, [state.currentPlayer, state.players, state.occupiedSpaces, state.round, state.actionLog, state.workersToPlace, state.gameLayers]);
            
            const handleEndTurn = async () => {
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                
                if (state.workersToPlace > 0 && currentPlayer.workersLeft > 0) {
                    const workersRemaining = state.workersToPlace;
                    const confirmSkip = await showConfirm(dispatch, 
                        'End Turn Early?',
                        `You can still place ${workersRemaining} more worker${workersRemaining > 1 ? 's' : ''} this turn. Are you sure you want to end your turn?`
                    );
                    if (!confirmSkip) return;
                }
                
                dispatch({ type: 'END_TURN' });
            };
            
            const handleAdvanceRound = () => {
                if (state.round < 3) {
                    dispatch({ type: 'ADVANCE_ROUND' });
                } else {
                    alert('Game is already at Round 3 (final round)');
                }
            };
            
            const handleResetGame = () => {
                dispatch({ type: 'RESET_GAME', preserveEmojis: true });
            };
            
            // If no layers selected yet, show loading or use default layers for local play
            if (!state.gameLayers) {
                console.log('No game layers found. State:', {
                    roomCode: state.roomCode,
                    gameStarted: state.gameStarted,
                    gameLayers: state.gameLayers
                });
                if (!state.roomCode) {
                    // Local play - use 4 layers
                    console.log('Local play - selecting 4 layers');
                    const selectedLayers = selectGameLayers(4);
                    dispatch({ type: 'SET_GAME_LAYERS', layers: selectedLayers });
                }
                return React.createElement('div', { 
                    className: 'min-h-screen flex items-center justify-center' 
                }, React.createElement('div', {
                    className: 'text-center glass rounded-xl p-8'
                }, [
                    React.createElement('h2', { key: 'title', className: 'text-2xl font-bold mb-4' }, 'Setting up game layers...'),
                    React.createElement('div', { key: 'spinner', className: 'animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto' }),
                    React.createElement('div', { key: 'debug', className: 'text-sm text-gray-600 mt-4' }, 
                        `Debug: roomCode=${state.roomCode}, gameStarted=${state.gameStarted}`)
                ]));
            }
            
            console.log('GameBoard rendering with layers:', Object.keys(state.gameLayers));

            const totalWorkers = state.players.reduce((sum, p) => sum + p.workersLeft, 0);
            const totalSpaces = Object.values(state.gameLayers).reduce((sum, layer) => 
                sum + layer.actions.filter(action => action.round <= state.round).length, 0
            );
            
            return React.createElement('div', { className: 'min-h-screen p-4' }, [
                React.createElement('div', { key: 'container', className: 'max-w-7xl mx-auto game-board' }, [
                    
                    // Game Header with Round Indicator and Room Code
                    React.createElement('div', { 
                        key: 'game-header', 
                        className: 'flex items-center justify-between mb-6'
                    }, [
                        // Room code badge (if in multiplayer)
                        state.roomCode && React.createElement('div', {
                            key: 'room-badge',
                            className: 'bg-gray-700 text-white px-4 py-2 rounded-lg shadow-md flex items-center gap-2'
                        }, [
                            React.createElement('span', { key: 'icon', className: 'text-sm' }, '🏠'),
                            React.createElement('span', { key: 'text', className: 'font-semibold' }, `Room: ${state.roomCode}`)
                        ]),
                        
                        // Round indicator (centered)
                        React.createElement('div', { 
                            key: 'round-indicator', 
                            className: 'bg-gradient-to-r from-blue-500 to-blue-600 text-white px-6 py-3 rounded-lg shadow-lg flex items-center justify-center gap-2 mx-auto'
                        }, [
                            React.createElement('span', { key: 'icon', className: 'text-2xl' }, '🎲'),
                            React.createElement('span', { key: 'text', className: 'text-xl font-bold' }, `Round ${state.round}`)
                        ]),
                        
                        // Spacer for layout balance
                        state.roomCode && React.createElement('div', {
                            key: 'spacer',
                            className: 'w-32' // Same width as room badge for balance
                        })
                    ]),
                    
                    // Player Cards
                    React.createElement('div', { key: 'players', className: 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8' }, 
                        state.players.map(player => 
                            React.createElement(PlayerCard, {
                                key: player.id,
                                player,
                                isCurrentPlayer: player.id === state.currentPlayer,
                                onEndTurn: handleEndTurn
                            })
                        )
                    ),
                    
                    // Game Layers - 2x2 Grid Layout
                    React.createElement('div', { key: 'layers', className: 'grid grid-cols-2 gap-6 mb-6' }, 
                        Object.entries(state.gameLayers).map(([color, layer]) => 
                            React.createElement(GameLayer, {
                                key: color,
                                color: color,
                                title: layer.title,
                                icon: layer.icon,
                                actions: layer.actions,
                                round: state.round
                            })
                        )
                    ),
                    
                    // Control Buttons
                    React.createElement('div', { key: 'controls', className: 'text-center glass rounded-lg p-4 shadow-lg' }, [
                        React.createElement('button', {
                            key: 'advance',
                            onClick: handleAdvanceRound,
                            className: 'bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold py-2 px-4 rounded-lg mr-3 shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                        }, `Advance to Round ${Math.min(state.round + 1, 3)}`),
                        React.createElement('button', {
                            key: 'reset',
                            onClick: handleResetGame,
                            className: 'bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                        }, 'Reset Game'),
                        React.createElement('div', { key: 'instructions', className: 'text-gray-600 mt-3 text-sm' }, 
                            'Place worker → Buy from shops → End turn (button under current player)'),
                        state.actionLog.length > 0 && React.createElement('div', { key: 'action-log', className: 'mt-4 p-3 bg-gray-100 rounded-lg max-h-32 overflow-y-auto' }, [
                            React.createElement('div', { key: 'log-title', className: 'font-bold text-gray-700 mb-2 text-sm' }, 'Action Log (Last 10):'),
                            ...state.actionLog.map((log, index) => 
                                React.createElement('div', { 
                                    key: index, 
                                    className: 'text-xs text-gray-600 mb-1 font-mono' 
                                }, log)
                            )
                        ])
                    ])
                ]),
                // Modal System
                state.modal && React.createElement(Modal, { 
                    key: 'modal', 
                    isOpen: true, 
                    onClose: () => dispatch({ type: 'HIDE_MODAL' }) 
                }, state.modal.type === 'choice' 
                    ? React.createElement(ChoiceModal, state.modal)
                    : state.modal.type === 'gemSelection'
                    ? React.createElement(GemSelectionModal, state.modal)
                    : state.modal.type === 'stealGems'
                    ? React.createElement(StealGemsModal, state.modal)
                    : React.createElement(ConfirmModal, state.modal)
                )
            ]);
        }

        // Main App Component
        function App() {
            return React.createElement(GameProvider, {}, 
                React.createElement(MainApp, {})
            );
        }
        
        function MainApp() {
            const { state } = useGame();
            
            // Add error boundary
            try {
                // Show room lobby if not in a game
                if (!state.gameStarted) {
                    // If connected to a room but game hasn't started, show waiting room
                    if (state.roomCode) {
                        return React.createElement('div', { className: 'min-h-screen p-4' }, [
                            React.createElement(ConnectedPlayers, { key: 'players' }),
                            React.createElement('div', { 
                                key: 'waiting',
                                className: 'text-center mt-8' 
                            }, [
                                React.createElement('div', {
                                    key: 'spinner',
                                    className: 'animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4'
                                }),
                                React.createElement('h2', {
                                    key: 'text',
                                    className: 'text-xl text-gray-600'
                                }, state.isHost ? 'Waiting for you to start the game...' : 'Waiting for host to start the game...')
                            ])
                        ]);
                    }
                    
                    // Show room lobby for initial connection
                    return React.createElement(RoomLobby, {});
                }
                
                // Show game board with multiplayer info if in a room
                return React.createElement('div', { className: 'min-h-screen' }, [
                    state.roomCode && React.createElement(ConnectedPlayers, { key: 'players' }),
                    React.createElement(GameBoard, { key: 'game' })
                ]);
            } catch (error) {
                console.error('Render error:', error);
                console.error('Error stack:', error.stack);
                console.error('Game state at error:', state);
                return React.createElement('div', { 
                    className: 'min-h-screen flex items-center justify-center p-4' 
                }, React.createElement('div', {
                    className: 'glass rounded-xl p-8 text-center'
                }, [
                    React.createElement('h1', { 
                        key: 'title',
                        className: 'text-2xl font-bold text-red-600 mb-4' 
                    }, 'Game Error'),
                    React.createElement('p', { 
                        key: 'message',
                        className: 'text-gray-600 mb-4' 
                    }, 'Something went wrong. Check browser console for details.'),
                    React.createElement('div', {
                        key: 'error-details',
                        className: 'text-sm text-gray-500 mb-4 p-2 bg-gray-100 rounded'
                    }, `Error: ${error.message}`),
                    React.createElement('button', {
                        key: 'reload',
                        onClick: () => window.location.reload(),
                        className: 'bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded'
                    }, 'Reload Game')
                ]));
            }
        }

        // Render the app
        ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
</body>
</html>
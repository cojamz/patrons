<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patrons - React Version</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            scroll-behavior: smooth;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
        }
        
        html {
            scroll-behavior: smooth;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
        }
        
        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }
        
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(156, 163, 175, 0.5);
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(156, 163, 175, 0.8);
        }
        
        /* Improve rendering performance */
        .game-board {
            -webkit-transform: translateZ(0);
            -moz-transform: translateZ(0);
            -ms-transform: translateZ(0);
            -o-transform: translateZ(0);
            transform: translateZ(0);
            will-change: transform;
        }
        
        /* Smoother transitions for all interactive elements */
        button, .action-space, .player-card {
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        /* Better momentum scrolling for iOS */
        @supports (-webkit-overflow-scrolling: touch) {
            body {
                -webkit-overflow-scrolling: touch;
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
            }
        }
        
        /* Reduce animation conflicts during scrolling */
        @media (prefers-reduced-motion: no-preference) {
            .action-space:hover {
                transition: all 0.15s ease-out;
            }
            
            button:hover {
                transition: all 0.15s ease-out;
            }
        }
        
        /* For users who prefer reduced motion */
        @media (prefers-reduced-motion: reduce) {
            html {
                scroll-behavior: auto;
            }
            
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        .player-1 { background: #8e44ad !important; }
        .player-2 { background: #27ae60 !important; }
        .player-3 { background: #e67e22 !important; }
        .player-4 { background: #2c3e50 !important; }
        
        @keyframes pulse-blue {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
        }
        
        .pulse-current {
            animation: pulse-blue 2s infinite;
        }
        
        .glass {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-100 via-purple-100 to-pink-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useContext, createContext, useReducer, useEffect } = React;
        
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB0c0iUOG3llUzLd9FhQ6Qc1qCB0DoajVw",
            authDomain: "cornycolonies.firebaseapp.com",
            databaseURL: "https://cornycolonies-default-rtdb.firebaseio.com",
            projectId: "cornycolonies",
            storageBucket: "cornycolonies.firebasestorage.app",
            messagingSenderId: "566795956627",
            appId: "1:566795956627:web:585b66a3277696f3b0b866"
        };
        
        // Initialize Firebase (will use demo mode for now)
        let database = null;
        try {
            if (typeof firebase !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                database = firebase.database();
            }
        } catch (error) {
            console.log('Firebase not available, using local mode');
        }

        // Game Context
        const GameContext = createContext();

        const initialState = {
            // Game state
            currentPlayer: 1,
            turnDirection: 1,
            players: [
                { id: 1, name: "Player 1", resources: { red: 0, yellow: 0, blue: 0, purple: 0 }, workersLeft: 4, effects: [], victoryPoints: 0 },
                { id: 2, name: "Player 2", resources: { red: 0, yellow: 0, blue: 0, purple: 0 }, workersLeft: 4, effects: [], victoryPoints: 0 },
                { id: 3, name: "Player 3", resources: { red: 0, yellow: 0, blue: 0, purple: 0 }, workersLeft: 4, effects: [], victoryPoints: 0 },
                { id: 4, name: "Player 4", resources: { red: 0, yellow: 0, blue: 0, purple: 0 }, workersLeft: 4, effects: [], victoryPoints: 0 }
            ],
            occupiedSpaces: {},
            round: 1,
            turnOrder: [1, 2, 3, 4],
            workerPlacedThisTurn: false,
            workersToPlace: 1,
            modal: null,
            actionLog: [],
            gameLayers: null, // Will be set when game starts
            closedShops: {}, // Track which shops are closed { 'red1': true, 'blue2': true, etc }
            shopCostModifier: 0, // Cost modifier for shops this round
            skippedTurns: {}, // Track players who should skip turns { playerId: turnsToSkip }
            playersOutOfWorkers: [], // Track order players ran out of workers for purple VP
            waitingForOthers: {}, // Track players waiting for others to run out (purple R3)
            roundActions: [], // Track all actions taken this round for Red R3 shop
            
            // Multiplayer state
            roomCode: null,
            myPlayerId: null,
            myPlayerName: '',
            connectedPlayers: {},
            isHost: false,
            gameStarted: false,
            connectionStatus: 'disconnected' // 'disconnected', 'connecting', 'connected'
        };

        function gameReducer(state, action) {
            switch (action.type) {
                case 'PLACE_WORKER':
                    const newWorkersToPlace = Math.max(0, state.workersToPlace - 1);
                    return {
                        ...state,
                        occupiedSpaces: {
                            ...state.occupiedSpaces,
                            [action.actionId]: state.currentPlayer
                        },
                        players: state.players.map(player => 
                            player.id === state.currentPlayer 
                                ? { ...player, workersLeft: player.workersLeft - 1 }
                                : player
                        ),
                        workerPlacedThisTurn: true,
                        workersToPlace: newWorkersToPlace,
                        roundActions: [...state.roundActions, { playerId: state.currentPlayer, actionId: action.actionId }]
                    };
                
                case 'UPDATE_RESOURCES':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { 
                                    ...player, 
                                    resources: {
                                        red: player.resources.red + (action.resources.red || 0),
                                        yellow: player.resources.yellow + (action.resources.yellow || 0),
                                        blue: player.resources.blue + (action.resources.blue || 0),
                                        purple: player.resources.purple + (action.resources.purple || 0)
                                    }
                                }
                                : player
                        )
                    };
                    
                case 'SET_RESOURCES':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, resources: action.resources }
                                : player
                        )
                    };
                
                case 'ADD_VICTORY_POINTS':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, victoryPoints: player.victoryPoints + action.points }
                                : player
                        )
                    };
                    
                case 'UPDATE_VP':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, victoryPoints: player.victoryPoints + action.vp }
                                : player
                        )
                    };
                
                case 'ADD_EFFECT':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, effects: [...(player.effects || []), action.effect] }
                                : player
                        )
                    };
                
                case 'UPDATE_PLAYER_EFFECTS':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, effects: action.effects }
                                : player
                        )
                    };
                
                case 'SET_WORKERS_TO_PLACE':
                    return {
                        ...state,
                        workersToPlace: action.count,
                        workerPlacedThisTurn: false
                    };
                
                case 'END_TURN':
                    const currentPlayerObj = state.players.find(p => p.id === state.currentPlayer);
                    
                    // Track if player just ran out of workers
                    let newPlayersOutOfWorkers = [...state.playersOutOfWorkers];
                    if (currentPlayerObj.workersLeft === 0 && !newPlayersOutOfWorkers.includes(state.currentPlayer)) {
                        newPlayersOutOfWorkers.push(state.currentPlayer);
                    }
                    
                    // Purple VP: Check if this is first or last player to run out
                    const purpleVPUpdates = [];
                    const playersWithWorkers = state.players.filter(p => p.workersLeft > 0);
                    
                    // First player to run out gets 3 VP
                    if (newPlayersOutOfWorkers.length === 1 && newPlayersOutOfWorkers[0] === state.currentPlayer) {
                        purpleVPUpdates.push({ playerId: state.currentPlayer, vp: 3, reason: 'first to run out of workers' });
                    }
                    // Last player to run out gets 3 VP (when only 1 player left with workers)
                    if (playersWithWorkers.length === 1 && currentPlayerObj.workersLeft === 0) {
                        const lastPlayer = playersWithWorkers[0];
                        if (!newPlayersOutOfWorkers.includes(lastPlayer.id)) {
                            newPlayersOutOfWorkers.push(lastPlayer.id);
                            purpleVPUpdates.push({ playerId: lastPlayer.id, vp: 3, reason: 'last to run out of workers' });
                        }
                    }
                    
                    // Check for extra turn effect
                    const hasExtraTurn = currentPlayerObj.effects.some(effect => 
                        effect.includes('Will take an extra turn after this one')
                    );
                    
                    if (hasExtraTurn) {
                        // Remove the extra turn effect and stay on the same player
                        return {
                            ...state,
                            players: state.players.map(player => {
                                const vpUpdate = purpleVPUpdates.find(u => u.playerId === player.id);
                                return player.id === state.currentPlayer 
                                    ? { 
                                        ...player, 
                                        effects: (player.effects || []).filter(effect => 
                                            !effect.includes('Will take an extra turn after this one')
                                        ),
                                        victoryPoints: player.victoryPoints + (vpUpdate ? vpUpdate.vp : 0)
                                    }
                                    : {
                                        ...player,
                                        victoryPoints: player.victoryPoints + (vpUpdate ? vpUpdate.vp : 0)
                                    };
                            }),
                            workerPlacedThisTurn: false,
                            workersToPlace: 1,
                            playersOutOfWorkers: newPlayersOutOfWorkers,
                            actionLog: [
                                ...state.actionLog.slice(-9), 
                                `Player ${state.currentPlayer}: Taking extra turn!`,
                                ...purpleVPUpdates.map(u => `Player ${u.playerId}: +${u.vp} VP (${u.reason})`)
                            ].filter(Boolean)
                        };
                    }
                    
                    // Check if any waiting players should now play all workers
                    let waitingPlayersUpdates = [];
                    let newWaitingForOthers = { ...state.waitingForOthers };
                    
                    // If all non-waiting players are out of workers, activate waiting players
                    const nonWaitingPlayersWithWorkers = state.players.filter(p => 
                        !state.waitingForOthers[p.id] && p.workersLeft > 0
                    );
                    
                    if (nonWaitingPlayersWithWorkers.length === 0) {
                        // All non-waiting players are out, activate waiting players
                        Object.keys(state.waitingForOthers).forEach(playerId => {
                            if (state.waitingForOthers[playerId]) {
                                const waitingPlayer = state.players.find(p => p.id === parseInt(playerId));
                                if (waitingPlayer && waitingPlayer.workersLeft > 0) {
                                    waitingPlayersUpdates.push({
                                        playerId: parseInt(playerId),
                                        workers: waitingPlayer.workersLeft
                                    });
                                    delete newWaitingForOthers[playerId];
                                }
                            }
                        });
                    }
                    
                    // Find next player considering skips and waiting players
                    let nextPlayer;
                    let nextDirection = state.turnDirection;
                    let attempts = 0;
                    const maxAttempts = state.players.length * 2;
                    
                    do {
                        const currentIndex = state.turnOrder.indexOf(attempts === 0 ? state.currentPlayer : nextPlayer);
                        
                        if (state.turnDirection === 1) {
                            if (currentIndex === state.turnOrder.length - 1) {
                                nextDirection = -1;
                                nextPlayer = state.turnOrder[currentIndex];
                            } else {
                                nextPlayer = state.turnOrder[currentIndex + 1];
                            }
                        } else {
                            if (currentIndex === 0) {
                                nextDirection = 1;
                                nextPlayer = state.turnOrder[currentIndex];
                            } else {
                                nextPlayer = state.turnOrder[currentIndex - 1];
                            }
                        }
                        
                        attempts++;
                        if (attempts > maxAttempts) break; // Prevent infinite loop
                        
                        // Check if player should skip
                        const shouldSkip = state.skippedTurns[nextPlayer] > 0;
                        // Check if player is waiting for others
                        const isWaiting = newWaitingForOthers[nextPlayer];
                        // Check if player has workers
                        const hasWorkers = state.players.find(p => p.id === nextPlayer).workersLeft > 0;
                        
                    } while ((state.skippedTurns[nextPlayer] > 0 || newWaitingForOthers[nextPlayer] || 
                             !state.players.find(p => p.id === nextPlayer).workersLeft > 0) && 
                             attempts < maxAttempts);
                    
                    // Update skip counts
                    const newSkippedTurns = { ...state.skippedTurns };
                    if (newSkippedTurns[nextPlayer] > 0) {
                        newSkippedTurns[nextPlayer]--;
                    }
                    
                    // Set workers to place for waiting players who are now active
                    const waitingPlayerUpdate = waitingPlayersUpdates.find(u => u.playerId === nextPlayer);
                    const workersToPlace = waitingPlayerUpdate ? waitingPlayerUpdate.workers : 1;
                    
                    return {
                        ...state,
                        currentPlayer: nextPlayer,
                        turnDirection: nextDirection,
                        workerPlacedThisTurn: false,
                        workersToPlace: workersToPlace,
                        skippedTurns: newSkippedTurns,
                        waitingForOthers: newWaitingForOthers,
                        playersOutOfWorkers: newPlayersOutOfWorkers,
                        players: state.players.map(player => {
                            const vpUpdate = purpleVPUpdates.find(u => u.playerId === player.id);
                            return vpUpdate ? {
                                ...player,
                                victoryPoints: player.victoryPoints + vpUpdate.vp
                            } : player;
                        }),
                        actionLog: [
                            ...state.actionLog.slice(-9),
                            ...purpleVPUpdates.map(u => `Player ${u.playerId}: +${u.vp} VP (${u.reason})`),
                            ...waitingPlayersUpdates.map(u => `Player ${u.playerId}: Can now play all ${u.workers} workers!`)
                        ].filter(Boolean)
                    };
                
                case 'ADVANCE_ROUND':
                    // Calculate Yellow automatic VP before advancing round
                    const vpMessages = [];
                    const playersWithYellowVP = state.players.map(player => {
                        const differentColors = Object.entries(player.resources)
                            .filter(([color, amount]) => amount > 0)
                            .length;
                        
                        if (differentColors > 0) {
                            vpMessages.push(`Player ${player.id}: +${differentColors} VP for ${differentColors} different color gems`);
                            return {
                                ...player,
                                victoryPoints: player.victoryPoints + differentColors
                            };
                        }
                        return player;
                    });
                    
                    return {
                        ...state,
                        round: state.round + 1,
                        players: playersWithYellowVP.map(player => {
                            const baseWorkers = 3 + (state.round + 1);
                            const hasExtraWorkers = (player.effects || []).some(effect => 
                                effect.includes('Will get 2 extra workers next round')
                            );
                            const extraWorkers = hasExtraWorkers ? 2 : 0;
                            
                            return {
                                ...player,
                                workersLeft: baseWorkers + extraWorkers,
                                effects: (player.effects || []).filter(effect => 
                                    !effect.includes('Will get 2 extra workers next round')
                                )
                            };
                        }),
                        occupiedSpaces: {},
                        currentPlayer: 1,
                        turnDirection: 1,
                        workerPlacedThisTurn: false,
                        workersToPlace: 1,
                        shopCostModifier: 0, // Reset cost modifier each round
                        playersOutOfWorkers: [], // Reset for new round
                        skippedTurns: {}, // Reset skip turns
                        waitingForOthers: {}, // Reset waiting status
                        roundActions: [], // Reset actions for new round
                        actionLog: [...state.actionLog.slice(-9), ...vpMessages, `Round ${state.round + 1} started! Extra workers applied.`]
                    };
                
                case 'ADD_LOG':
                    return {
                        ...state,
                        actionLog: [...state.actionLog.slice(-9), action.message] // Keep last 10 messages
                    };
                
                case 'RESET_GAME':
                    return initialState;
                
                case 'SHOW_MODAL':
                    return {
                        ...state,
                        modal: action.modal
                    };
                
                case 'HIDE_MODAL':
                    return {
                        ...state,
                        modal: null
                    };
                
                case 'UPDATE_OCCUPIED_SPACES':
                    return {
                        ...state,
                        occupiedSpaces: action.occupiedSpaces
                    };
                
                case 'SET_TURN_ORDER':
                    return {
                        ...state,
                        turnOrder: action.turnOrder
                    };
                
                case 'CLOSE_SHOP':
                    return {
                        ...state,
                        closedShops: {
                            ...state.closedShops,
                            [action.shopId]: true
                        }
                    };
                
                case 'FLIP_ALL_SHOPS':
                    const flippedShops = {};
                    // Flip all regular shops
                    const colors = ['red', 'yellow', 'blue', 'purple'];
                    const rounds = [1, 2, 3];
                    colors.forEach(color => {
                        rounds.forEach(round => {
                            const shopId = `${color}${round}`;
                            flippedShops[shopId] = !state.closedShops[shopId];
                        });
                        // Also flip victory shops
                        const vpShopId = `${color}VP`;
                        flippedShops[vpShopId] = !state.closedShops[vpShopId];
                    });
                    return {
                        ...state,
                        closedShops: flippedShops
                    };
                
                case 'SET_SHOP_COST_MODIFIER':
                    return {
                        ...state,
                        shopCostModifier: action.modifier
                    };
                
                // Multiplayer actions
                case 'SET_ROOM_INFO':
                    return {
                        ...state,
                        roomCode: action.roomCode,
                        isHost: action.isHost
                    };
                
                case 'SET_MY_PLAYER_INFO':
                    return {
                        ...state,
                        myPlayerId: action.playerId,
                        myPlayerName: action.playerName
                    };
                
                case 'UPDATE_CONNECTED_PLAYERS':
                    return {
                        ...state,
                        connectedPlayers: action.connectedPlayers
                    };
                
                case 'START_GAME':
                    return {
                        ...state,
                        gameStarted: true
                    };
                
                case 'SET_GAME_LAYERS':
                    return {
                        ...state,
                        gameLayers: action.layers
                    };
                
                case 'UPDATE_CONNECTION_STATUS':
                    return {
                        ...state,
                        connectionStatus: action.status
                    };
                
                case 'SET_SKIPPED_TURNS':
                    return {
                        ...state,
                        skippedTurns: action.skippedTurns
                    };
                
                case 'SET_WAITING_FOR_OTHERS':
                    return {
                        ...state,
                        waitingForOthers: action.waitingForOthers
                    };
                
                case 'REMOVE_WORKER':
                    const newOccupiedSpaces = { ...state.occupiedSpaces };
                    delete newOccupiedSpaces[action.actionId];
                    return {
                        ...state,
                        occupiedSpaces: newOccupiedSpaces,
                        players: state.players.map(player => 
                            player.id === action.playerId
                                ? { ...player, workersLeft: player.workersLeft + 1 }
                                : player
                        )
                    };
                
                case 'SYNC_GAME_STATE':
                    // Merge remote game state while preserving local multiplayer state
                    return {
                        ...state,
                        ...action.gameState,
                        // Ensure all players have effects array
                        players: action.gameState.players ? action.gameState.players.map(player => ({
                            ...player,
                            effects: player.effects || [],
                            resources: {
                                red: 0, yellow: 0, blue: 0, purple: 0,
                                ...(player.resources || {})
                            }
                        })) : state.players,
                        roomCode: state.roomCode,
                        myPlayerId: state.myPlayerId,
                        myPlayerName: state.myPlayerName,
                        connectedPlayers: state.connectedPlayers,
                        isHost: state.isHost,
                        gameStarted: action.gameState.gameStarted !== undefined ? action.gameState.gameStarted : state.gameStarted,
                        connectionStatus: state.connectionStatus,
                        // Sync game layers if provided
                        gameLayers: action.gameState.gameLayers || state.gameLayers
                    };
                
                default:
                    return state;
            }
        }

        function GameProvider({ children }) {
            const [state, dispatch] = useReducer(gameReducer, initialState);
            
            return React.createElement(GameContext.Provider, { value: { state, dispatch } }, children);
        }

        function useGame() {
            const context = useContext(GameContext);
            if (!context) {
                throw new Error('useGame must be used within a GameProvider');
            }
            return context;
        }
        
        // Multiplayer Functions
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }
        
        function createRoom(dispatch, playerName) {
            const roomCode = generateRoomCode();
            const playerId = 1; // Host is always player 1
            
            if (database) {
                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connecting' });
                
                const roomRef = database.ref(`rooms/${roomCode}`);
                
                // Add timeout to prevent infinite loading
                const timeout = setTimeout(() => {
                    console.error('Room creation timeout');
                    alert('Failed to create room - connection timeout. Please try local mode or set up Firebase.');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                }, 5000); // 5 second timeout
                
                roomRef.set({
                    host: playerId,
                    gameState: {
                        ...initialState,
                        gameStarted: false
                    },
                    players: {
                        [playerId]: {
                            id: playerId,
                            name: playerName,
                            connected: true,
                            joinedAt: Date.now()
                        }
                    }
                }).then(() => {
                    clearTimeout(timeout);
                    dispatch({ type: 'SET_ROOM_INFO', roomCode, isHost: true });
                    dispatch({ type: 'SET_MY_PLAYER_INFO', playerId, playerName });
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connected' });
                    
                    // Listen for player updates
                    setupRoomListeners(roomCode, dispatch, playerId);
                }).catch(error => {
                    clearTimeout(timeout);
                    console.error('Error creating room:', error);
                    alert('Failed to create room. Firebase is not properly configured. Please use local mode for now.');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                });
            } else {
                alert('Multiplayer requires Firebase setup. Please use local mode for now.');
                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
            }
        }
        
        function joinRoom(dispatch, roomCode, playerName) {
            if (database) {
                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connecting' });
                
                // Add timeout to prevent infinite loading
                const timeout = setTimeout(() => {
                    console.error('Room join timeout');
                    alert('Failed to join room - connection timeout. Please try local mode or check the room code.');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                }, 5000); // 5 second timeout
                
                const roomRef = database.ref(`rooms/${roomCode}`);
                roomRef.once('value').then(snapshot => {
                    clearTimeout(timeout);
                    if (snapshot.exists()) {
                        const roomData = snapshot.val();
                        const players = roomData.players || {};
                        
                        // Find available player slot (1-4)
                        let playerId = null;
                        for (let i = 1; i <= 4; i++) {
                            if (!players[i] || !players[i].connected) {
                                playerId = i;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            // Join the room
                            roomRef.child(`players/${playerId}`).set({
                                id: playerId,
                                name: playerName,
                                connected: true,
                                joinedAt: Date.now()
                            }).then(() => {
                                dispatch({ type: 'SET_ROOM_INFO', roomCode, isHost: false });
                                dispatch({ type: 'SET_MY_PLAYER_INFO', playerId, playerName });
                                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connected' });
                                
                                // Load current game state
                                if (roomData.gameState) {
                                    dispatch({ type: 'SYNC_GAME_STATE', gameState: roomData.gameState });
                                }
                                
                                // Listen for updates
                                setupRoomListeners(roomCode, dispatch, playerId);
                            });
                        } else {
                            alert('Room is full (4 players max)');
                            dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                        }
                    } else {
                        alert('Room not found');
                        dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                    }
                }).catch(error => {
                    console.error('Error joining room:', error);
                    alert('Failed to join room');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                });
            } else {
                alert('Firebase not available. Using local mode.');
            }
        }
        
        function setupRoomListeners(roomCode, dispatch, myPlayerId) {
            if (!database) return;
            
            const roomRef = database.ref(`rooms/${roomCode}`);
            
            // Listen for player changes
            roomRef.child('players').on('value', snapshot => {
                const players = snapshot.val() || {};
                dispatch({ type: 'UPDATE_CONNECTED_PLAYERS', connectedPlayers: players });
                
                // Check if host disconnected and transfer host status
                const connectedPlayers = Object.values(players).filter(p => p.connected);
                const currentHost = connectedPlayers.find(p => p.id === 1);
                
                if (!currentHost && connectedPlayers.length > 0) {
                    // Original host (player 1) disconnected, make lowest ID the new host
                    const newHost = connectedPlayers.reduce((lowest, player) => 
                        player.id < lowest.id ? player : lowest
                    );
                    
                    if (newHost.id === myPlayerId) {
                        // I become the new host
                        dispatch({ type: 'SET_ROOM_INFO', roomCode: roomCode, isHost: true });
                        console.log(`Player ${myPlayerId} is now the host`);
                    }
                }
            });
            
            // Listen for game state changes
            roomRef.child('gameState').on('value', snapshot => {
                const gameState = snapshot.val();
                if (gameState) {
                    dispatch({ type: 'SYNC_GAME_STATE', gameState });
                }
            });
            
            // Handle disconnection
            roomRef.child(`players/${myPlayerId}/connected`).onDisconnect().set(false);
        }
        
        function syncGameState(roomCode, gameState) {
            if (database && roomCode) {
                database.ref(`rooms/${roomCode}/gameState`).set(gameState);
            }
        }
        
        function startMultiplayerGame(roomCode) {
            if (database && roomCode) {
                // Get current connected players and initialize proper game state
                database.ref(`rooms/${roomCode}/players`).once('value', (snapshot) => {
                    const connectedPlayers = snapshot.val() || {};
                    const playerCount = Object.keys(connectedPlayers).length;
                    
                    // Create proper player objects with all required fields
                    const players = [];
                    Object.values(connectedPlayers).forEach((player, index) => {
                        players.push({
                            id: player.id,
                            name: player.name,
                            resources: { red: 0, yellow: 0, blue: 0, purple: 0 },
                            workersLeft: 4,
                            effects: [],
                            victoryPoints: 0
                        });
                    });
                    
                    // Initialize complete game state
                    const gameState = {
                        currentPlayer: 1,
                        turnDirection: 1,
                        players: players,
                        occupiedSpaces: {},
                        round: 1,
                        turnOrder: players.map(p => p.id),
                        workerPlacedThisTurn: false,
                        workersToPlace: 1,
                        actionLog: [],
                        gameStarted: true
                    };
                    
                    database.ref(`rooms/${roomCode}/gameState`).set(gameState);
                });
            }
        }

        // Room Lobby Component
        function RoomLobby() {
            const { state, dispatch } = useGame();
            const [playerName, setPlayerName] = useState('');
            const [roomCodeInput, setRoomCodeInput] = useState('');
            const [mode, setMode] = useState('menu'); // 'menu', 'create', 'join'
            
            const handleCreateRoom = () => {
                if (!playerName.trim()) {
                    alert('Please enter your name');
                    return;
                }
                createRoom(dispatch, playerName.trim());
            };
            
            const handleJoinRoom = () => {
                if (!playerName.trim()) {
                    alert('Please enter your name');
                    return;
                }
                if (!roomCodeInput.trim()) {
                    alert('Please enter room code');
                    return;
                }
                joinRoom(dispatch, roomCodeInput.trim().toUpperCase(), playerName.trim());
            };
            
            const handlePlayLocal = () => {
                // For local play, use 4 players
                const selectedLayers = selectGameLayers(4);
                dispatch({ type: 'SET_GAME_LAYERS', layers: selectedLayers });
                dispatch({ type: 'START_GAME' });
            };
            
            return React.createElement('div', { 
                className: 'min-h-screen flex items-center justify-center p-4'
            }, React.createElement('div', {
                className: 'glass rounded-xl shadow-2xl p-8 max-w-md w-full'
            }, [
                React.createElement('div', { key: 'header', className: 'text-center mb-8' }, [
                    React.createElement('h1', { 
                        key: 'title',
                        className: 'text-3xl font-bold text-gray-800 mb-2' 
                    }, 'Patrons'),
                    React.createElement('p', { 
                        key: 'subtitle',
                        className: 'text-gray-600' 
                    }, 'Choose your game mode')
                ]),
                
                mode === 'menu' && React.createElement('div', { key: 'menu', className: 'space-y-4' }, [
                    React.createElement('input', {
                        key: 'name',
                        type: 'text',
                        placeholder: 'Enter your name',
                        value: playerName,
                        onChange: (e) => setPlayerName(e.target.value),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent'
                    }),
                    React.createElement('button', {
                        key: 'create',
                        onClick: () => setMode('create'),
                        className: 'w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, '🎮 Create Online Game'),
                    React.createElement('button', {
                        key: 'join',
                        onClick: () => setMode('join'),
                        className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, '🚪 Join Online Game'),
                    React.createElement('button', {
                        key: 'local',
                        onClick: handlePlayLocal,
                        className: 'w-full bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, '💻 Play Local (Same Device)')
                ]),
                
                mode === 'create' && React.createElement('div', { key: 'create', className: 'space-y-4' }, [
                    React.createElement('h3', { 
                        key: 'title',
                        className: 'text-xl font-bold text-center mb-4' 
                    }, 'Create Room'),
                    React.createElement('input', {
                        key: 'name',
                        type: 'text',
                        placeholder: 'Enter your name',
                        value: playerName,
                        onChange: (e) => setPlayerName(e.target.value),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent'
                    }),
                    React.createElement('button', {
                        key: 'create',
                        onClick: handleCreateRoom,
                        disabled: state.connectionStatus === 'connecting',
                        className: 'w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200 disabled:transform-none'
                    }, state.connectionStatus === 'connecting' ? 'Creating...' : 'Create Room'),
                    React.createElement('button', {
                        key: 'back',
                        onClick: () => setMode('menu'),
                        className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Back')
                ]),
                
                mode === 'join' && React.createElement('div', { key: 'join', className: 'space-y-4' }, [
                    React.createElement('h3', { 
                        key: 'title',
                        className: 'text-xl font-bold text-center mb-4' 
                    }, 'Join Room'),
                    React.createElement('input', {
                        key: 'name',
                        type: 'text',
                        placeholder: 'Enter your name',
                        value: playerName,
                        onChange: (e) => setPlayerName(e.target.value),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent'
                    }),
                    React.createElement('input', {
                        key: 'code',
                        type: 'text',
                        placeholder: 'Enter room code',
                        value: roomCodeInput,
                        onChange: (e) => setRoomCodeInput(e.target.value.toUpperCase()),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent'
                    }),
                    React.createElement('button', {
                        key: 'join',
                        onClick: handleJoinRoom,
                        disabled: state.connectionStatus === 'connecting',
                        className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200 disabled:transform-none'
                    }, state.connectionStatus === 'connecting' ? 'Joining...' : 'Join Room'),
                    React.createElement('button', {
                        key: 'back',
                        onClick: () => setMode('menu'),
                        className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Back')
                ])
            ]));
        }
        
        // Connected Players Component
        function ConnectedPlayers() {
            const { state, dispatch } = useGame();
            const connectedCount = Object.keys(state.connectedPlayers).length;
            
            const handleStartGame = () => {
                if (connectedCount >= 2) {
                    console.log('Starting game with', connectedCount, 'players');
                    // Select layers based on actual connected player count
                    const selectedLayers = selectGameLayers(connectedCount);
                    console.log('Selected layers:', Object.keys(selectedLayers));
                    dispatch({ type: 'SET_GAME_LAYERS', layers: selectedLayers });
                    startMultiplayerGame(state.roomCode);
                    dispatch({ type: 'START_GAME' });
                    console.log('Game started successfully');
                } else {
                    alert('Need at least 2 players to start');
                }
            };
            
            const handleLeaveRoom = () => {
                if (confirm('Are you sure you want to leave the room?')) {
                    window.location.reload();
                }
            };
            
            return React.createElement('div', {
                className: 'glass rounded-lg p-4 mb-6'
            }, [
                React.createElement('div', { key: 'header', className: 'flex justify-between items-center mb-4' }, [
                    React.createElement('div', { key: 'info' }, [
                        React.createElement('h3', { 
                            key: 'title',
                            className: 'text-lg font-bold text-gray-800' 
                        }, `Room: ${state.roomCode}`),
                        React.createElement('p', { 
                            key: 'count',
                            className: 'text-sm text-gray-600' 
                        }, `${connectedCount}/4 players connected`)
                    ]),
                    React.createElement('button', {
                        key: 'leave',
                        onClick: handleLeaveRoom,
                        className: 'bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm'
                    }, 'Leave')
                ]),
                React.createElement('div', { key: 'players', className: 'grid grid-cols-2 gap-2 mb-4' }, 
                    Object.values(state.connectedPlayers).map(player => 
                        React.createElement('div', {
                            key: player.id,
                            className: `p-2 rounded border-2 ${player.connected ? 'border-green-400 bg-green-50' : 'border-gray-300 bg-gray-50'} ${player.id === state.myPlayerId ? 'ring-2 ring-blue-400' : ''}`
                        }, [
                            React.createElement('div', { 
                                key: 'name',
                                className: 'font-semibold' 
                            }, `Player ${player.id}: ${player.name}`),
                            React.createElement('div', { 
                                key: 'status',
                                className: `text-xs ${player.connected ? 'text-green-600' : 'text-gray-500'}` 
                            }, player.connected ? '🟢 Connected' : '🔴 Disconnected'),
                            player.id === state.myPlayerId && React.createElement('div', { 
                                key: 'you',
                                className: 'text-xs text-blue-600 font-bold' 
                            }, '(You)')
                        ])
                    )
                ),
                state.isHost && !state.gameStarted && React.createElement('button', {
                    key: 'start',
                    onClick: handleStartGame,
                    disabled: connectedCount < 2,
                    className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200'
                }, connectedCount >= 2 ? 'Start Game' : 'Need 2+ Players to Start')
            ]);
        }

        // Action Space Component - Enhanced with compact mode and round indicators
        function ActionSpace({ actionId, title, description, round, available = true, compact = false }) {
            const { state, dispatch } = useGame();
            const isOccupied = state.occupiedSpaces[actionId];
            const occupyingPlayer = isOccupied ? state.players.find(p => p.id === isOccupied) : null;
            
            const handleClick = async () => {
                if (isOccupied || !available) return;
                
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                if (currentPlayer.workersLeft <= 0) return;
                
                if (state.workersToPlace <= 0) {
                    alert('You have already placed all your workers this turn. End your turn or buy from shops.');
                    return;
                }
                
                dispatch({ type: 'PLACE_WORKER', actionId });
                
                // Get fresh state after worker placement for repeat actions
                const freshState = { ...state, occupiedSpaces: { ...state.occupiedSpaces, [actionId]: state.currentPlayer } };
                await executeAction(actionId, currentPlayer, dispatch, freshState, state.gameLayers);
                
                const message = `Action completed: ${actionId} for Player ${currentPlayer.id}`;
                dispatch({ type: 'ADD_LOG', message });
                console.log(message);
            };
            
            const getRoundStyle = () => {
                if (round === 1) return 'bg-gray-100 border-gray-300';
                if (round === 2) return 'bg-green-100 border-green-500';
                if (round === 3) return 'bg-yellow-100 border-yellow-500';
                return 'bg-gray-100 border-gray-300';
            };
            
            const getAvailabilityStyle = () => {
                if (!available) return 'opacity-50';
                if (isOccupied) return 'bg-red-100 border-red-400 cursor-not-allowed';
                return 'hover:bg-blue-50 hover:border-blue-400 cursor-pointer transform hover:scale-105';
            };
            
            const getRoundIndicator = () => {
                const baseStyle = "absolute top-1 left-1 px-2 py-1 rounded-full text-xs font-bold text-white";
                switch (round) {
                    case 1: return `${baseStyle} bg-gray-500`;
                    case 2: return `${baseStyle} bg-green-500`;
                    case 3: return `${baseStyle} bg-yellow-600`;
                    default: return `${baseStyle} bg-gray-500`;
                }
            };
            
            const getCardSize = () => {
                return compact ? 'p-2 min-h-14' : 'p-3 min-h-20';
            };
            
            const getTextSize = () => {
                return compact ? {
                    title: 'text-xs',
                    desc: 'text-xs'
                } : {
                    title: 'text-sm',
                    desc: 'text-xs'
                };
            };
            
            const textSizes = getTextSize();
            
            return React.createElement('div', {
                className: `relative ${getCardSize()} border-2 rounded-lg flex flex-col justify-center text-center transition-all duration-200 ${getRoundStyle()} ${getAvailabilityStyle()}`,
                onClick: handleClick
            }, [
                React.createElement('div', { key: 'title', className: `font-bold ${textSizes.title} mb-1` }, title),
                React.createElement('div', { key: 'desc', className: `${textSizes.desc} text-gray-600 leading-tight` }, description),
                occupyingPlayer && React.createElement('div', {
                    key: 'worker',
                    className: `absolute top-1 right-1 w-5 h-5 rounded-full flex items-center justify-center text-white text-xs font-bold player-${occupyingPlayer.id}`
                }, occupyingPlayer.id),
                React.createElement('div', { 
                    key: 'round-indicator', 
                    className: getRoundIndicator() 
                }, `R${round}`)
            ]);
        }

        // Simplified action execution
        async function executeAction(actionId, player, dispatch, currentState, gameLayers) {
            const basicGains = {
                'gain3red': { red: 3 },
                'gain2red': { red: 2 },
                'gain3blue': { blue: 3 },
                'gain2blue': { blue: 2 },
                'gain3purple': { purple: 3 },
                'gain2purple': { purple: 2 }
                // Note: gain3yellow and gain2yellow are NOT basic gains - they have special logic
            };
            
            if (basicGains[actionId]) {
                let resources = { ...basicGains[actionId] };
                
                // Check for doubling effect
                const hasDoubleEffect = (player.effects || []).some(effect => effect.includes('Next gain will be doubled'));
                if (hasDoubleEffect) {
                    // Double all gains
                    Object.keys(resources).forEach(color => {
                        resources[color] *= 2;
                    });
                    
                    // Remove the doubling effect after use
                    dispatch({
                        type: 'UPDATE_PLAYER_EFFECTS',
                        playerId: player.id,
                        effects: (player.effects || []).filter(effect => !effect.includes('Next gain will be doubled'))
                    });
                    
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')} (DOUBLED!)`;
                    dispatch({ type: 'ADD_LOG', message });
                } else {
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: resources
                });
                
                // RED AUTOMATIC VP: Award 1 VP for red layer actions
                if (actionId.includes('red')) {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: player.id,
                        vp: 1
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action` });
                }
                
                return;
            }
            
            // Yellow layer actions with player choice
            if (actionId === 'gain3yellow') {
                const colors = ['red', 'yellow', 'blue', 'purple'];
                const choices = [];
                
                for (let i = 0; i < 3; i++) {
                    const availableColors = colors.filter(c => !choices.includes(c));
                    const colorOptions = availableColors.map(color => ({
                        label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                        value: color
                    }));
                    
                    const choice = await showChoice(dispatch, 
                        `Choose color ${i + 1}/3 for different colored gems`, 
                        colorOptions
                    );
                    
                    if (choice) {
                        choices.push(choice);
                    } else {
                        // If cancelled, use first available
                        choices.push(availableColors[0]);
                    }
                }
                
                const resources = {};
                choices.forEach(color => {
                    resources[color] = (resources[color] || 0) + 1;
                });
                
                // Check for doubling effect
                const hasDoubleEffect = (player.effects || []).some(effect => effect.includes('Next gain will be doubled'));
                if (hasDoubleEffect) {
                    // Double all gains
                    Object.keys(resources).forEach(color => {
                        resources[color] *= 2;
                    });
                    
                    // Remove the doubling effect after use
                    dispatch({
                        type: 'UPDATE_PLAYER_EFFECTS',
                        playerId: player.id,
                        effects: (player.effects || []).filter(effect => !effect.includes('Next gain will be doubled'))
                    });
                    
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')} (DOUBLED!)`;
                    dispatch({ type: 'ADD_LOG', message });
                } else {
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources
                });
                return;
            }
            
            // Similar implementation for gain2yellow
            if (actionId === 'gain2yellow') {
                const colors = ['red', 'yellow', 'blue', 'purple'];
                const choices = [];
                
                for (let i = 0; i < 2; i++) {
                    const availableColors = colors.filter(c => !choices.includes(c));
                    const colorOptions = availableColors.map(color => ({
                        label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                        value: color
                    }));
                    
                    const choice = await showChoice(dispatch, 
                        `Choose color ${i + 1}/2 for different colored gems`, 
                        colorOptions
                    );
                    
                    if (choice) {
                        choices.push(choice);
                    } else {
                        choices.push(availableColors[0]);
                    }
                }
                
                const resources = {};
                choices.forEach(color => {
                    resources[color] = (resources[color] || 0) + 1;
                });
                
                // Check for doubling effect
                const hasDoubleEffect = (player.effects || []).some(effect => effect.includes('Next gain will be doubled'));
                if (hasDoubleEffect) {
                    // Double all gains
                    Object.keys(resources).forEach(color => {
                        resources[color] *= 2;
                    });
                    
                    // Remove the doubling effect after use
                    dispatch({
                        type: 'UPDATE_PLAYER_EFFECTS',
                        playerId: player.id,
                        effects: (player.effects || []).filter(effect => !effect.includes('Next gain will be doubled'))
                    });
                    
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')} (DOUBLED!)`;
                    dispatch({ type: 'ADD_LOG', message });
                } else {
                    const message = `Player ${player.id}: ${actionId} → +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources
                });
                return;
            }
            
            // NEW PURPLE LAYER ACTIONS
            if (actionId === 'gain4purpleSkip') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 4 }
                });
                
                // Set skip for next turn
                const newSkippedTurns = { ...state.skippedTurns };
                newSkippedTurns[player.id] = (newSkippedTurns[player.id] || 0) + 1;
                dispatch({
                    type: 'SET_SKIPPED_TURNS',
                    skippedTurns: newSkippedTurns
                });
                
                const message = `Player ${player.id}: gain4purpleSkip → +4 purple, will skip next turn`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (actionId === 'gain2purpleTakeBack') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 2 }
                });
                
                // Find workers on different quad
                const occupiedByPlayer = Object.entries(state.occupiedSpaces || {})
                    .filter(([actionId, playerId]) => playerId === player.id);
                
                if (occupiedByPlayer.length > 0) {
                    // Group by layer
                    const workersByLayer = {};
                    occupiedByPlayer.forEach(([actionId, playerId]) => {
                        const layer = Object.keys(gameLayers).find(color => 
                            gameLayers[color].actions.some(a => a.id === actionId)
                        );
                        if (layer) {
                            if (!workersByLayer[layer]) workersByLayer[layer] = [];
                            workersByLayer[layer].push(actionId);
                        }
                    });
                    
                    // Show options from different layers
                    const options = [];
                    Object.entries(workersByLayer).forEach(([layer, actions]) => {
                        actions.forEach(actionId => {
                            const action = gameLayers[layer].actions.find(a => a.id === actionId);
                            if (action) {
                                options.push({
                                    label: `${layer} - ${action.title}`,
                                    value: actionId
                                });
                            }
                        });
                    });
                    
                    if (options.length > 0) {
                        const choice = await showChoice(dispatch, 'Choose a worker to take back', options);
                        if (choice) {
                            // Remove worker and give it back
                            dispatch({
                                type: 'REMOVE_WORKER',
                                actionId: choice,
                                playerId: player.id
                            });
                            dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Took back worker from ${choice}` });
                        }
                    }
                }
                
                const message = `Player ${player.id}: gain2purpleTakeBack → +2 purple + take back worker`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (actionId === 'gain5purpleSkip') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 5 }
                });
                
                // Set skip for this turn (immediately)
                const newSkippedTurns = { ...state.skippedTurns };
                newSkippedTurns[player.id] = (newSkippedTurns[player.id] || 0) + 1;
                dispatch({
                    type: 'SET_SKIPPED_TURNS',
                    skippedTurns: newSkippedTurns
                });
                
                const message = `Player ${player.id}: gain5purpleSkip → +5 purple, skipping turn`;
                dispatch({ type: 'ADD_LOG', message });
                
                // Force end turn
                setTimeout(() => dispatch({ type: 'END_TURN' }), 100);
                return;
            }
            
            if (actionId === 'playThreeWorkers') {
                // Set the player to be able to place 3 more workers this turn
                dispatch({
                    type: 'SET_WORKERS_TO_PLACE',
                    count: 3
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Playing 3 workers this turn'
                });
                
                const message = `Player ${player.id}: playThreeWorkers → Can place 3 more workers this turn`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (actionId === 'gain4purpleWaitAll') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 4 }
                });
                
                // Set waiting status
                const newWaitingForOthers = { ...state.waitingForOthers };
                newWaitingForOthers[player.id] = true;
                dispatch({
                    type: 'SET_WAITING_FOR_OTHERS',
                    waitingForOthers: newWaitingForOthers
                });
                
                const message = `Player ${player.id}: gain4purpleWaitAll → +4 purple, waiting for others to run out`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Purple layer - Play two workers (immediately)
            if (actionId === 'playTwoWorkers') {
                // Set the player to be able to place 2 more workers this turn
                dispatch({
                    type: 'SET_WORKERS_TO_PLACE',
                    count: 2
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Playing 2 workers this turn'
                });
                
                const message = `Player ${player.id}: playTwoWorkers → Can place 2 more workers this turn`;
                dispatch({ type: 'ADD_LOG', message });
                console.log(message);
                return;
            }
            
            // OLD PURPLE ACTIONS - NO LONGER IN SPEC
            /* // Purple layer - Extra workers next round
            if (actionId === 'extraWorkers') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 1 }
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Will get 2 extra workers next round'
                });
                
                console.log(`Player ${player.id} will get 2 extra workers next round`);
                return;
            }
            
            // Purple layer - Any Round 1 Shop Benefit
            if (actionId === 'purpleShopHybrid') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 1 }
                });
                
                const shopOptions = [
                    { label: '🔴 R1: Repeat a worker\'s action', value: 'red1' },
                    { label: '🟡 R1: Double next gain', value: 'yellow1' },
                    { label: '🔵 R1: Close ⚪ shop this round', value: 'blue1' },
                    { label: '🟣 R1: Take an extra turn after this one', value: 'purple1' }
                ];
                
                const choice = await showChoice(dispatch, 
                    'Choose ⚪ Round 1 shop benefit', 
                    shopOptions
                );
                
                if (choice) {
                    switch(choice) {
                        case 'red1':
                            // Execute repeat action immediately
                            await executeRepeatAction(player, dispatch, currentState, gameLayers);
                            break;
                        case 'yellow1':
                            dispatch({
                                type: 'ADD_EFFECT',
                                playerId: player.id,
                                effect: 'Next gain will be doubled'
                            });
                            break;
                        case 'blue1':
                            dispatch({
                                type: 'ADD_EFFECT',
                                playerId: player.id,
                                effect: 'Can close ⚪ shop this round'
                            });
                            break;
                        case 'purple1':
                            dispatch({
                                type: 'ADD_EFFECT',
                                playerId: player.id,
                                effect: 'Will take an extra turn after this one'
                            });
                            break;
                    }
                    
                    const effectNames = {
                        'red1': 'Repeat worker action',
                        'yellow1': 'Double next gain',
                        'blue1': 'Close shop ability',
                        'purple1': 'Extra turn'
                    };
                    
                    const message = `Player ${player.id}: purpleShopHybrid → +1 purple + ${effectNames[choice]}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                return;
            }
            
            // Purple layer - Choose turn order
            if (actionId === 'purpleHybrid2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 1 }
                });
                
                const orderOptions = [
                    { label: '1 → 2 → 3 → 4', value: [1, 2, 3, 4] },
                    { label: '4 → 3 → 2 → 1', value: [4, 3, 2, 1] },
                    { label: '2 → 1 → 4 → 3', value: [2, 1, 4, 3] },
                    { label: '3 → 4 → 1 → 2', value: [3, 4, 1, 2] }
                ];
                
                const newOrder = await showChoice(dispatch, 
                    'Choose new turn order for next round', 
                    orderOptions
                );
                
                if (newOrder) {
                    // Apply the turn order change immediately for next round
                    dispatch({
                        type: 'SET_TURN_ORDER',
                        turnOrder: newOrder
                    });
                    
                    const message = `Player ${player.id}: purpleHybrid2 → +1 purple + set turn order to ${newOrder.join(' → ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                return;
            } */
            
            // Red layer - Repeat an action
            if (actionId === 'redRepeatAction') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { red: 1 }
                });
                
                // RED AUTOMATIC VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action` });
                
                const logMessage = `DEBUG: Occupied spaces: ${JSON.stringify(currentState.occupiedSpaces)}`;
                dispatch({ type: 'ADD_LOG', message: logMessage });
                
                // Find all occupied spaces that belong to the current player (excluding this repeat action)
                const playerSpaces = Object.entries(currentState.occupiedSpaces)
                    .filter(([spaceId, playerId]) => playerId === player.id && spaceId !== 'redRepeatAction')
                    .map(([spaceId]) => spaceId);
                
                const debugMessage = `DEBUG: Player spaces to repeat: ${playerSpaces.join(', ')}`;
                dispatch({ type: 'ADD_LOG', message: debugMessage });
                
                if (playerSpaces.length === 0) {
                    const message = `Player ${player.id}: redRepeatAction → +1 red (no other workers to repeat)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                if (playerSpaces.length === 1) {
                    // Only one option, auto-select it
                    const spaceId = playerSpaces[0];
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    
                    const message = `Player ${player.id}: redRepeatAction → +1 red + repeating ${actionTitle}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    // Execute the action again
                    await executeAction(spaceId, player, dispatch, currentState, gameLayers);
                    return;
                }
                
                // Multiple options, let player choose
                const repeatOptions = playerSpaces.map(spaceId => {
                    // Find the action details
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    return {
                        label: `Repeat: ${actionTitle}`,
                        value: spaceId
                    };
                });
                
                const choice = await showChoice(dispatch, 
                    'Choose an action to repeat', 
                    repeatOptions
                );
                
                if (choice) {
                    const message = `Player ${player.id}: redRepeatAction → +1 red + repeating ${choice}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    // Execute the chosen action again
                    await executeAction(choice, player, dispatch, currentState, gameLayers);
                }
                return;
            }
            
            // RED LAYER ACTIONS
            
            // Red hybrid actions - swap workers
            if (actionId === 'redHybrid1' || actionId === 'redHybrid2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { red: 1 }
                });
                
                // RED AUTOMATIC VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action` });
                
                // Find workers that can be swapped
                const allWorkers = Object.entries(currentState.occupiedSpaces);
                if (allWorkers.length < 2) {
                    const message = `Player ${player.id}: ${actionId} → +1 red (not enough workers to swap)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const workerOptions = allWorkers.map(([spaceId, playerId]) => ({
                    label: `Player ${playerId}'s worker on ${spaceId}`,
                    value: { spaceId, playerId }
                }));
                
                const worker1 = await showChoice(dispatch, 'Choose first worker to swap', workerOptions);
                if (!worker1) return;
                
                const remainingWorkers = workerOptions.filter(w => 
                    !(w.value.spaceId === worker1.spaceId && w.value.playerId === worker1.playerId)
                );
                
                const worker2 = await showChoice(dispatch, 'Choose second worker to swap', remainingWorkers);
                if (!worker2) return;
                
                // Perform the swap
                const newOccupiedSpaces = { ...currentState.occupiedSpaces };
                newOccupiedSpaces[worker1.spaceId] = worker2.playerId;
                newOccupiedSpaces[worker2.spaceId] = worker1.playerId;
                
                dispatch({
                    type: 'UPDATE_OCCUPIED_SPACES',
                    occupiedSpaces: newOccupiedSpaces
                });
                
                // Execute actions for the affected players
                if (actionId === 'redHybrid1') {
                    // Both players get actions
                    await executeAction(worker1.spaceId, currentState.players.find(p => p.id === worker2.playerId), dispatch, currentState, gameLayers);
                    await executeAction(worker2.spaceId, currentState.players.find(p => p.id === worker1.playerId), dispatch, currentState, gameLayers);
                } else {
                    // Only current player gets actions
                    await executeAction(worker1.spaceId, player, dispatch, currentState, gameLayers);
                    await executeAction(worker2.spaceId, player, dispatch, currentState, gameLayers);
                }
                
                const message = `Player ${player.id}: ${actionId} → +1 red + swapped workers`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Force red placement
            if (actionId === 'forceRedPlacement') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { red: 1 }
                });
                
                // RED AUTOMATIC VP
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action` });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Other players must place on red layer until full'
                });
                
                const message = `Player ${player.id}: forceRedPlacement → +1 red + forcing red placement`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Red R3 - Repeat all your worker actions
            if (actionId === 'redRepeatAll') {
                // RED AUTOMATIC VP for the action itself
                dispatch({
                    type: 'UPDATE_VP',
                    playerId: player.id,
                    vp: 1
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action` });
                
                // Find all spaces occupied by current player
                const playerSpaces = Object.entries(currentState.occupiedSpaces)
                    .filter(([spaceId, occupyingPlayerId]) => occupyingPlayerId === player.id && spaceId !== 'redRepeatAll')
                    .map(([spaceId]) => spaceId);
                
                if (playerSpaces.length === 0) {
                    const message = `Player ${player.id}: redRepeatAll → No other workers to repeat`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: redRepeatAll → Repeating ${playerSpaces.length} actions` });
                
                // Execute each action (this will also award VP for red actions)
                for (const spaceId of playerSpaces) {
                    await executeAction(spaceId, player, dispatch, currentState, gameLayers);
                }
                
                return;
            }
            
            // YELLOW LAYER ACTIONS
            
            // Steal gem actions
            if (actionId === 'steal2Gems' || actionId === 'steal3Gems') {
                const stealCount = actionId === 'steal2Gems' ? 2 : 3;
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                
                if (otherPlayers.length === 0) {
                    const message = `Player ${player.id}: ${actionId} → No other players to steal from`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                for (let i = 0; i < stealCount; i++) {
                    const targetOptions = otherPlayers
                        .filter(p => Object.values(p.resources).some(amount => amount > 0))
                        .map(p => ({
                            label: `Player ${p.id} (${Object.entries(p.resources).filter(([,amt]) => amt > 0).map(([color, amt]) => `${amt} ${color}`).join(', ')})`,
                            value: p.id
                        }));
                    
                    if (targetOptions.length === 0) break;
                    
                    const targetId = await showChoice(dispatch, `Choose player to steal from (${i + 1}/${stealCount})`, targetOptions);
                    if (!targetId) break;
                    
                    const targetPlayer = otherPlayers.find(p => p.id === targetId);
                    const availableColors = Object.entries(targetPlayer.resources)
                        .filter(([, amount]) => amount > 0)
                        .map(([color]) => ({
                            label: `${color.charAt(0).toUpperCase() + color.slice(1)} (${targetPlayer.resources[color]} available)`,
                            value: color
                        }));
                    
                    const colorToSteal = await showChoice(dispatch, `Choose color to steal from Player ${targetId}`, availableColors);
                    if (!colorToSteal) break;
                    
                    // Transfer the gem
                    dispatch({
                        type: 'UPDATE_RESOURCES',
                        playerId: targetId,
                        resources: { [colorToSteal]: -1 }
                    });
                    
                    dispatch({
                        type: 'UPDATE_RESOURCES',
                        playerId: player.id,
                        resources: { [colorToSteal]: 1 }
                    });
                }
                
                const message = `Player ${player.id}: ${actionId} → Stole ${stealCount} gem(s)`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Yellow hybrid actions
            if (actionId === 'yellowHybrid1') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { yellow: 1 }
                });
                
                // Trade any number of gems
                const totalGems = Object.values(player.resources).reduce((sum, amount) => sum + amount, 0);
                if (totalGems === 0) {
                    const message = `Player ${player.id}: yellowHybrid1 → +1 yellow (no gems to trade)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Ask how many gems to trade
                const numberOptions = [];
                for (let i = 1; i <= Math.min(totalGems, 10); i++) {
                    numberOptions.push({ label: `Trade ${i} gem${i > 1 ? 's' : ''}`, value: i });
                }
                
                const numberToTrade = await showChoice(dispatch, 'How many gems do you want to trade?', numberOptions);
                if (!numberToTrade) {
                    const message = `Player ${player.id}: yellowHybrid1 → +1 yellow (no trade)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Choose gems to trade away
                const tradeCost = {};
                for (let i = 0; i < numberToTrade; i++) {
                    const availableColors = Object.entries(player.resources)
                        .filter(([color, amount]) => amount + (tradeCost[color] || 0) > 0)
                        .map(([color, amount]) => ({
                            label: `${color.charAt(0).toUpperCase() + color.slice(1)} (${amount + (tradeCost[color] || 0)} available)`,
                            value: color
                        }));
                    
                    const colorToTrade = await showChoice(dispatch, `Choose gem to trade away (${i + 1}/${numberToTrade})`, availableColors);
                    if (colorToTrade) {
                        tradeCost[colorToTrade] = (tradeCost[colorToTrade] || 0) - 1;
                    }
                }
                
                // Choose gems to gain (same number)
                const colors = ['red', 'yellow', 'blue', 'purple'];
                const tradeGain = {};
                for (let i = 0; i < numberToTrade; i++) {
                    const colorOptions = colors.map(color => ({
                        label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                        value: color
                    }));
                    
                    const colorToGain = await showChoice(dispatch, `Choose gem to gain (${i + 1}/${numberToTrade})`, colorOptions);
                    if (colorToGain) {
                        tradeGain[colorToGain] = (tradeGain[colorToGain] || 0) + 1;
                    }
                }
                
                // Apply the trade
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { ...tradeCost, ...tradeGain }
                });
                
                const message = `Player ${player.id}: yellowHybrid1 → +1 yellow + traded ${numberToTrade} gems`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (actionId === 'yellowHybrid2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { yellow: 1 }
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Next gain will be doubled'
                });
                
                const message = `Player ${player.id}: yellowHybrid2 → +1 yellow + next gain doubled`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Yellow R3 - Swap all resources with another player
            if (actionId === 'yellowSwapResources') {
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                
                if (otherPlayers.length === 0) {
                    const message = `Player ${player.id}: yellowSwapResources → No other players to swap with`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const swapOptions = otherPlayers.map(p => ({
                    label: `Player ${p.id} (${Object.entries(p.resources).filter(([,amt]) => amt > 0).map(([color, amt]) => `${amt} ${color}`).join(', ') || 'no gems'})`,
                    value: p.id
                }));
                
                const targetPlayerId = await showChoice(dispatch, 'Choose player to swap all resources with', swapOptions);
                
                if (targetPlayerId) {
                    const targetPlayer = otherPlayers.find(p => p.id === targetPlayerId);
                    const playerResources = { ...player.resources };
                    const targetResources = { ...targetPlayer.resources };
                    
                    // Swap resources
                    dispatch({
                        type: 'SET_RESOURCES',
                        playerId: player.id,
                        resources: targetResources
                    });
                    
                    dispatch({
                        type: 'SET_RESOURCES',
                        playerId: targetPlayerId,
                        resources: playerResources
                    });
                    
                    const message = `Player ${player.id}: yellowSwapResources → Swapped all resources with Player ${targetPlayerId}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                return;
            }
            
            // BLUE LAYER ACTIONS
            
            // Blue shop benefit actions - gain any shop benefit even if closed
            // Blue R1 shop benefit action
            if (actionId === 'blueR1ShopBenefit') {
                // List all available R1 shops
                const shopOptions = [];
                const colors = ['red', 'yellow', 'blue', 'purple'];
                
                colors.forEach(color => {
                    // Only R1 shops
                    shopOptions.push({
                        label: `${color} R1 shop`,
                        value: { color, round: 1 }
                    });
                });
                
                const choice = await showChoice(dispatch, 'Choose any R1 shop benefit (ignores closed status)', shopOptions);
                
                if (choice) {
                    // Execute the shop benefit without paying cost
                    await executeShopBenefit(choice.color, choice.round, player, dispatch, state);
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Executed ${choice.color} R1 shop benefit` });
                    
                    // BLUE AUTOMATIC VP: All players get 1 VP when anyone uses any shop benefit
                    const allPlayers = state.players;
                    allPlayers.forEach(p => {
                        dispatch({
                            type: 'UPDATE_VP',
                            playerId: p.id,
                            vp: 1
                        });
                    });
                    dispatch({ type: 'ADD_LOG', message: 'All players: +1 VP (someone used a shop benefit)' });
                }
                
                return;
            }
            
            // Blue any shop benefit action (R3)
            if (actionId === 'blueAnyShopBenefit') {
                // List all available shops
                const shopOptions = [];
                const colors = ['red', 'yellow', 'blue', 'purple'];
                
                colors.forEach(color => {
                    // R1 shops
                    shopOptions.push({
                        label: `${color} R1 shop`,
                        value: { color, round: 1 }
                    });
                    // R2 shops
                    shopOptions.push({
                        label: `${color} R2 shop`,
                        value: { color, round: 2 }
                    });
                    // R3 shops
                    shopOptions.push({
                        label: `${color} R3 shop`,
                        value: { color, round: 3 }
                    });
                    // Victory shops
                    shopOptions.push({
                        label: `${color} Victory shop (3 VP)`,
                        value: { color, round: 'vp' }
                    });
                });
                
                const choice = await showChoice(dispatch, 'Choose any shop benefit (ignores closed status)', shopOptions);
                
                if (choice) {
                    // Execute the shop benefit without paying cost
                    if (choice.round === 'vp') {
                        // Grant 3 VP
                        dispatch({
                            type: 'UPDATE_VP',
                            playerId: player.id,
                            vp: 3
                        });
                        dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Gained 3 VP from ${choice.color} victory shop` });
                    } else {
                        // Execute regular shop effect
                        await executeShopBenefit(choice.color, choice.round, player, dispatch, state);
                        dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Executed ${choice.color} R${choice.round} shop benefit` });
                    }
                    
                    // BLUE AUTOMATIC VP: All players get 1 VP when anyone uses any shop benefit
                    const allPlayers = state.players;
                    allPlayers.forEach(p => {
                        dispatch({
                            type: 'UPDATE_VP',
                            playerId: p.id,
                            vp: 1
                        });
                    });
                    dispatch({ type: 'ADD_LOG', message: 'All players: +1 VP (someone used a shop benefit)' });
                }
                
                return;
            }
            
            // Blue reduce costs action
            if (actionId === 'blueReduceCosts') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { blue: 1 }
                });
                
                // Set cost reduction for this round
                dispatch({
                    type: 'SET_SHOP_COST_MODIFIER',
                    modifier: -1
                });
                
                const message = `Player ${player.id}: blueReduceCosts → +1 blue + shop costs reduced by 1 any`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Blue increase costs action
            if (actionId === 'blueIncreaseCosts') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { blue: 2 }
                });
                
                // Set cost increase for this round
                dispatch({
                    type: 'SET_SHOP_COST_MODIFIER',
                    modifier: 1
                });
                
                const message = `Player ${player.id}: blueIncreaseCosts → +2 blue + shop costs increased by 1 any`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Blue toggle shops action
            if (actionId === 'blueToggleShops') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { blue: 1 }
                });
                
                // Toggle all shops (flip status)
                dispatch({
                    type: 'FLIP_ALL_SHOPS'
                });
                
                const message = `Player ${player.id}: blueToggleShops → +1 blue + all shops toggled`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            console.log(`Player ${player.id} executed action: ${actionId}`);
        }

        // Custom Modal Components
        function Modal({ isOpen, onClose, children }) {
            if (!isOpen) return null;
            
            return React.createElement('div', {
                className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
                onClick: onClose
            }, React.createElement('div', {
                className: 'glass rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl',
                onClick: (e) => e.stopPropagation()
            }, children));
        }

        function ChoiceModal({ title, options, onSelect, onCancel }) {
            const { dispatch } = useGame();
            
            const handleSelect = (option) => {
                dispatch({ type: 'HIDE_MODAL' });
                onSelect(option);
            };
            
            const handleCancel = () => {
                dispatch({ type: 'HIDE_MODAL' });
                if (onCancel) onCancel();
            };
            
            return React.createElement('div', { className: 'text-center' }, [
                React.createElement('h3', { 
                    key: 'title', 
                    className: 'text-xl font-bold text-gray-800 mb-4' 
                }, title),
                React.createElement('div', { 
                    key: 'options', 
                    className: 'space-y-2 mb-6' 
                }, options.map((option, index) => 
                    React.createElement('button', {
                        key: index,
                        onClick: () => handleSelect(option.value || option),
                        className: 'w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, option.label || option)
                )),
                React.createElement('button', {
                    key: 'cancel',
                    onClick: handleCancel,
                    className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                }, 'Cancel')
            ]);
        }

        function ConfirmModal({ title, message, onConfirm, onCancel }) {
            const { dispatch } = useGame();
            
            const handleConfirm = () => {
                dispatch({ type: 'HIDE_MODAL' });
                onConfirm();
            };
            
            const handleCancel = () => {
                dispatch({ type: 'HIDE_MODAL' });
                if (onCancel) onCancel();
            };
            
            return React.createElement('div', { className: 'text-center' }, [
                React.createElement('h3', { 
                    key: 'title', 
                    className: 'text-xl font-bold text-gray-800 mb-2' 
                }, title),
                React.createElement('p', { 
                    key: 'message', 
                    className: 'text-gray-600 mb-6' 
                }, message),
                React.createElement('div', { 
                    key: 'buttons', 
                    className: 'flex gap-3' 
                }, [
                    React.createElement('button', {
                        key: 'cancel',
                        onClick: handleCancel,
                        className: 'flex-1 bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Cancel'),
                    React.createElement('button', {
                        key: 'confirm',
                        onClick: handleConfirm,
                        className: 'flex-1 bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Confirm')
                ])
            ]);
        }

        // Helper functions for custom prompts
        function showChoice(dispatch, title, options) {
            return new Promise((resolve) => {
                dispatch({
                    type: 'SHOW_MODAL',
                    modal: {
                        type: 'choice',
                        title,
                        options,
                        onSelect: resolve,
                        onCancel: () => resolve(null)
                    }
                });
            });
        }

        function showConfirm(dispatch, title, message) {
            return new Promise((resolve) => {
                dispatch({
                    type: 'SHOW_MODAL',
                    modal: {
                        type: 'confirm',
                        title,
                        message,
                        onConfirm: () => resolve(true),
                        onCancel: () => resolve(false)
                    }
                });
            });
        }

        // End Turn Button Component
        function EndTurnButton({ onEndTurn }) {
            return React.createElement('div', { className: 'mt-3 text-center' }, 
                React.createElement('button', {
                    onClick: onEndTurn,
                    className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200'
                }, 'End Turn')
            );
        }

        // Execute repeat action from red shop
        async function executeRepeatAction(player, dispatch, state, gameLayers) {
            const playerSpaces = Object.entries(state.occupiedSpaces)
                .filter(([spaceId, pid]) => pid === player.id)
                .map(([spaceId]) => spaceId);
            
            if (playerSpaces.length === 0) {
                const message = `Player ${player.id}: Red shop → No workers to repeat`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (playerSpaces.length === 1) {
                // Auto-select the only option
                const spaceId = playerSpaces[0];
                let actionTitle = spaceId;
                for (const layerData of Object.values(gameLayers)) {
                    const action = layerData.actions.find(a => a.id === spaceId);
                    if (action) {
                        actionTitle = action.title;
                        break;
                    }
                }
                
                const message = `Player ${player.id}: Red shop → Repeating ${actionTitle}`;
                dispatch({ type: 'ADD_LOG', message });
                
                await executeAction(spaceId, player, dispatch, state, gameLayers);
            } else {
                // Multiple options, let player choose
                const repeatOptions = playerSpaces.map(spaceId => {
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    return {
                        label: `Repeat: ${actionTitle}`,
                        value: spaceId
                    };
                });
                
                const choice = await showChoice(dispatch, 
                    'Choose an action to repeat', 
                    repeatOptions
                );
                
                if (choice) {
                    const message = `Player ${player.id}: Red shop → Repeating ${choice}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    await executeAction(choice, player, dispatch, state, gameLayers);
                }
            }
        }

        // Execute yellow 3 shop effect
        async function executeYellow3Shop(player, dispatch, state) {
            // Gain 9 gems ⚪ colors
            const colors = ['red', 'yellow', 'blue', 'purple'];
            const choices = [];
            
            for (let i = 0; i < 9; i++) {
                const colorOptions = colors.map(color => ({
                    label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                    value: color
                }));
                
                const choice = await showChoice(dispatch, 
                    `Choose color ${i + 1}/9 for ⚪ colored gems`, 
                    colorOptions
                );
                
                if (choice) {
                    choices.push(choice);
                } else {
                    choices.push(colors[0]); // Default to first color if cancelled
                }
            }
            
            const resources = {};
            choices.forEach(color => {
                resources[color] = (resources[color] || 0) + 1;
            });
            
            dispatch({
                type: 'UPDATE_RESOURCES',
                playerId: player.id,
                resources
            });
            
            // Each other player gains 1 gem of buyer's choice
            for (const otherPlayer of state.players) {
                if (otherPlayer.id !== player.id) {
                    const colorForOther = await showChoice(dispatch, 
                        `Choose a gem color for Player ${otherPlayer.id} to gain`, 
                        colors.map(color => ({
                            label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                            value: color
                        }))
                    );
                    
                    if (colorForOther) {
                        dispatch({
                            type: 'UPDATE_RESOURCES',
                            playerId: otherPlayer.id,
                            resources: { [colorForOther]: 1 }
                        });
                    }
                }
            }
            
            const message = `Player ${player.id}: Yellow R3 shop → Gained 9 gems, each other player gained 1 gem`;
            dispatch({ type: 'ADD_LOG', message });
        }
        
        // Execute yellow 2 shop effect
        async function executeYellow2Shop(player, dispatch, state) {
            // Gain 5 gems ⚪ colors
            const colors = ['red', 'yellow', 'blue', 'purple'];
            const choices = [];
            
            for (let i = 0; i < 5; i++) {
                const colorOptions = colors.map(color => ({
                    label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                    value: color
                }));
                
                const choice = await showChoice(dispatch, 
                    `Choose color ${i + 1}/5 for ⚪ colored gems`, 
                    colorOptions
                );
                
                if (choice) {
                    choices.push(choice);
                } else {
                    choices.push(colors[0]); // Default to first color if cancelled
                }
            }
            
            const resources = {};
            choices.forEach(color => {
                resources[color] = (resources[color] || 0) + 1;
            });
            
            dispatch({
                type: 'UPDATE_RESOURCES',
                playerId: player.id,
                resources
            });
            
            // Everyone gains 1 gem of buyer's choice
            const colorForOthers = await showChoice(dispatch, 
                `Choose a gem color for all other players to gain`, 
                colors.map(color => ({
                            label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                            value: color
                        }))
                    );
                    
            if (colorForOthers) {
                for (const otherPlayer of state.players) {
                    if (otherPlayer.id !== player.id) {
                        dispatch({
                            type: 'UPDATE_RESOURCES',
                            playerId: otherPlayer.id,
                            resources: { [colorForOthers]: 1 }
                        });
                    }
                }
            }
            
            const message = `Player ${player.id}: Yellow R2 shop → Gained 5 gems, everyone gained 1 ${colorForOthers || 'gem'}`;
            dispatch({ type: 'ADD_LOG', message });
        }
        
        // Execute blue 1 shop effect - Close any shop
        async function executeBlue1Shop(player, dispatch, state) {
            // List all shops
            const shopOptions = [];
            const colors = ['red', 'yellow', 'blue', 'purple'];
            
            colors.forEach(color => {
                // R1 shops
                if (!state.closedShops[`${color}1`]) {
                    shopOptions.push({
                        label: `${color} R1 shop`,
                        value: `${color}1`
                    });
                }
                // R2 shops
                if (!state.closedShops[`${color}2`]) {
                    shopOptions.push({
                        label: `${color} R2 shop`,
                        value: `${color}2`
                    });
                }
                // R3 shops if round 3
                if (state.round >= 3 && !state.closedShops[`${color}3`]) {
                    shopOptions.push({
                        label: `${color} R3 shop`,
                        value: `${color}3`
                    });
                }
                // Victory shops
                if (!state.closedShops[`${color}vp`]) {
                    shopOptions.push({
                        label: `${color} Victory shop`,
                        value: `${color}vp`
                    });
                }
            });
            
            if (shopOptions.length === 0) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: All shops are already closed!` });
                return;
            }
            
            const choice = await showChoice(dispatch, 'Choose a shop to close', shopOptions);
            
            if (choice) {
                dispatch({
                    type: 'CLOSE_SHOP',
                    shopId: choice
                });
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Closed ${choice} shop` });
            }
        }
        
        // Execute blue 3 shop effect - Any shop benefit
        async function executeBlue3Shop(player, dispatch, state) {
            // This is the same as blueAnyShopBenefit action
            // List all available shops
            const shopOptions = [];
            const colors = ['red', 'yellow', 'blue', 'purple'];
            
            colors.forEach(color => {
                // R1 shops
                shopOptions.push({
                    label: `${color} R1 shop`,
                    value: { color, round: 1 }
                });
                // R2 shops
                shopOptions.push({
                    label: `${color} R2 shop`,
                    value: { color, round: 2 }
                });
                // R3 shops
                shopOptions.push({
                    label: `${color} R3 shop`,
                    value: { color, round: 3 }
                });
                // Victory shops
                shopOptions.push({
                    label: `${color} Victory shop (3 VP)`,
                    value: { color, round: 'vp' }
                });
            });
            
            const choice = await showChoice(dispatch, 'Choose any shop benefit (ignores closed status)', shopOptions);
            
            if (choice) {
                // Execute the shop benefit without paying cost
                if (choice.round === 'vp') {
                    // Grant 3 VP
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: player.id,
                        vp: 3
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Gained 3 VP from ${choice.color} victory shop` });
                } else {
                    // Execute regular shop effect
                    await executeShopBenefit(choice.color, choice.round, player, dispatch, state);
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Executed ${choice.color} R${choice.round} shop benefit` });
                }
                
                // BLUE AUTOMATIC VP: All players get 1 VP when anyone uses any shop
                state.players.forEach(p => {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: p.id,
                        vp: 1
                    });
                });
                dispatch({ type: 'ADD_LOG', message: 'All players: +1 VP (someone used a shop)' });
            }
        }
        
        // Execute any shop benefit by shop ID
        async function executeShopBenefit(shopColor, shopRound, player, dispatch, state) {
            const shopId = `${shopColor}${shopRound}`;
            
            switch(shopId) {
                case 'red1':
                    // Repeat a worker's action
                    await executeRepeatAction(player, dispatch, state, state.gameLayers);
                    break;
                case 'red2':
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: player.id,
                        effect: 'Can place the next player\'s worker'
                    });
                    break;
                case 'red3':
                    // Repeat all actions taken this round
                    await executeRed3Shop(player, dispatch, state);
                    break;
                case 'yellow1':
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: player.id,
                        effect: 'Next gain will be doubled'
                    });
                    break;
                case 'yellow2':
                    await executeYellow2Shop(player, dispatch, state);
                    break;
                case 'yellow3':
                    await executeYellow3Shop(player, dispatch, state);
                    break;
                case 'blue1':
                    await executeBlue1Shop(player, dispatch, state);
                    break;
                case 'blue2':
                    // Flip all shops
                    dispatch({ type: 'FLIP_ALL_SHOPS' });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: All shops flipped!` });
                    break;
                case 'blue3':
                    await executeBlue3Shop(player, dispatch, state);
                    break;
                case 'purple1':
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: player.id,
                        effect: 'Will take an extra turn after this one'
                    });
                    break;
                case 'purple2':
                    dispatch({
                        type: 'SET_WORKERS_TO_PLACE',
                        count: 2
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Can place 2 more workers this turn!` });
                    break;
                case 'purple3':
                    const workersRemaining = player.workersLeft;
                    if (workersRemaining > 0) {
                        dispatch({
                            type: 'SET_WORKERS_TO_PLACE',
                            count: workersRemaining
                        });
                        dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Can place all ${workersRemaining} remaining workers!` });
                    }
                    break;
                default:
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Shop benefit ${shopId} not implemented yet` });
            }
        }
        
        // Execute red 3 shop effect - Repeat all actions taken this round
        async function executeRed3Shop(player, dispatch, state) {
            if (state.roundActions.length === 0) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: No actions have been taken this round!` });
                return;
            }
            
            // Show list of all actions taken this round
            const actionOptions = state.roundActions.map((roundAction, index) => {
                // Find the action details
                let actionTitle = roundAction.actionId;
                let layerColor = '';
                
                Object.entries(state.gameLayers || {}).forEach(([color, layer]) => {
                    const action = layer.actions.find(a => a.id === roundAction.actionId);
                    if (action) {
                        actionTitle = action.title;
                        layerColor = color;
                    }
                });
                
                return {
                    label: `Player ${roundAction.playerId}'s ${layerColor} action: ${actionTitle}`,
                    value: roundAction.actionId
                };
            });
            
            // Let player choose which actions to repeat
            const message = 'Choose actions to repeat (you can repeat all of them!)';
            let continueChoosing = true;
            const repeatedActions = [];
            
            while (continueChoosing && actionOptions.length > 0) {
                const choice = await showChoice(dispatch, message, [
                    ...actionOptions,
                    { label: 'Done repeating actions', value: 'done' }
                ]);
                
                if (!choice || choice === 'done') {
                    continueChoosing = false;
                } else {
                    repeatedActions.push(choice);
                    // Execute the action
                    await executeAction(choice, player, dispatch, state.occupiedSpaces, state.gameLayers, state, state.gameLayers);
                    
                    // RED AUTOMATIC VP: Gain 1 VP for red action
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: player.id,
                        vp: 1
                    });
                    dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: +1 VP for red action (repeat)` });
                }
            }
            
            if (repeatedActions.length > 0) {
                dispatch({ type: 'ADD_LOG', message: `Player ${player.id}: Repeated ${repeatedActions.length} actions from this round!` });
            }
        }

        // Effect activation function
        async function activateEffect(effect, playerId, effectIndex, dispatch, state) {
            const player = state.players.find(p => p.id === playerId);
            
            if (effect.includes('Can repeat a worker\'s action')) {
                // Find all occupied spaces that belong to the player
                const playerSpaces = Object.entries(state.occupiedSpaces)
                    .filter(([spaceId, pid]) => pid === playerId)
                    .map(([spaceId]) => spaceId);
                
                if (playerSpaces.length === 0) {
                    alert('No workers to repeat!');
                    return;
                }
                
                if (playerSpaces.length === 1) {
                    // Auto-select the only option
                    const spaceId = playerSpaces[0];
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    
                    const message = `Player ${playerId}: Used shop effect to repeat ${actionTitle}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    // Execute the action again
                    await executeAction(spaceId, player, dispatch, state, gameLayers);
                } else {
                    // Multiple options, let player choose
                    const repeatOptions = playerSpaces.map(spaceId => {
                        let actionTitle = spaceId;
                        for (const layerData of Object.values(gameLayers)) {
                            const action = layerData.actions.find(a => a.id === spaceId);
                            if (action) {
                                actionTitle = action.title;
                                break;
                            }
                        }
                        return {
                            label: `Repeat: ${actionTitle}`,
                            value: spaceId
                        };
                    });
                    
                    const choice = await showChoice(dispatch, 
                        'Choose an action to repeat', 
                        repeatOptions
                    );
                    
                    if (choice) {
                        const message = `Player ${playerId}: Used shop effect to repeat ${choice}`;
                        dispatch({ type: 'ADD_LOG', message });
                        
                        // Execute the chosen action again
                        await executeAction(choice, player, dispatch, state, gameLayers);
                    }
                }
                
                // Remove the effect after use
                dispatch({
                    type: 'UPDATE_PLAYER_EFFECTS',
                    playerId: playerId,
                    effects: (player.effects || []).filter((_, i) => i !== effectIndex)
                });
                
            } else if (effect.includes('Can close ⚪ shop this round')) {
                // Choose which shop to close
                const shopOptions = [
                    { label: 'Red Shop', value: 'red' },
                    { label: 'Yellow Shop', value: 'yellow' },
                    { label: 'Blue Shop', value: 'blue' },
                    { label: 'Purple Shop', value: 'purple' }
                ];
                
                const shopToClose = await showChoice(dispatch, 'Choose shop to close this round', shopOptions);
                if (shopToClose) {
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: playerId,
                        effect: `${shopToClose.charAt(0).toUpperCase() + shopToClose.slice(1)} shop is closed this round`
                    });
                    
                    dispatch({ type: 'ADD_LOG', message: `Player ${playerId}: Closed ${shopToClose} shop for this round` });
                }
                
                // Remove the activatable effect
                dispatch({
                    type: 'UPDATE_PLAYER_EFFECTS',
                    playerId: playerId,
                    effects: (player.effects || []).filter((_, i) => i !== effectIndex)
                });
                
            } else if (effect.includes('Will take an extra turn after this one')) {
                // Check if player is already at the end of snake (would get 2 turns naturally)
                const currentIndex = state.turnOrder.indexOf(state.currentPlayer);
                const isAtSnakeEnd = (state.turnDirection === 1 && currentIndex === state.turnOrder.length - 1) ||
                                   (state.turnDirection === -1 && currentIndex === 0);
                
                if (isAtSnakeEnd) {
                    alert('You are already at the end of the turn snake and will get another turn naturally. Extra turn effect not needed.');
                } else {
                    // Apply extra turn effect
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: state.currentPlayer,
                        effect: 'Will take an extra turn after this one'
                    });
                    
                    dispatch({ type: 'ADD_LOG', message: `Player ${state.currentPlayer}: Will take an extra turn after this one` });
                }
                
                // Remove the activatable effect regardless
                dispatch({
                    type: 'UPDATE_PLAYER_EFFECTS',
                    playerId: playerId,
                    effects: (player.effects || []).filter((_, i) => i !== effectIndex)
                });
                
            } else if (effect.includes('Can place the next player\'s worker')) {
                alert('Place next player\'s worker effect not implemented yet');
            } else if (effect.includes('Can undo the last player\'s turn')) {
                alert('Undo turn effect not implemented yet');
            }
        }

        // Get effect button for activatable effects
        function getEffectButton(effect, playerId, effectIndex) {
            const { state, dispatch } = useGame();
            
            const activatableEffects = [
                'Can repeat a worker\'s action',
                'Can close ⚪ shop this round',
                'Will take an extra turn after this one',
                'Can place the next player\'s worker',
                'Can undo the last player\'s turn'
            ];
            
            const isActivatable = activatableEffects.some(ae => effect.includes(ae));
            const isCurrentPlayer = state.currentPlayer === playerId;
            
            if (isActivatable && isCurrentPlayer) {
                return React.createElement('button', {
                    key: 'activate',
                    onClick: () => activateEffect(effect, playerId, effectIndex, dispatch, state),
                    className: 'bg-blue-500 hover:bg-blue-600 text-white text-xs px-2 py-1 rounded ml-2'
                }, 'Use');
            }
            
            return null;
        }

        // Player Card Component
        function PlayerCard({ player, isCurrentPlayer, onEndTurn }) {
            const { state } = useGame();
            
            // Get active colors from current game layers
            const activeColors = state.gameLayers ? Object.keys(state.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
            
            const getPlayerStyle = () => {
                let baseStyle = "glass rounded-lg shadow-lg p-4 transition-all duration-300";
                if (isCurrentPlayer) {
                    baseStyle += " ring-4 ring-blue-400 ring-opacity-60 shadow-xl transform scale-105 pulse-current";
                }
                return baseStyle;
            };
            
            const getResourceIcon = (color, amount) => {
                const colors = {
                    red: 'bg-red-500',
                    yellow: 'bg-yellow-500', 
                    blue: 'bg-blue-500',
                    purple: 'bg-purple-500',
                };
                
                const gemIcons = {
                    red: '🔴',
                    yellow: '🟡', 
                    blue: '🔵',
                    purple: '🟣'
                };
                
                const gemIcon = gemIcons[color] || '💎';
                
                return React.createElement('div', {
                    key: color,
                    className: `w-12 h-12 rounded-lg ${colors[color]} flex flex-col items-center justify-center text-white font-bold text-sm shadow-lg hover:shadow-xl transform hover:scale-110 transition-all`
                }, [
                    React.createElement('div', { key: 'icon', className: 'text-lg' }, gemIcon),
                    React.createElement('div', { key: 'amount', className: 'text-xs' }, amount)
                ]);
            };
            
            return React.createElement('div', { className: getPlayerStyle() }, [
                React.createElement('div', { key: 'header', className: 'flex items-center justify-between mb-4' }, [
                    React.createElement('h3', { key: 'name', className: 'font-bold text-lg text-gray-800' }, [
                        player.name,
                        isCurrentPlayer && React.createElement('span', { key: 'indicator', className: 'text-blue-500 ml-2' }, '🎯')
                    ]),
                    React.createElement('div', { key: 'vp', className: 'text-2xl font-bold text-blue-600 bg-blue-100 px-3 py-1 rounded-lg' }, `${player.victoryPoints} VP`)
                ]),
                React.createElement('div', { key: 'resources', className: 'flex gap-3 mb-4 justify-center' }, 
                    activeColors.map(color => 
                        getResourceIcon(color, player.resources[color] || 0)
                    )
                ),
                React.createElement('div', { key: 'workers', className: 'text-center text-gray-700 font-semibold mb-3' }, 
                    `Workers left: ${player.workersLeft}`),
                (player.effects && player.effects.length > 0) && React.createElement('div', { key: 'effects', className: 'mb-3' }, [
                    React.createElement('div', { key: 'label', className: 'text-xs font-semibold text-gray-600 mb-1' }, 'Effects:'),
                    ...(player.effects || []).map((effect, index) => 
                        React.createElement('div', { 
                            key: `effect-${index}`, 
                            className: 'bg-yellow-100 border border-yellow-300 rounded px-2 py-1 mb-1 text-xs flex justify-between items-center' 
                        }, [
                            React.createElement('span', { key: 'text' }, effect),
                            getEffectButton(effect, player.id, index)
                        ])
                    )
                ]),
                isCurrentPlayer && React.createElement(EndTurnButton, { key: 'end-turn', onEndTurn })
            ]);
        }

        // Game Layer Component - Card-focused layout with shops at top
        function GameLayer({ color, title, icon, actions, round }) {
            const getLayerStyle = () => {
                const baseStyle = "glass rounded-lg shadow-lg p-4 border-t-6 hover:shadow-xl transition-all duration-300 h-full flex flex-col";
                switch (color) {
                    case 'red': return `${baseStyle} border-t-red-500`;
                    case 'yellow': return `${baseStyle} border-t-yellow-500`;
                    case 'blue': return `${baseStyle} border-t-blue-500`;
                    case 'purple': return `${baseStyle} border-t-purple-500`;
                    default: return `${baseStyle} border-t-gray-500`;
                }
            };
            
            const getIconColor = () => {
                switch (color) {
                    case 'red': return 'text-red-500';
                    case 'yellow': return 'text-yellow-500';
                    case 'blue': return 'text-blue-500';
                    case 'purple': return 'text-purple-500';
                    default: return 'text-gray-500';
                }
            };
            
            const availableActions = actions.filter(action => action.round <= round);
            
            return React.createElement('div', { className: getLayerStyle() }, [
                // Card Header - Layer title and color
                React.createElement('div', { key: 'header', className: 'flex justify-between items-center mb-4' }, [
                    React.createElement('h2', { key: 'title', className: `text-xl font-bold ${getIconColor()}` }, 
                        `${icon} ${color.charAt(0).toUpperCase() + color.slice(1)}`),
                    React.createElement('span', { key: 'round', className: 'text-gray-600 text-sm bg-white px-2 py-1 rounded shadow' }, 
                        `Round ${round}`)
                ]),
                
                // Shops Section - Compact horizontal layout
                React.createElement('div', { key: 'shops', className: 'mb-3 bg-white bg-opacity-10 rounded-lg p-2' }, [
                    React.createElement('div', { key: 'shop-header', className: 'text-sm font-semibold text-gray-700 mb-1' }, '🏪 Shops'),
                    React.createElement('div', { key: 'shop-grid', className: 'grid grid-cols-4 gap-1 text-xs' }, [
                        React.createElement(CompactShop, { key: 'shop-r1', color, round: 1, label: 'R1' }),
                        React.createElement(CompactShop, { key: 'shop-r2', color, round: 2, label: 'R2' }),
                        round >= 3 ? React.createElement(CompactShop, { key: 'shop-r3', color, round: 3, label: 'R3' }) : React.createElement('div', { key: 'empty' }),
                        React.createElement(CompactVictoryShop, { key: 'shop-vp', color })
                    ])
                ]),
                
                // Action Spaces Section - Below shops
                React.createElement('div', { key: 'actions-section', className: 'flex-1' }, [
                    React.createElement('h3', { key: 'actions-title', className: 'text-lg font-semibold mb-3 text-gray-800' }, '⚡ Actions'),
                    React.createElement('div', { key: 'actions', className: 'grid grid-cols-2 gap-2' }, 
                        availableActions.map(action => 
                            React.createElement(ActionSpace, {
                                key: action.id,
                                actionId: action.id,
                                title: action.title,
                                description: action.description,
                                round: action.round,
                                available: action.round <= round,
                                compact: true // New prop for smaller action spaces
                            })
                        )
                    )
                ])
            ]);
        }

        // Regular Shop Component
        function RegularShop({ color, round }) {
            const { state, dispatch } = useGame();
            
            const shopData = {
                red: {
                    1: { cost: { red: 1, any: 1 }, effect: 'Repeat a worker\'s action' },
                    2: { cost: { red: 2, any: 2 }, effect: 'Place the next player\'s worker' },
                    3: { cost: { red: 3, any: 3 }, effect: 'Repeat all actions taken this round by ⚪ player' }
                },
                yellow: {
                    1: { cost: { yellow: 1, any: 1 }, effect: 'Double your next gain action' },
                    2: { cost: { yellow: 2, any: 2 }, effect: 'Gain 5 gems ⚪ color, everyone gains 1 gem of your choice' },
                    3: { cost: { yellow: 3, any: 3 }, effect: 'Gain 9 gems of ⚪ kind, each other player gains 1 color of your choice' }
                },
                blue: {
                    1: { cost: { blue: 1, any: 1 }, effect: 'Close ⚪ shop this round' },
                    2: { cost: { blue: 2, any: 2 }, effect: 'Gain a shop benefit then close that shop' },
                    3: { cost: { blue: 3, any: 3 }, effect: 'Flip the status of all shops, including victory shops' }
                },
                purple: {
                    1: { cost: { purple: 1, any: 1 }, effect: 'Take an extra turn after this one' },
                    2: { cost: { purple: 2, any: 2 }, effect: 'Play 2 more workers this turn' },
                    3: { cost: { purple: 3, any: 3 }, effect: 'Play the rest of your workers' }
                }
            };
            
            const handlePurchase = async (shopRound) => {
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                // Check if this shop is closed
                const shopId = `${color}${shopRound}`;
                if (state.closedShops[shopId]) {
                    alert(`${color.charAt(0).toUpperCase() + color.slice(1)} R${shopRound} shop is closed!`);
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                const shop = shopData[color][shopRound];
                
                // Check if player has enough resources
                const colorRequired = shop.cost[color] || 0;
                let anyRequired = shop.cost.any || 0;
                
                // Apply cost modifier
                anyRequired = Math.max(0, anyRequired + state.shopCostModifier);
                
                if (currentPlayer.resources[color] < colorRequired) {
                    alert(`Need ${colorRequired} ${color} gems. You have ${currentPlayer.resources[color]}.`);
                    return;
                }
                
                if (anyRequired > 0) {
                    const totalAllGems = Object.values(currentPlayer.resources).reduce((sum, amount) => sum + amount, 0);
                    const totalAvailableForAny = totalAllGems - colorRequired; // Subtract the specific color requirement
                    
                    if (totalAvailableForAny < anyRequired) {
                        alert(`Need ${anyRequired} additional gems of ⚪ color. You have ${totalAvailableForAny} available.`);
                        return;
                    }
                }
                
                // Deduct the specific color cost
                const resourceCost = {};
                if (colorRequired > 0) {
                    resourceCost[color] = -colorRequired;
                }
                
                // Deduct "any" cost - let player choose colors
                if (anyRequired > 0) {
                    let remaining = anyRequired;
                    
                    while (remaining > 0) {
                        const colorOptions = ['red', 'yellow', 'blue', 'purple']
                            .filter(c => {
                                const currentAmount = currentPlayer.resources[c];
                                const alreadySpent = resourceCost[c] ? -resourceCost[c] : 0;
                                return (currentAmount - alreadySpent) > 0;
                            })
                            .map(c => {
                                const currentAmount = currentPlayer.resources[c];
                                const alreadySpent = resourceCost[c] ? -resourceCost[c] : 0;
                                const available = currentAmount - alreadySpent;
                                return {
                                    label: `${c.charAt(0).toUpperCase() + c.slice(1)} (${available} available)`,
                                    value: c
                                };
                            });
                        
                        if (colorOptions.length === 0) break;
                        
                        const choice = await showChoice(dispatch, 
                            `Choose color to spend (${remaining} more needed)`, 
                            colorOptions
                        );
                        
                        if (choice) {
                            resourceCost[choice] = (resourceCost[choice] || 0) - 1;
                            remaining -= 1;
                        } else {
                            // If cancelled, auto-select first available
                            const autoChoice = colorOptions[0].value;
                            resourceCost[autoChoice] = (resourceCost[autoChoice] || 0) - 1;
                            remaining -= 1;
                        }
                    }
                }
                
                dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                
                // Apply the shop effect immediately
                switch(`${color}${shopRound}`) {
                    case 'red1':
                        // Repeat a worker's action - execute immediately
                        await executeRepeatAction(currentPlayer, dispatch, state, state.gameLayers);
                        break;
                    case 'red2':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Can place the next player\'s worker'
                        });
                        break;
                    case 'yellow1':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Next gain will be doubled'
                        });
                        break;
                    case 'yellow2':
                        // Gain 5 gems ⚪ colors + everyone gains gem - execute immediately
                        await executeYellow2Shop(currentPlayer, dispatch, state);
                        break;
                    case 'yellow3':
                        // Gain 9 gems ⚪ colors + everyone gains 1 each - execute immediately
                        await executeYellow3Shop(currentPlayer, dispatch, state);
                        break;
                    case 'red3':
                        // Repeat all actions taken this round by any player - execute immediately
                        await executeRed3Shop(currentPlayer, dispatch, state);
                        break;
                    case 'blue1':
                        // Close any shop this round - let player choose
                        await executeBlue1Shop(currentPlayer, dispatch, state);
                        break;
                    case 'blue2':
                        // Flip all shops immediately
                        dispatch({ type: 'FLIP_ALL_SHOPS' });
                        dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: All shops flipped!` });
                        break;
                    case 'blue3':
                        // Gain any shop benefit (even if closed) - execute immediately
                        await executeBlue3Shop(currentPlayer, dispatch, state);
                        break;
                    case 'purple1':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Will take an extra turn after this one'
                        });
                        break;
                    case 'purple2':
                        // Play 2 more workers this turn
                        dispatch({
                            type: 'SET_WORKERS_TO_PLACE',
                            count: 2
                        });
                        dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Can place 2 more workers this turn!` });
                        break;
                    case 'purple3':
                        // Play the rest of your workers
                        const workersRemaining = currentPlayer.workersLeft;
                        if (workersRemaining > 0) {
                            dispatch({
                                type: 'SET_WORKERS_TO_PLACE',
                                count: workersRemaining
                            });
                            dispatch({ type: 'ADD_LOG', message: `Player ${currentPlayer.id}: Can place all ${workersRemaining} remaining workers!` });
                        }
                        break;
                }
                
                const message = `Player ${currentPlayer.id}: Bought ${color} R${shopRound} shop`;
                dispatch({ type: 'ADD_LOG', message });
                console.log(message);
                
                // BLUE AUTOMATIC VP: All players get 1 VP when any shop is used
                state.players.forEach(p => {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: p.id,
                        vp: 1
                    });
                });
                dispatch({ type: 'ADD_LOG', message: 'All players: +1 VP (someone used a shop)' });
            };
            
            const round1Shop = shopData[color][1];
            const round2Shop = shopData[color][2];
            
            return React.createElement('div', { 
                className: 'bg-gradient-to-br from-yellow-100 to-yellow-200 border-2 border-yellow-400 rounded-lg p-3 shadow-md hover:shadow-lg transition-all' 
            }, [
                React.createElement('div', { key: 'title', className: 'text-center font-bold text-yellow-700 mb-2 text-sm' }, `🛒 ${color.charAt(0).toUpperCase() + color.slice(1)}`),
                
                React.createElement('div', { key: 'round1', className: 'text-xs mb-2' }, [
                    React.createElement('div', { key: 'desc', className: 'mb-1 text-yellow-800' }, 
                        `R1: ${round1Shop.effect.length > 20 ? round1Shop.effect.substring(0, 20) + '...' : round1Shop.effect}`),
                    React.createElement('button', {
                        key: 'btn',
                        onClick: () => handlePurchase(1),
                        className: 'bg-yellow-600 hover:bg-yellow-700 text-white px-2 py-1 rounded text-xs transition-colors w-full'
                    }, 'Buy R1')
                ]),
                
                round >= 2 && React.createElement('div', { key: 'round2', className: 'text-xs' }, [
                    React.createElement('div', { key: 'desc', className: 'mb-1 text-yellow-800' }, 
                        `R2: ${round2Shop.effect.length > 20 ? round2Shop.effect.substring(0, 20) + '...' : round2Shop.effect}`),
                    React.createElement('button', {
                        key: 'btn',
                        onClick: () => handlePurchase(2),
                        className: 'bg-yellow-600 hover:bg-yellow-700 text-white px-2 py-1 rounded text-xs transition-colors w-full',
                        disabled: color === 'purple'
                    }, color === 'purple' ? 'TBD' : 'Buy R2')
                ])
            ]);
        }

        // Compact Shop Component
        function CompactShop({ color, round, label }) {
            const { state, dispatch } = useGame();
            
            const shopData = {
                red: {
                    1: { cost: { red: 1, any: 1 }, effect: 'Repeat action' },
                    2: { cost: { red: 2, any: 2 }, effect: 'Place next worker' },
                    3: { cost: { red: 3, any: 3 }, effect: 'Repeat all actions' }
                },
                yellow: {
                    1: { cost: { yellow: 1, any: 1 }, effect: 'Double gain' },
                    2: { cost: { yellow: 2, any: 2 }, effect: 'Gain 5+all 1' },
                    3: { cost: { yellow: 3, any: 3 }, effect: 'Gain 9+all 1' }
                },
                blue: {
                    1: { cost: { blue: 1, any: 1 }, effect: 'Close shop' },
                    2: { cost: { blue: 2, any: 2 }, effect: 'Flip all shops' },
                    3: { cost: { blue: 3, any: 3 }, effect: 'Any shop benefit' }
                },
                purple: {
                    1: { cost: { purple: 1, any: 1 }, effect: 'Extra turn' },
                    2: { cost: { purple: 2, any: 2 }, effect: 'Play 2 more' },
                    3: { cost: { purple: 3, any: 3 }, effect: 'Play all' }
                }
            };
            
            const shop = shopData[color][round];
            const shopId = `${color}${round}`;
            const isClosed = state.closedShops[shopId];
            const colorCost = shop.cost[color] || 0;
            const anyCost = Math.max(0, (shop.cost.any || 0) + state.shopCostModifier);
            
            const handlePurchase = async () => {
                if (isClosed) {
                    alert('This shop is closed!');
                    return;
                }
                
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                
                // Check resources
                if (currentPlayer.resources[color] < colorCost) {
                    alert(`Need ${colorCost} ${color} gems.`);
                    return;
                }
                
                const totalGems = Object.values(currentPlayer.resources).reduce((sum, amt) => sum + amt, 0);
                if (totalGems - colorCost < anyCost) {
                    alert(`Need ${anyCost} additional gems.`);
                    return;
                }
                
                // Simple cost deduction (full implementation in RegularShop)
                const resourceCost = {};
                resourceCost[color] = -colorCost;
                
                // Deduct any cost
                let remaining = anyCost;
                ['red', 'yellow', 'blue', 'purple'].forEach(c => {
                    if (remaining > 0 && c !== color) {
                        const available = currentPlayer.resources[c];
                        const take = Math.min(available, remaining);
                        if (take > 0) {
                            resourceCost[c] = (resourceCost[c] || 0) - take;
                            remaining -= take;
                        }
                    }
                });
                
                dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                
                // Execute shop effect
                await executeShopBenefit(color, round, currentPlayer, dispatch, state);
                
                // Blue automatic VP
                state.players.forEach(p => {
                    dispatch({ type: 'UPDATE_VP', playerId: p.id, vp: 1 });
                });
                dispatch({ type: 'ADD_LOG', message: 'All players: +1 VP (someone used a shop)' });
            };
            
            const getColorEmoji = () => {
                switch(color) {
                    case 'red': return '🔴';
                    case 'yellow': return '🟡';
                    case 'blue': return '🔵';
                    case 'purple': return '🟣';
                    default: return '📎';
                }
            };
            
            return React.createElement('div', { 
                className: `p-1 rounded ${isClosed ? 'bg-gray-200 opacity-50' : 'bg-white hover:bg-gray-50'} border transition-all` 
            }, [
                React.createElement('div', { key: 'header', className: 'flex items-center justify-between text-xs' }, [
                    React.createElement('span', { key: 'label', className: 'font-bold' }, label),
                    React.createElement('span', { key: 'cost' }, `${colorCost}${getColorEmoji()}+${anyCost}⚪`)
                ]),
                React.createElement('button', {
                    key: 'btn',
                    onClick: handlePurchase,
                    className: `w-full text-xs py-1 px-1 rounded mt-1 ${isClosed ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600 text-white'}`,
                    disabled: isClosed
                }, isClosed ? 'Closed' : shop.effect)
            ]);
        }
        
        // Compact Victory Shop Component
        function CompactVictoryShop({ color }) {
            const { state, dispatch } = useGame();
            
            const shopData = {
                red: { cost: 5, vp: 3 },
                yellow: { cost: 5, vp: 3 },
                blue: { cost: 5, vp: 3 },
                purple: { cost: 6, vp: 3 }
            };
            
            const shop = shopData[color];
            const shopId = `${color}vp`;
            const isClosed = state.closedShops[shopId];
            const actualCost = color === 'yellow' ? Math.max(0, shop.cost + state.shopCostModifier) : shop.cost;
            
            const handlePurchase = () => {
                if (isClosed) {
                    alert('This shop is closed!');
                    return;
                }
                
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                
                if (color === 'yellow') {
                    const totalGems = Object.values(currentPlayer.resources).reduce((sum, amt) => sum + amt, 0);
                    if (totalGems < actualCost) {
                        alert(`Need ${actualCost} gems total.`);
                        return;
                    }
                } else {
                    if (currentPlayer.resources[color] < actualCost) {
                        alert(`Need ${actualCost} ${color} gems.`);
                        return;
                    }
                }
                
                // Deduct cost (simplified)
                const resourceCost = {};
                if (color === 'yellow') {
                    let remaining = actualCost;
                    ['red', 'yellow', 'blue', 'purple'].forEach(c => {
                        const take = Math.min(currentPlayer.resources[c], remaining);
                        if (take > 0) {
                            resourceCost[c] = -take;
                            remaining -= take;
                        }
                    });
                } else {
                    resourceCost[color] = -actualCost;
                }
                
                dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                dispatch({ type: 'ADD_VICTORY_POINTS', playerId: currentPlayer.id, points: shop.vp });
                
                // Blue automatic VP
                state.players.forEach(p => {
                    dispatch({ type: 'UPDATE_VP', playerId: p.id, vp: 1 });
                });
                dispatch({ type: 'ADD_LOG', message: 'All players: +1 VP (someone used a shop)' });
            };
            
            const getColorEmoji = () => {
                switch(color) {
                    case 'red': return '🔴';
                    case 'yellow': return '🟡';
                    case 'blue': return '🔵';
                    case 'purple': return '🟣';
                    default: return '📎';
                }
            };
            
            return React.createElement('div', { 
                className: `p-1 rounded ${isClosed ? 'bg-gray-200 opacity-50' : 'bg-green-100 hover:bg-green-200'} border border-green-400 transition-all` 
            }, [
                React.createElement('div', { key: 'header', className: 'flex items-center justify-between text-xs' }, [
                    React.createElement('span', { key: 'label', className: 'font-bold text-green-700' }, 'VP'),
                    React.createElement('span', { key: 'cost' }, 
                        color === 'yellow' ? `${actualCost}⚪` : `${actualCost}${getColorEmoji()}`)
                ]),
                React.createElement('button', {
                    key: 'btn',
                    onClick: handlePurchase,
                    className: `w-full text-xs py-1 px-1 rounded mt-1 ${isClosed ? 'bg-gray-400 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700 text-white'}`,
                    disabled: isClosed
                }, isClosed ? 'Closed' : `${shop.vp} VP`)
            ]);
        }
        
        // Victory Shop Component
        function VictoryShop({ color }) {
            const { state, dispatch } = useGame();
            
            const shopData = {
                red: { cost: { red: 5 }, vp: 3 },
                yellow: { cost: { any: 5 }, vp: 3 },
                blue: { cost: { blue: 5 }, vp: 3 },
                purple: { cost: { purple: 6 }, vp: 3 }
            };
            
            const shopId = `${color}vp`;
            const isClosed = state.closedShops[shopId];
            
            const handlePurchase = () => {
                // Check if shop is closed
                if (isClosed) {
                    alert('This shop is closed!');
                    return;
                }
                
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                const shop = shopData[color];
                
                if (color === 'yellow') {
                    // Yellow VP shop costs 5 any gems (modified by shopCostModifier)
                    const baseCost = 5;
                    const actualCost = Math.max(0, baseCost + state.shopCostModifier);
                    const totalGems = Object.values(currentPlayer.resources).reduce((sum, count) => sum + count, 0);
                    
                    if (totalGems < actualCost) {
                        alert(`Need ${actualCost} gems of ⚪ color. You have ${totalGems}.`);
                        return;
                    }
                    
                    // Deduct gems proportionally
                    const resourceCost = {};
                    let remaining = actualCost;
                    const colors = ['red', 'yellow', 'blue', 'purple'];
                    
                    for (const color of colors) {
                        const take = Math.min(currentPlayer.resources[color], remaining);
                        if (take > 0) {
                            resourceCost[color] = -take; // Negative to subtract
                        }
                        remaining -= take;
                        if (remaining === 0) break;
                    }
                    
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                } else {
                    const requiredAmount = shop.cost[color];
                    if (currentPlayer.resources[color] < requiredAmount) {
                        alert(`Need ${requiredAmount} ${color} gems. You have ${currentPlayer.resources[color]}.`);
                        return;
                    }
                    
                    const resourceCost = {};
                    resourceCost[color] = -requiredAmount; // Negative to subtract
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                }
                
                dispatch({ type: 'ADD_VICTORY_POINTS', playerId: currentPlayer.id, points: shop.vp });
                console.log(`Player ${currentPlayer.id} bought 3 victory points from ${color} shop`);
                
                // BLUE AUTOMATIC VP: All players get 1 VP when any shop is used
                state.players.forEach(p => {
                    dispatch({
                        type: 'UPDATE_VP',
                        playerId: p.id,
                        vp: 1
                    });
                });
                dispatch({ type: 'ADD_LOG', message: 'All players: +1 VP (someone used a shop)' });
            };
            
            const shop = shopData[color];
            const actualCost = color === 'yellow' ? Math.max(0, 5 + state.shopCostModifier) : 5;
            
            return React.createElement('div', { 
                className: `bg-gradient-to-br from-green-100 to-green-200 border-2 ${isClosed ? 'border-red-400 opacity-60' : 'border-green-400'} rounded-lg p-3 shadow-md hover:shadow-lg transition-all` 
            }, [
                React.createElement('div', { key: 'title', className: 'text-center font-bold text-green-700 mb-2 text-sm' }, 
                    isClosed ? '🔒 Victory (Closed)' : '🏆 Victory'),
                React.createElement('div', { key: 'cost', className: 'text-center text-xs mb-2 text-green-800' }, 
                    React.createElement('strong', {}, 
                        `${color === 'yellow' ? `${actualCost} ⚪` : `${shop.cost[color]} ${color.charAt(0).toUpperCase() + color.slice(1)}`}: ${shop.vp} VP`)),
                React.createElement('div', { key: 'button', className: 'text-center' }, 
                    React.createElement('button', {
                        onClick: handlePurchase,
                        className: `${isClosed ? 'bg-gray-400 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'} text-white px-3 py-1 rounded text-xs font-bold shadow-md hover:shadow-lg transform hover:scale-105 transition-all`
                    }, isClosed ? 'Closed' : 'Buy'))
            ]);
        }

        // All available game layers
        const allGameLayers = {
            red: {
                title: "Worker Manipulation",
                icon: "🔴",
                actions: [
                    { id: 'gain3red', title: 'Gain 3 🔴', description: '', round: 1 },
                    { id: 'gain2red', title: 'Gain 2 🔴', description: '', round: 1 },
                    { id: 'redHybrid1', title: '+1 🔴 + Swap Workers', description: '(Both players get actions)', round: 1 },
                    { id: 'redRepeatAction', title: 'Repeat an Action', description: '(That one of your workers is on)', round: 1 },
                    { id: 'forceRedPlacement', title: 'Other Players Must Place on Red', description: '(Until red layer is full)', round: 2 },
                    { id: 'redHybrid2', title: '+1 🔴 + Swap Workers', description: '(Only you get action)', round: 2 },
                    { id: 'redRepeatAll', title: 'Repeat All Your Worker Actions', description: '(In any order you choose)', round: 3 }
                ]
            },
            yellow: {
                title: "Resource Manipulation", 
                icon: "🟡",
                actions: [
                    { id: 'gain3yellow', title: 'Gain 3 Different Gems', description: '', round: 1 },
                    { id: 'gain2yellow', title: 'Gain 2 Different Gems', description: '', round: 1 },
                    { id: 'steal2Gems', title: 'Steal 2 Gems', description: '', round: 1 },
                    { id: 'yellowHybrid1', title: '+1 🟡 + Trade ⚪ Number of Gems', description: '', round: 1 },
                    { id: 'steal3Gems', title: 'Steal 3 Gems', description: '', round: 2 },
                    { id: 'yellowHybrid2', title: '+1 🟡 + Double Next Gain', description: '(Doesn\'t stack with shop)', round: 2 },
                    { id: 'yellowSwapResources', title: 'Swap All Resources', description: '(Choose ⚪ player)', round: 3 }
                ]
            },
            blue: {
                title: "Shop Control",
                icon: "🔵", 
                actions: [
                    { id: 'gain3blue', title: 'Gain 3 🔵', description: '', round: 1 },
                    { id: 'gain2blue', title: 'Gain 2 🔵', description: '', round: 1 },
                    { id: 'blueR1ShopBenefit', title: 'Gain an R1 Shop Benefit', description: '(Even if closed)', round: 1 },
                    { id: 'blueReduceCosts', title: '+1 🔵 + Reduce All Shop Costs', description: '(By 1 ⚪ this round)', round: 1 },
                    { id: 'blueIncreaseCosts', title: '+2 🔵 + Increase All Shop Costs', description: '(By 1 ⚪ this round)', round: 2 },
                    { id: 'blueToggleShops', title: '+1 🔵 + Toggle All Shop Status', description: '(Including victory shops)', round: 2 },
                    { id: 'blueAnyShopBenefit', title: 'Gain Any Shop Benefit', description: '(Even if closed)', round: 3 }
                ]
            },
            purple: {
                title: "Timing/Order",
                icon: "🟣",
                actions: [
                    { id: 'gain4purpleSkip', title: 'Gain 4 🟣, Skip Next Turn', description: '', round: 1 },
                    { id: 'gain3purple', title: 'Gain 3 🟣', description: '', round: 1 },
                    { id: 'gain2purpleTakeBack', title: 'Gain 2 🟣, Take Back Worker', description: '(From different quad)', round: 1 },
                    { id: 'playTwoWorkers', title: 'Play 2 More Workers', description: '(This turn)', round: 1 },
                    { id: 'gain5purpleSkip', title: 'Gain 5 🟣, Skip Turn', description: '', round: 2 },
                    { id: 'playThreeWorkers', title: 'Play 3 More Workers', description: '(This turn)', round: 2 },
                    { id: 'gain4purpleWaitAll', title: 'Gain 4 🟣, Wait Then Play All', description: '(Skip until others out, then play all)', round: 3 }
                ]
            },
        };
        
        // Function to select random layers based on player count
        function selectGameLayers(playerCount) {
            const availableLayers = Object.keys(allGameLayers);
            const shuffled = [...availableLayers].sort(() => Math.random() - 0.5);
            const selectedLayerKeys = shuffled.slice(0, playerCount);
            
            const gameData = {};
            selectedLayerKeys.forEach(key => {
                gameData[key] = allGameLayers[key];
            });
            
            return gameData;
        }

        // Main Game Board Component
        function GameBoard() {
            const { state, dispatch } = useGame();
            
            // Sync state to Firebase whenever state changes
            useEffect(() => {
                if (state.roomCode && state.gameStarted) {
                    syncGameState(state.roomCode, {
                        currentPlayer: state.currentPlayer,
                        turnDirection: state.turnDirection,
                        players: state.players,
                        occupiedSpaces: state.occupiedSpaces,
                        round: state.round,
                        turnOrder: state.turnOrder,
                        workerPlacedThisTurn: state.workerPlacedThisTurn,
                        workersToPlace: state.workersToPlace,
                        actionLog: state.actionLog,
                        gameStarted: state.gameStarted,
                        gameLayers: state.gameLayers
                    });
                }
            }, [state.currentPlayer, state.players, state.occupiedSpaces, state.round, state.actionLog, state.workersToPlace, state.gameLayers]);
            
            const handleEndTurn = async () => {
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                
                if (state.workersToPlace > 0 && currentPlayer.workersLeft > 0) {
                    const workersRemaining = state.workersToPlace;
                    const confirmSkip = await showConfirm(dispatch, 
                        'End Turn Early?',
                        `You can still place ${workersRemaining} more worker${workersRemaining > 1 ? 's' : ''} this turn. Are you sure you want to end your turn?`
                    );
                    if (!confirmSkip) return;
                }
                
                dispatch({ type: 'END_TURN' });
            };
            
            const handleAdvanceRound = () => {
                if (state.round < 3) {
                    dispatch({ type: 'ADVANCE_ROUND' });
                } else {
                    alert('Game is already at Round 3 (final round)');
                }
            };
            
            const handleResetGame = () => {
                dispatch({ type: 'RESET_GAME' });
            };
            
            // If no layers selected yet, show loading or use default layers for local play
            if (!state.gameLayers) {
                console.log('No game layers found. State:', {
                    roomCode: state.roomCode,
                    gameStarted: state.gameStarted,
                    gameLayers: state.gameLayers
                });
                if (!state.roomCode) {
                    // Local play - use 4 layers
                    console.log('Local play - selecting 4 layers');
                    const selectedLayers = selectGameLayers(4);
                    dispatch({ type: 'SET_GAME_LAYERS', layers: selectedLayers });
                }
                return React.createElement('div', { 
                    className: 'min-h-screen flex items-center justify-center' 
                }, React.createElement('div', {
                    className: 'text-center glass rounded-xl p-8'
                }, [
                    React.createElement('h2', { key: 'title', className: 'text-2xl font-bold mb-4' }, 'Setting up game layers...'),
                    React.createElement('div', { key: 'spinner', className: 'animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto' }),
                    React.createElement('div', { key: 'debug', className: 'text-sm text-gray-600 mt-4' }, 
                        `Debug: roomCode=${state.roomCode}, gameStarted=${state.gameStarted}`)
                ]));
            }
            
            console.log('GameBoard rendering with layers:', Object.keys(state.gameLayers));

            const totalWorkers = state.players.reduce((sum, p) => sum + p.workersLeft, 0);
            const totalSpaces = Object.values(state.gameLayers).reduce((sum, layer) => 
                sum + layer.actions.filter(action => action.round <= state.round).length, 0
            );
            
            return React.createElement('div', { className: 'min-h-screen p-4' }, [
                React.createElement('div', { key: 'container', className: 'max-w-7xl mx-auto game-board' }, [
                    
                    // Player Cards
                    React.createElement('div', { key: 'players', className: 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8' }, 
                        state.players.map(player => 
                            React.createElement(PlayerCard, {
                                key: player.id,
                                player,
                                isCurrentPlayer: player.id === state.currentPlayer,
                                onEndTurn: handleEndTurn
                            })
                        )
                    ),
                    
                    // Game Layers - 2x2 Grid Layout
                    React.createElement('div', { key: 'layers', className: 'grid grid-cols-2 gap-6 mb-6' }, [
                        // Top row: Blue (left), Yellow (right)
                        React.createElement(GameLayer, {
                            key: 'blue',
                            color: 'blue',
                            title: state.gameLayers.blue.title,
                            icon: state.gameLayers.blue.icon,
                            actions: state.gameLayers.blue.actions,
                            round: state.round
                        }),
                        React.createElement(GameLayer, {
                            key: 'yellow',
                            color: 'yellow',
                            title: state.gameLayers.yellow.title,
                            icon: state.gameLayers.yellow.icon,
                            actions: state.gameLayers.yellow.actions,
                            round: state.round
                        }),
                        // Bottom row: Red (left), Purple (right)
                        React.createElement(GameLayer, {
                            key: 'red',
                            color: 'red',
                            title: state.gameLayers.red.title,
                            icon: state.gameLayers.red.icon,
                            actions: state.gameLayers.red.actions,
                            round: state.round
                        }),
                        React.createElement(GameLayer, {
                            key: 'purple',
                            color: 'purple',
                            title: state.gameLayers.purple.title,
                            icon: state.gameLayers.purple.icon,
                            actions: state.gameLayers.purple.actions,
                            round: state.round
                        })
                    ]),
                    
                    // Control Buttons
                    React.createElement('div', { key: 'controls', className: 'text-center glass rounded-lg p-4 shadow-lg' }, [
                        React.createElement('button', {
                            key: 'advance',
                            onClick: handleAdvanceRound,
                            className: 'bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold py-2 px-4 rounded-lg mr-3 shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                        }, `Advance to Round ${Math.min(state.round + 1, 3)}`),
                        React.createElement('button', {
                            key: 'reset',
                            onClick: handleResetGame,
                            className: 'bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                        }, 'Reset Game'),
                        React.createElement('div', { key: 'instructions', className: 'text-gray-600 mt-3 text-sm' }, 
                            'Place worker → Buy from shops → End turn (button under current player)'),
                        state.actionLog.length > 0 && React.createElement('div', { key: 'action-log', className: 'mt-4 p-3 bg-gray-100 rounded-lg max-h-32 overflow-y-auto' }, [
                            React.createElement('div', { key: 'log-title', className: 'font-bold text-gray-700 mb-2 text-sm' }, 'Action Log (Last 10):'),
                            ...state.actionLog.map((log, index) => 
                                React.createElement('div', { 
                                    key: index, 
                                    className: 'text-xs text-gray-600 mb-1 font-mono' 
                                }, log)
                            )
                        ])
                    ])
                ]),
                // Modal System
                state.modal && React.createElement(Modal, { 
                    key: 'modal', 
                    isOpen: true, 
                    onClose: () => dispatch({ type: 'HIDE_MODAL' }) 
                }, state.modal.type === 'choice' 
                    ? React.createElement(ChoiceModal, state.modal)
                    : React.createElement(ConfirmModal, state.modal)
                )
            ]);
        }

        // Main App Component
        function App() {
            return React.createElement(GameProvider, {}, 
                React.createElement(MainApp, {})
            );
        }
        
        function MainApp() {
            const { state } = useGame();
            
            // Add error boundary
            try {
                // Show room lobby if not in a game
                if (!state.gameStarted) {
                    // If connected to a room but game hasn't started, show waiting room
                    if (state.roomCode) {
                        return React.createElement('div', { className: 'min-h-screen p-4' }, [
                            React.createElement(ConnectedPlayers, { key: 'players' }),
                            React.createElement('div', { 
                                key: 'waiting',
                                className: 'text-center mt-8' 
                            }, [
                                React.createElement('div', {
                                    key: 'spinner',
                                    className: 'animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4'
                                }),
                                React.createElement('h2', {
                                    key: 'text',
                                    className: 'text-xl text-gray-600'
                                }, state.isHost ? 'Waiting for you to start the game...' : 'Waiting for host to start the game...')
                            ])
                        ]);
                    }
                    
                    // Show room lobby for initial connection
                    return React.createElement(RoomLobby, {});
                }
                
                // Show game board with multiplayer info if in a room
                return React.createElement('div', { className: 'min-h-screen' }, [
                    state.roomCode && React.createElement(ConnectedPlayers, { key: 'players' }),
                    React.createElement(GameBoard, { key: 'game' })
                ]);
            } catch (error) {
                console.error('Render error:', error);
                console.error('Error stack:', error.stack);
                console.error('Game state at error:', state);
                return React.createElement('div', { 
                    className: 'min-h-screen flex items-center justify-center p-4' 
                }, React.createElement('div', {
                    className: 'glass rounded-xl p-8 text-center'
                }, [
                    React.createElement('h1', { 
                        key: 'title',
                        className: 'text-2xl font-bold text-red-600 mb-4' 
                    }, 'Game Error'),
                    React.createElement('p', { 
                        key: 'message',
                        className: 'text-gray-600 mb-4' 
                    }, 'Something went wrong. Check browser console for details.'),
                    React.createElement('div', {
                        key: 'error-details',
                        className: 'text-sm text-gray-500 mb-4 p-2 bg-gray-100 rounded'
                    }, `Error: ${error.message}`),
                    React.createElement('button', {
                        key: 'reload',
                        onClick: () => window.location.reload(),
                        className: 'bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded'
                    }, 'Reload Game')
                ]));
            }
        }

        // Render the app
        ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
</body>
</html>
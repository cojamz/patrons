<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patrons - React Version</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            scroll-behavior: smooth;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
        }
        
        html {
            scroll-behavior: smooth;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
        }
        
        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }
        
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(156, 163, 175, 0.5);
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(156, 163, 175, 0.8);
        }
        
        /* Improve rendering performance */
        .game-board {
            -webkit-transform: translateZ(0);
            -moz-transform: translateZ(0);
            -ms-transform: translateZ(0);
            -o-transform: translateZ(0);
            transform: translateZ(0);
            will-change: transform;
        }
        
        /* Smoother transitions for all interactive elements */
        button, .action-space, .player-card {
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        /* Better momentum scrolling for iOS */
        @supports (-webkit-overflow-scrolling: touch) {
            body {
                -webkit-overflow-scrolling: touch;
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
            }
        }
        
        /* Reduce animation conflicts during scrolling */
        @media (prefers-reduced-motion: no-preference) {
            .action-space:hover {
                transition: all 0.15s ease-out;
            }
            
            button:hover {
                transition: all 0.15s ease-out;
            }
        }
        
        /* For users who prefer reduced motion */
        @media (prefers-reduced-motion: reduce) {
            html {
                scroll-behavior: auto;
            }
            
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        .player-1 { background: #8e44ad !important; }
        .player-2 { background: #27ae60 !important; }
        .player-3 { background: #e67e22 !important; }
        .player-4 { background: #2c3e50 !important; }
        
        @keyframes pulse-blue {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
        }
        
        .pulse-current {
            animation: pulse-blue 2s infinite;
        }
        
        .glass {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-100 via-purple-100 to-pink-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useContext, createContext, useReducer, useEffect } = React;
        
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB0c0iUOG3llUzLd9FhQ6Qc1qCB0DoajVw",
            authDomain: "cornycolonies.firebaseapp.com",
            databaseURL: "https://cornycolonies-default-rtdb.firebaseio.com",
            projectId: "cornycolonies",
            storageBucket: "cornycolonies.firebasestorage.app",
            messagingSenderId: "566795956627",
            appId: "1:566795956627:web:585b66a3277696f3b0b866"
        };
        
        // Initialize Firebase (will use demo mode for now)
        let database = null;
        try {
            if (typeof firebase !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                database = firebase.database();
            }
        } catch (error) {
            console.log('Firebase not available, using local mode');
        }

        // Game Context
        const GameContext = createContext();

        const initialState = {
            // Game state
            currentPlayer: 1,
            turnDirection: 1,
            players: [
                { id: 1, name: "Player 1", resources: { red: 0, yellow: 0, blue: 0, purple: 0 }, workersLeft: 4, effects: [], victoryPoints: 0 },
                { id: 2, name: "Player 2", resources: { red: 0, yellow: 0, blue: 0, purple: 0 }, workersLeft: 4, effects: [], victoryPoints: 0 },
                { id: 3, name: "Player 3", resources: { red: 0, yellow: 0, blue: 0, purple: 0 }, workersLeft: 4, effects: [], victoryPoints: 0 },
                { id: 4, name: "Player 4", resources: { red: 0, yellow: 0, blue: 0, purple: 0 }, workersLeft: 4, effects: [], victoryPoints: 0 }
            ],
            occupiedSpaces: {},
            round: 1,
            turnOrder: [1, 2, 3, 4],
            workerPlacedThisTurn: false,
            workersToPlace: 1,
            modal: null,
            actionLog: [],
            gameLayers: null, // Will be set when game starts
            
            // Multiplayer state
            roomCode: null,
            myPlayerId: null,
            myPlayerName: '',
            connectedPlayers: {},
            isHost: false,
            gameStarted: false,
            connectionStatus: 'disconnected' // 'disconnected', 'connecting', 'connected'
        };

        function gameReducer(state, action) {
            switch (action.type) {
                case 'PLACE_WORKER':
                    const newWorkersToPlace = Math.max(0, state.workersToPlace - 1);
                    return {
                        ...state,
                        occupiedSpaces: {
                            ...state.occupiedSpaces,
                            [action.actionId]: state.currentPlayer
                        },
                        players: state.players.map(player => 
                            player.id === state.currentPlayer 
                                ? { ...player, workersLeft: player.workersLeft - 1 }
                                : player
                        ),
                        workerPlacedThisTurn: true,
                        workersToPlace: newWorkersToPlace
                    };
                
                case 'UPDATE_RESOURCES':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { 
                                    ...player, 
                                    resources: {
                                        red: player.resources.red + (action.resources.red || 0),
                                        yellow: player.resources.yellow + (action.resources.yellow || 0),
                                        blue: player.resources.blue + (action.resources.blue || 0),
                                        purple: player.resources.purple + (action.resources.purple || 0)
                                    }
                                }
                                : player
                        )
                    };
                
                case 'ADD_VICTORY_POINTS':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, victoryPoints: player.victoryPoints + action.points }
                                : player
                        )
                    };
                
                case 'ADD_EFFECT':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, effects: [...(player.effects || []), action.effect] }
                                : player
                        )
                    };
                
                case 'UPDATE_PLAYER_EFFECTS':
                    return {
                        ...state,
                        players: state.players.map(player => 
                            player.id === action.playerId 
                                ? { ...player, effects: action.effects }
                                : player
                        )
                    };
                
                case 'SET_WORKERS_TO_PLACE':
                    return {
                        ...state,
                        workersToPlace: action.count,
                        workerPlacedThisTurn: false
                    };
                
                case 'END_TURN':
                    const currentPlayerObj = state.players.find(p => p.id === state.currentPlayer);
                    const hasExtraTurn = currentPlayerObj.effects.some(effect => 
                        effect.includes('Will take an extra turn after this one')
                    );
                    
                    if (hasExtraTurn) {
                        // Remove the extra turn effect and stay on the same player
                        return {
                            ...state,
                            players: state.players.map(player => 
                                player.id === state.currentPlayer 
                                    ? { 
                                        ...player, 
                                        effects: (player.effects || []).filter(effect => 
                                            !effect.includes('Will take an extra turn after this one')
                                        )
                                    }
                                    : player
                            ),
                            workerPlacedThisTurn: false,
                            workersToPlace: 1,
                            actionLog: [...state.actionLog.slice(-9), `Player ${state.currentPlayer}: Taking extra turn!`]
                        };
                    }
                    
                    // Normal turn progression
                    const currentIndex = state.turnOrder.indexOf(state.currentPlayer);
                    let nextPlayer;
                    let nextDirection = state.turnDirection;
                    
                    if (state.turnDirection === 1) {
                        if (currentIndex === state.turnOrder.length - 1) {
                            nextDirection = -1;
                            nextPlayer = state.currentPlayer;
                        } else {
                            nextPlayer = state.turnOrder[currentIndex + 1];
                        }
                    } else {
                        if (currentIndex === 0) {
                            nextDirection = 1;
                            nextPlayer = state.currentPlayer;
                        } else {
                            nextPlayer = state.turnOrder[currentIndex - 1];
                        }
                    }
                    
                    return {
                        ...state,
                        currentPlayer: nextPlayer,
                        turnDirection: nextDirection,
                        workerPlacedThisTurn: false,
                        workersToPlace: 1
                    };
                
                case 'ADVANCE_ROUND':
                    return {
                        ...state,
                        round: state.round + 1,
                        players: state.players.map(player => {
                            const baseWorkers = 3 + (state.round + 1);
                            const hasExtraWorkers = (player.effects || []).some(effect => 
                                effect.includes('Will get 2 extra workers next round')
                            );
                            const extraWorkers = hasExtraWorkers ? 2 : 0;
                            
                            return {
                                ...player,
                                workersLeft: baseWorkers + extraWorkers,
                                effects: (player.effects || []).filter(effect => 
                                    !effect.includes('Will get 2 extra workers next round')
                                )
                            };
                        }),
                        occupiedSpaces: {},
                        currentPlayer: 1,
                        turnDirection: 1,
                        workerPlacedThisTurn: false,
                        workersToPlace: 1,
                        actionLog: [...state.actionLog.slice(-9), `Round ${state.round + 1} started! Extra workers applied.`]
                    };
                
                case 'ADD_LOG':
                    return {
                        ...state,
                        actionLog: [...state.actionLog.slice(-9), action.message] // Keep last 10 messages
                    };
                
                case 'RESET_GAME':
                    return initialState;
                
                case 'SHOW_MODAL':
                    return {
                        ...state,
                        modal: action.modal
                    };
                
                case 'HIDE_MODAL':
                    return {
                        ...state,
                        modal: null
                    };
                
                case 'UPDATE_OCCUPIED_SPACES':
                    return {
                        ...state,
                        occupiedSpaces: action.occupiedSpaces
                    };
                
                case 'SET_TURN_ORDER':
                    return {
                        ...state,
                        turnOrder: action.turnOrder
                    };
                
                // Multiplayer actions
                case 'SET_ROOM_INFO':
                    return {
                        ...state,
                        roomCode: action.roomCode,
                        isHost: action.isHost
                    };
                
                case 'SET_MY_PLAYER_INFO':
                    return {
                        ...state,
                        myPlayerId: action.playerId,
                        myPlayerName: action.playerName
                    };
                
                case 'UPDATE_CONNECTED_PLAYERS':
                    return {
                        ...state,
                        connectedPlayers: action.connectedPlayers
                    };
                
                case 'START_GAME':
                    return {
                        ...state,
                        gameStarted: true
                    };
                
                case 'SET_GAME_LAYERS':
                    return {
                        ...state,
                        gameLayers: action.layers
                    };
                
                case 'UPDATE_CONNECTION_STATUS':
                    return {
                        ...state,
                        connectionStatus: action.status
                    };
                
                case 'SYNC_GAME_STATE':
                    // Merge remote game state while preserving local multiplayer state
                    return {
                        ...state,
                        ...action.gameState,
                        // Ensure all players have effects array
                        players: action.gameState.players ? action.gameState.players.map(player => ({
                            ...player,
                            effects: player.effects || [],
                            resources: {
                                red: 0, yellow: 0, blue: 0, purple: 0,
                                ...(player.resources || {})
                            }
                        })) : state.players,
                        roomCode: state.roomCode,
                        myPlayerId: state.myPlayerId,
                        myPlayerName: state.myPlayerName,
                        connectedPlayers: state.connectedPlayers,
                        isHost: state.isHost,
                        gameStarted: action.gameState.gameStarted !== undefined ? action.gameState.gameStarted : state.gameStarted,
                        connectionStatus: state.connectionStatus,
                        // Sync game layers if provided
                        gameLayers: action.gameState.gameLayers || state.gameLayers
                    };
                
                default:
                    return state;
            }
        }

        function GameProvider({ children }) {
            const [state, dispatch] = useReducer(gameReducer, initialState);
            
            return React.createElement(GameContext.Provider, { value: { state, dispatch } }, children);
        }

        function useGame() {
            const context = useContext(GameContext);
            if (!context) {
                throw new Error('useGame must be used within a GameProvider');
            }
            return context;
        }
        
        // Multiplayer Functions
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }
        
        function createRoom(dispatch, playerName) {
            const roomCode = generateRoomCode();
            const playerId = 1; // Host is always player 1
            
            if (database) {
                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connecting' });
                
                const roomRef = database.ref(`rooms/${roomCode}`);
                
                // Add timeout to prevent infinite loading
                const timeout = setTimeout(() => {
                    console.error('Room creation timeout');
                    alert('Failed to create room - connection timeout. Please try local mode or set up Firebase.');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                }, 5000); // 5 second timeout
                
                roomRef.set({
                    host: playerId,
                    gameState: {
                        ...initialState,
                        gameStarted: false
                    },
                    players: {
                        [playerId]: {
                            id: playerId,
                            name: playerName,
                            connected: true,
                            joinedAt: Date.now()
                        }
                    }
                }).then(() => {
                    clearTimeout(timeout);
                    dispatch({ type: 'SET_ROOM_INFO', roomCode, isHost: true });
                    dispatch({ type: 'SET_MY_PLAYER_INFO', playerId, playerName });
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connected' });
                    
                    // Listen for player updates
                    setupRoomListeners(roomCode, dispatch, playerId);
                }).catch(error => {
                    clearTimeout(timeout);
                    console.error('Error creating room:', error);
                    alert('Failed to create room. Firebase is not properly configured. Please use local mode for now.');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                });
            } else {
                alert('Multiplayer requires Firebase setup. Please use local mode for now.');
                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
            }
        }
        
        function joinRoom(dispatch, roomCode, playerName) {
            if (database) {
                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connecting' });
                
                // Add timeout to prevent infinite loading
                const timeout = setTimeout(() => {
                    console.error('Room join timeout');
                    alert('Failed to join room - connection timeout. Please try local mode or check the room code.');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                }, 5000); // 5 second timeout
                
                const roomRef = database.ref(`rooms/${roomCode}`);
                roomRef.once('value').then(snapshot => {
                    clearTimeout(timeout);
                    if (snapshot.exists()) {
                        const roomData = snapshot.val();
                        const players = roomData.players || {};
                        
                        // Find available player slot (1-4)
                        let playerId = null;
                        for (let i = 1; i <= 4; i++) {
                            if (!players[i] || !players[i].connected) {
                                playerId = i;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            // Join the room
                            roomRef.child(`players/${playerId}`).set({
                                id: playerId,
                                name: playerName,
                                connected: true,
                                joinedAt: Date.now()
                            }).then(() => {
                                dispatch({ type: 'SET_ROOM_INFO', roomCode, isHost: false });
                                dispatch({ type: 'SET_MY_PLAYER_INFO', playerId, playerName });
                                dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'connected' });
                                
                                // Load current game state
                                if (roomData.gameState) {
                                    dispatch({ type: 'SYNC_GAME_STATE', gameState: roomData.gameState });
                                }
                                
                                // Listen for updates
                                setupRoomListeners(roomCode, dispatch, playerId);
                            });
                        } else {
                            alert('Room is full (4 players max)');
                            dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                        }
                    } else {
                        alert('Room not found');
                        dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                    }
                }).catch(error => {
                    console.error('Error joining room:', error);
                    alert('Failed to join room');
                    dispatch({ type: 'UPDATE_CONNECTION_STATUS', status: 'disconnected' });
                });
            } else {
                alert('Firebase not available. Using local mode.');
            }
        }
        
        function setupRoomListeners(roomCode, dispatch, myPlayerId) {
            if (!database) return;
            
            const roomRef = database.ref(`rooms/${roomCode}`);
            
            // Listen for player changes
            roomRef.child('players').on('value', snapshot => {
                const players = snapshot.val() || {};
                dispatch({ type: 'UPDATE_CONNECTED_PLAYERS', connectedPlayers: players });
                
                // Check if host disconnected and transfer host status
                const connectedPlayers = Object.values(players).filter(p => p.connected);
                const currentHost = connectedPlayers.find(p => p.id === 1);
                
                if (!currentHost && connectedPlayers.length > 0) {
                    // Original host (player 1) disconnected, make lowest ID the new host
                    const newHost = connectedPlayers.reduce((lowest, player) => 
                        player.id < lowest.id ? player : lowest
                    );
                    
                    if (newHost.id === myPlayerId) {
                        // I become the new host
                        dispatch({ type: 'SET_ROOM_INFO', roomCode: roomCode, isHost: true });
                        console.log(`Player ${myPlayerId} is now the host`);
                    }
                }
            });
            
            // Listen for game state changes
            roomRef.child('gameState').on('value', snapshot => {
                const gameState = snapshot.val();
                if (gameState) {
                    dispatch({ type: 'SYNC_GAME_STATE', gameState });
                }
            });
            
            // Handle disconnection
            roomRef.child(`players/${myPlayerId}/connected`).onDisconnect().set(false);
        }
        
        function syncGameState(roomCode, gameState) {
            if (database && roomCode) {
                database.ref(`rooms/${roomCode}/gameState`).set(gameState);
            }
        }
        
        function startMultiplayerGame(roomCode) {
            if (database && roomCode) {
                // Get current connected players and initialize proper game state
                database.ref(`rooms/${roomCode}/players`).once('value', (snapshot) => {
                    const connectedPlayers = snapshot.val() || {};
                    const playerCount = Object.keys(connectedPlayers).length;
                    
                    // Create proper player objects with all required fields
                    const players = [];
                    Object.values(connectedPlayers).forEach((player, index) => {
                        players.push({
                            id: player.id,
                            name: player.name,
                            resources: { red: 0, yellow: 0, blue: 0, purple: 0 },
                            workersLeft: 4,
                            effects: [],
                            victoryPoints: 0
                        });
                    });
                    
                    // Initialize complete game state
                    const gameState = {
                        currentPlayer: 1,
                        turnDirection: 1,
                        players: players,
                        occupiedSpaces: {},
                        round: 1,
                        turnOrder: players.map(p => p.id),
                        workerPlacedThisTurn: false,
                        workersToPlace: 1,
                        actionLog: [],
                        gameStarted: true
                    };
                    
                    database.ref(`rooms/${roomCode}/gameState`).set(gameState);
                });
            }
        }

        // Room Lobby Component
        function RoomLobby() {
            const { state, dispatch } = useGame();
            const [playerName, setPlayerName] = useState('');
            const [roomCodeInput, setRoomCodeInput] = useState('');
            const [mode, setMode] = useState('menu'); // 'menu', 'create', 'join'
            
            const handleCreateRoom = () => {
                if (!playerName.trim()) {
                    alert('Please enter your name');
                    return;
                }
                createRoom(dispatch, playerName.trim());
            };
            
            const handleJoinRoom = () => {
                if (!playerName.trim()) {
                    alert('Please enter your name');
                    return;
                }
                if (!roomCodeInput.trim()) {
                    alert('Please enter room code');
                    return;
                }
                joinRoom(dispatch, roomCodeInput.trim().toUpperCase(), playerName.trim());
            };
            
            const handlePlayLocal = () => {
                // For local play, use 4 players
                const selectedLayers = selectGameLayers(4);
                dispatch({ type: 'SET_GAME_LAYERS', layers: selectedLayers });
                dispatch({ type: 'START_GAME' });
            };
            
            return React.createElement('div', { 
                className: 'min-h-screen flex items-center justify-center p-4'
            }, React.createElement('div', {
                className: 'glass rounded-xl shadow-2xl p-8 max-w-md w-full'
            }, [
                React.createElement('div', { key: 'header', className: 'text-center mb-8' }, [
                    React.createElement('h1', { 
                        key: 'title',
                        className: 'text-3xl font-bold text-gray-800 mb-2' 
                    }, 'Patrons'),
                    React.createElement('p', { 
                        key: 'subtitle',
                        className: 'text-gray-600' 
                    }, 'Choose your game mode')
                ]),
                
                mode === 'menu' && React.createElement('div', { key: 'menu', className: 'space-y-4' }, [
                    React.createElement('input', {
                        key: 'name',
                        type: 'text',
                        placeholder: 'Enter your name',
                        value: playerName,
                        onChange: (e) => setPlayerName(e.target.value),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent'
                    }),
                    React.createElement('button', {
                        key: 'create',
                        onClick: () => setMode('create'),
                        className: 'w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, 'ðŸŽ® Create Online Game'),
                    React.createElement('button', {
                        key: 'join',
                        onClick: () => setMode('join'),
                        className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, 'ðŸšª Join Online Game'),
                    React.createElement('button', {
                        key: 'local',
                        onClick: handlePlayLocal,
                        className: 'w-full bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, 'ðŸ’» Play Local (Same Device)')
                ]),
                
                mode === 'create' && React.createElement('div', { key: 'create', className: 'space-y-4' }, [
                    React.createElement('h3', { 
                        key: 'title',
                        className: 'text-xl font-bold text-center mb-4' 
                    }, 'Create Room'),
                    React.createElement('input', {
                        key: 'name',
                        type: 'text',
                        placeholder: 'Enter your name',
                        value: playerName,
                        onChange: (e) => setPlayerName(e.target.value),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent'
                    }),
                    React.createElement('button', {
                        key: 'create',
                        onClick: handleCreateRoom,
                        disabled: state.connectionStatus === 'connecting',
                        className: 'w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200 disabled:transform-none'
                    }, state.connectionStatus === 'connecting' ? 'Creating...' : 'Create Room'),
                    React.createElement('button', {
                        key: 'back',
                        onClick: () => setMode('menu'),
                        className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Back')
                ]),
                
                mode === 'join' && React.createElement('div', { key: 'join', className: 'space-y-4' }, [
                    React.createElement('h3', { 
                        key: 'title',
                        className: 'text-xl font-bold text-center mb-4' 
                    }, 'Join Room'),
                    React.createElement('input', {
                        key: 'name',
                        type: 'text',
                        placeholder: 'Enter your name',
                        value: playerName,
                        onChange: (e) => setPlayerName(e.target.value),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent'
                    }),
                    React.createElement('input', {
                        key: 'code',
                        type: 'text',
                        placeholder: 'Enter room code',
                        value: roomCodeInput,
                        onChange: (e) => setRoomCodeInput(e.target.value.toUpperCase()),
                        className: 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent'
                    }),
                    React.createElement('button', {
                        key: 'join',
                        onClick: handleJoinRoom,
                        disabled: state.connectionStatus === 'connecting',
                        className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200 disabled:transform-none'
                    }, state.connectionStatus === 'connecting' ? 'Joining...' : 'Join Room'),
                    React.createElement('button', {
                        key: 'back',
                        onClick: () => setMode('menu'),
                        className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Back')
                ])
            ]));
        }
        
        // Connected Players Component
        function ConnectedPlayers() {
            const { state, dispatch } = useGame();
            const connectedCount = Object.keys(state.connectedPlayers).length;
            
            const handleStartGame = () => {
                if (connectedCount >= 2) {
                    console.log('Starting game with', connectedCount, 'players');
                    // Select layers based on actual connected player count
                    const selectedLayers = selectGameLayers(connectedCount);
                    console.log('Selected layers:', Object.keys(selectedLayers));
                    dispatch({ type: 'SET_GAME_LAYERS', layers: selectedLayers });
                    startMultiplayerGame(state.roomCode);
                    dispatch({ type: 'START_GAME' });
                    console.log('Game started successfully');
                } else {
                    alert('Need at least 2 players to start');
                }
            };
            
            const handleLeaveRoom = () => {
                if (confirm('Are you sure you want to leave the room?')) {
                    window.location.reload();
                }
            };
            
            return React.createElement('div', {
                className: 'glass rounded-lg p-4 mb-6'
            }, [
                React.createElement('div', { key: 'header', className: 'flex justify-between items-center mb-4' }, [
                    React.createElement('div', { key: 'info' }, [
                        React.createElement('h3', { 
                            key: 'title',
                            className: 'text-lg font-bold text-gray-800' 
                        }, `Room: ${state.roomCode}`),
                        React.createElement('p', { 
                            key: 'count',
                            className: 'text-sm text-gray-600' 
                        }, `${connectedCount}/4 players connected`)
                    ]),
                    React.createElement('button', {
                        key: 'leave',
                        onClick: handleLeaveRoom,
                        className: 'bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm'
                    }, 'Leave')
                ]),
                React.createElement('div', { key: 'players', className: 'grid grid-cols-2 gap-2 mb-4' }, 
                    Object.values(state.connectedPlayers).map(player => 
                        React.createElement('div', {
                            key: player.id,
                            className: `p-2 rounded border-2 ${player.connected ? 'border-green-400 bg-green-50' : 'border-gray-300 bg-gray-50'} ${player.id === state.myPlayerId ? 'ring-2 ring-blue-400' : ''}`
                        }, [
                            React.createElement('div', { 
                                key: 'name',
                                className: 'font-semibold' 
                            }, `Player ${player.id}: ${player.name}`),
                            React.createElement('div', { 
                                key: 'status',
                                className: `text-xs ${player.connected ? 'text-green-600' : 'text-gray-500'}` 
                            }, player.connected ? 'ðŸŸ¢ Connected' : 'ðŸ”´ Disconnected'),
                            player.id === state.myPlayerId && React.createElement('div', { 
                                key: 'you',
                                className: 'text-xs text-blue-600 font-bold' 
                            }, '(You)')
                        ])
                    )
                ),
                state.isHost && !state.gameStarted && React.createElement('button', {
                    key: 'start',
                    onClick: handleStartGame,
                    disabled: connectedCount < 2,
                    className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200'
                }, connectedCount >= 2 ? 'Start Game' : 'Need 2+ Players to Start')
            ]);
        }

        // Action Space Component
        function ActionSpace({ actionId, title, description, round, available = true }) {
            const { state, dispatch } = useGame();
            const isOccupied = state.occupiedSpaces[actionId];
            const occupyingPlayer = isOccupied ? state.players.find(p => p.id === isOccupied) : null;
            
            const handleClick = async () => {
                if (isOccupied || !available) return;
                
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                if (currentPlayer.workersLeft <= 0) return;
                
                if (state.workersToPlace <= 0) {
                    alert('You have already placed all your workers this turn. End your turn or buy from shops.');
                    return;
                }
                
                dispatch({ type: 'PLACE_WORKER', actionId });
                
                // Get fresh state after worker placement for repeat actions
                const freshState = { ...state, occupiedSpaces: { ...state.occupiedSpaces, [actionId]: state.currentPlayer } };
                await executeAction(actionId, currentPlayer, dispatch, freshState, state.gameLayers);
                
                const message = `Action completed: ${actionId} for Player ${currentPlayer.id}`;
                dispatch({ type: 'ADD_LOG', message });
                console.log(message);
            };
            
            const getRoundStyle = () => {
                if (round === 1) return 'bg-gray-100 border-gray-300';
                if (round === 2) return 'bg-green-100 border-green-500';
                if (round === 3) return 'bg-yellow-100 border-yellow-500';
                return 'bg-gray-100 border-gray-300';
            };
            
            const getAvailabilityStyle = () => {
                if (!available) return 'opacity-50';
                if (isOccupied) return 'bg-red-100 border-red-400 cursor-not-allowed';
                return 'hover:bg-blue-50 hover:border-blue-400 cursor-pointer transform hover:scale-105';
            };
            
            return React.createElement('div', {
                className: `relative p-2 border-2 rounded-lg min-h-16 flex flex-col justify-center text-center transition-all duration-200 ${getRoundStyle()} ${getAvailabilityStyle()}`,
                onClick: handleClick
            }, [
                React.createElement('div', { key: 'title', className: 'font-bold text-xs mb-1' }, title),
                React.createElement('div', { key: 'desc', className: 'text-xs text-gray-500 leading-tight' }, description),
                occupyingPlayer && React.createElement('div', {
                    key: 'worker',
                    className: `absolute top-1 right-1 w-6 h-6 rounded-full flex items-center justify-center text-white text-xs font-bold player-${occupyingPlayer.id}`
                }, occupyingPlayer.id),
                React.createElement('div', { key: 'round', className: 'absolute bottom-1 right-1 text-xs text-gray-500' }, `R${round}`)
            ]);
        }

        // Simplified action execution
        async function executeAction(actionId, player, dispatch, currentState, gameLayers) {
            const basicGains = {
                'gain3red': { red: 3 },
                'gain2red': { red: 2 },
                'gain3blue': { blue: 3 },
                'gain2blue': { blue: 2 },
                'gain3yellow': { yellow: 3 },
                'gain2yellow': { yellow: 2 },
                'gain3purple': { purple: 3 },
                'gain2purple': { purple: 2 }
            };
            
            if (basicGains[actionId]) {
                let resources = { ...basicGains[actionId] };
                
                // Check for doubling effect
                const hasDoubleEffect = (player.effects || []).some(effect => effect.includes('Next gain will be doubled'));
                if (hasDoubleEffect) {
                    // Double all gains
                    Object.keys(resources).forEach(color => {
                        resources[color] *= 2;
                    });
                    
                    // Remove the doubling effect after use
                    dispatch({
                        type: 'UPDATE_PLAYER_EFFECTS',
                        playerId: player.id,
                        effects: (player.effects || []).filter(effect => !effect.includes('Next gain will be doubled'))
                    });
                    
                    const message = `Player ${player.id}: ${actionId} â†’ +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')} (DOUBLED!)`;
                    dispatch({ type: 'ADD_LOG', message });
                } else {
                    const message = `Player ${player.id}: ${actionId} â†’ +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: resources
                });
                return;
            }
            
            // Yellow layer actions with player choice
            if (actionId === 'gain3yellow') {
                const colors = ['red', 'yellow', 'blue', 'purple'];
                const choices = [];
                
                for (let i = 0; i < 3; i++) {
                    const availableColors = colors.filter(c => !choices.includes(c));
                    const colorOptions = availableColors.map(color => ({
                        label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                        value: color
                    }));
                    
                    const choice = await showChoice(dispatch, 
                        `Choose color ${i + 1}/3 for different colored gems`, 
                        colorOptions
                    );
                    
                    if (choice) {
                        choices.push(choice);
                    } else {
                        // If cancelled, use first available
                        choices.push(availableColors[0]);
                    }
                }
                
                const resources = {};
                choices.forEach(color => {
                    resources[color] = (resources[color] || 0) + 1;
                });
                
                // Check for doubling effect
                const hasDoubleEffect = (player.effects || []).some(effect => effect.includes('Next gain will be doubled'));
                if (hasDoubleEffect) {
                    // Double all gains
                    Object.keys(resources).forEach(color => {
                        resources[color] *= 2;
                    });
                    
                    // Remove the doubling effect after use
                    dispatch({
                        type: 'UPDATE_PLAYER_EFFECTS',
                        playerId: player.id,
                        effects: (player.effects || []).filter(effect => !effect.includes('Next gain will be doubled'))
                    });
                    
                    const message = `Player ${player.id}: ${actionId} â†’ +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')} (DOUBLED!)`;
                    dispatch({ type: 'ADD_LOG', message });
                } else {
                    const message = `Player ${player.id}: ${actionId} â†’ +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources
                });
                return;
            }
            
            // Similar implementation for gain2yellow
            if (actionId === 'gain2yellow') {
                const colors = ['red', 'yellow', 'blue', 'purple'];
                const choices = [];
                
                for (let i = 0; i < 2; i++) {
                    const availableColors = colors.filter(c => !choices.includes(c));
                    const colorOptions = availableColors.map(color => ({
                        label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                        value: color
                    }));
                    
                    const choice = await showChoice(dispatch, 
                        `Choose color ${i + 1}/2 for different colored gems`, 
                        colorOptions
                    );
                    
                    if (choice) {
                        choices.push(choice);
                    } else {
                        choices.push(availableColors[0]);
                    }
                }
                
                const resources = {};
                choices.forEach(color => {
                    resources[color] = (resources[color] || 0) + 1;
                });
                
                // Check for doubling effect
                const hasDoubleEffect = (player.effects || []).some(effect => effect.includes('Next gain will be doubled'));
                if (hasDoubleEffect) {
                    // Double all gains
                    Object.keys(resources).forEach(color => {
                        resources[color] *= 2;
                    });
                    
                    // Remove the doubling effect after use
                    dispatch({
                        type: 'UPDATE_PLAYER_EFFECTS',
                        playerId: player.id,
                        effects: (player.effects || []).filter(effect => !effect.includes('Next gain will be doubled'))
                    });
                    
                    const message = `Player ${player.id}: ${actionId} â†’ +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')} (DOUBLED!)`;
                    dispatch({ type: 'ADD_LOG', message });
                } else {
                    const message = `Player ${player.id}: ${actionId} â†’ +${Object.entries(resources).map(([color, amount]) => `${amount} ${color}`).join(', ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources
                });
                return;
            }
            
            // Purple layer - Play two workers (immediately)
            if (actionId === 'playTwoWorkers') {
                // Set the player to be able to place 2 more workers this turn
                dispatch({
                    type: 'SET_WORKERS_TO_PLACE',
                    count: 2
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Playing 2 workers this turn'
                });
                
                const message = `Player ${player.id}: playTwoWorkers â†’ Can place 2 more workers this turn`;
                dispatch({ type: 'ADD_LOG', message });
                console.log(message);
                return;
            }
            
            // Purple layer - Extra workers next round
            if (actionId === 'extraWorkers') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 1 }
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Will get 2 extra workers next round'
                });
                
                console.log(`Player ${player.id} will get 2 extra workers next round`);
                return;
            }
            
            // Purple layer - Any Round 1 Shop Benefit
            if (actionId === 'purpleShopHybrid') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 1 }
                });
                
                const shopOptions = [
                    { label: 'Red R1: Repeat a worker\'s action', value: 'red1' },
                    { label: 'Yellow R1: Double next gain', value: 'yellow1' },
                    { label: 'Blue R1: Close any shop this round', value: 'blue1' },
                    { label: 'Purple R1: Take an extra turn after this one', value: 'purple1' }
                ];
                
                const choice = await showChoice(dispatch, 
                    'Choose any Round 1 shop benefit', 
                    shopOptions
                );
                
                if (choice) {
                    switch(choice) {
                        case 'red1':
                            // Execute repeat action immediately
                            await executeRepeatAction(player, dispatch, currentState, gameLayers);
                            break;
                        case 'yellow1':
                            dispatch({
                                type: 'ADD_EFFECT',
                                playerId: player.id,
                                effect: 'Next gain will be doubled'
                            });
                            break;
                        case 'blue1':
                            dispatch({
                                type: 'ADD_EFFECT',
                                playerId: player.id,
                                effect: 'Can close any shop this round'
                            });
                            break;
                        case 'purple1':
                            dispatch({
                                type: 'ADD_EFFECT',
                                playerId: player.id,
                                effect: 'Will take an extra turn after this one'
                            });
                            break;
                    }
                    
                    const effectNames = {
                        'red1': 'Repeat worker action',
                        'yellow1': 'Double next gain',
                        'blue1': 'Close shop ability',
                        'purple1': 'Extra turn'
                    };
                    
                    const message = `Player ${player.id}: purpleShopHybrid â†’ +1 purple + ${effectNames[choice]}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                return;
            }
            
            // Purple layer - Choose turn order
            if (actionId === 'purpleHybrid2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { purple: 1 }
                });
                
                const orderOptions = [
                    { label: '1 â†’ 2 â†’ 3 â†’ 4', value: [1, 2, 3, 4] },
                    { label: '4 â†’ 3 â†’ 2 â†’ 1', value: [4, 3, 2, 1] },
                    { label: '2 â†’ 1 â†’ 4 â†’ 3', value: [2, 1, 4, 3] },
                    { label: '3 â†’ 4 â†’ 1 â†’ 2', value: [3, 4, 1, 2] }
                ];
                
                const newOrder = await showChoice(dispatch, 
                    'Choose new turn order for next round', 
                    orderOptions
                );
                
                if (newOrder) {
                    // Apply the turn order change immediately for next round
                    dispatch({
                        type: 'SET_TURN_ORDER',
                        turnOrder: newOrder
                    });
                    
                    const message = `Player ${player.id}: purpleHybrid2 â†’ +1 purple + set turn order to ${newOrder.join(' â†’ ')}`;
                    dispatch({ type: 'ADD_LOG', message });
                }
                return;
            }
            
            // Red layer - Repeat an action
            if (actionId === 'redRepeatAction') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { red: 1 }
                });
                
                const logMessage = `DEBUG: Occupied spaces: ${JSON.stringify(currentState.occupiedSpaces)}`;
                dispatch({ type: 'ADD_LOG', message: logMessage });
                
                // Find all occupied spaces that belong to the current player (excluding this repeat action)
                const playerSpaces = Object.entries(currentState.occupiedSpaces)
                    .filter(([spaceId, playerId]) => playerId === player.id && spaceId !== 'redRepeatAction')
                    .map(([spaceId]) => spaceId);
                
                const debugMessage = `DEBUG: Player spaces to repeat: ${playerSpaces.join(', ')}`;
                dispatch({ type: 'ADD_LOG', message: debugMessage });
                
                if (playerSpaces.length === 0) {
                    const message = `Player ${player.id}: redRepeatAction â†’ +1 red (no other workers to repeat)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                if (playerSpaces.length === 1) {
                    // Only one option, auto-select it
                    const spaceId = playerSpaces[0];
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    
                    const message = `Player ${player.id}: redRepeatAction â†’ +1 red + repeating ${actionTitle}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    // Execute the action again
                    await executeAction(spaceId, player, dispatch, currentState, gameLayers);
                    return;
                }
                
                // Multiple options, let player choose
                const repeatOptions = playerSpaces.map(spaceId => {
                    // Find the action details
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    return {
                        label: `Repeat: ${actionTitle}`,
                        value: spaceId
                    };
                });
                
                const choice = await showChoice(dispatch, 
                    'Choose an action to repeat', 
                    repeatOptions
                );
                
                if (choice) {
                    const message = `Player ${player.id}: redRepeatAction â†’ +1 red + repeating ${choice}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    // Execute the chosen action again
                    await executeAction(choice, player, dispatch, currentState, gameLayers);
                }
                return;
            }
            
            // RED LAYER ACTIONS
            
            // Red hybrid actions - swap workers
            if (actionId === 'redHybrid1' || actionId === 'redHybrid2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { red: 1 }
                });
                
                // Find workers that can be swapped
                const allWorkers = Object.entries(currentState.occupiedSpaces);
                if (allWorkers.length < 2) {
                    const message = `Player ${player.id}: ${actionId} â†’ +1 red (not enough workers to swap)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                const workerOptions = allWorkers.map(([spaceId, playerId]) => ({
                    label: `Player ${playerId}'s worker on ${spaceId}`,
                    value: { spaceId, playerId }
                }));
                
                const worker1 = await showChoice(dispatch, 'Choose first worker to swap', workerOptions);
                if (!worker1) return;
                
                const remainingWorkers = workerOptions.filter(w => 
                    !(w.value.spaceId === worker1.spaceId && w.value.playerId === worker1.playerId)
                );
                
                const worker2 = await showChoice(dispatch, 'Choose second worker to swap', remainingWorkers);
                if (!worker2) return;
                
                // Perform the swap
                const newOccupiedSpaces = { ...currentState.occupiedSpaces };
                newOccupiedSpaces[worker1.spaceId] = worker2.playerId;
                newOccupiedSpaces[worker2.spaceId] = worker1.playerId;
                
                dispatch({
                    type: 'UPDATE_OCCUPIED_SPACES',
                    occupiedSpaces: newOccupiedSpaces
                });
                
                // Execute actions for the affected players
                if (actionId === 'redHybrid1') {
                    // Both players get actions
                    await executeAction(worker1.spaceId, currentState.players.find(p => p.id === worker2.playerId), dispatch, currentState, gameLayers);
                    await executeAction(worker2.spaceId, currentState.players.find(p => p.id === worker1.playerId), dispatch, currentState, gameLayers);
                } else {
                    // Only current player gets actions
                    await executeAction(worker1.spaceId, player, dispatch, currentState, gameLayers);
                    await executeAction(worker2.spaceId, player, dispatch, currentState, gameLayers);
                }
                
                const message = `Player ${player.id}: ${actionId} â†’ +1 red + swapped workers`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Force red placement
            if (actionId === 'forceRedPlacement') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { red: 1 }
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Other players must place on red layer until full'
                });
                
                const message = `Player ${player.id}: forceRedPlacement â†’ +1 red + forcing red placement`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // YELLOW LAYER ACTIONS
            
            // Steal gem actions
            if (actionId === 'stealGem' || actionId === 'steal2Gems') {
                const stealCount = actionId === 'stealGem' ? 1 : 2;
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                
                if (otherPlayers.length === 0) {
                    const message = `Player ${player.id}: ${actionId} â†’ No other players to steal from`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                for (let i = 0; i < stealCount; i++) {
                    const targetOptions = otherPlayers
                        .filter(p => Object.values(p.resources).some(amount => amount > 0))
                        .map(p => ({
                            label: `Player ${p.id} (${Object.entries(p.resources).filter(([,amt]) => amt > 0).map(([color, amt]) => `${amt} ${color}`).join(', ')})`,
                            value: p.id
                        }));
                    
                    if (targetOptions.length === 0) break;
                    
                    const targetId = await showChoice(dispatch, `Choose player to steal from (${i + 1}/${stealCount})`, targetOptions);
                    if (!targetId) break;
                    
                    const targetPlayer = otherPlayers.find(p => p.id === targetId);
                    const availableColors = Object.entries(targetPlayer.resources)
                        .filter(([, amount]) => amount > 0)
                        .map(([color]) => ({
                            label: `${color.charAt(0).toUpperCase() + color.slice(1)} (${targetPlayer.resources[color]} available)`,
                            value: color
                        }));
                    
                    const colorToSteal = await showChoice(dispatch, `Choose color to steal from Player ${targetId}`, availableColors);
                    if (!colorToSteal) break;
                    
                    // Transfer the gem
                    dispatch({
                        type: 'UPDATE_RESOURCES',
                        playerId: targetId,
                        resources: { [colorToSteal]: -1 }
                    });
                    
                    dispatch({
                        type: 'UPDATE_RESOURCES',
                        playerId: player.id,
                        resources: { [colorToSteal]: 1 }
                    });
                }
                
                const message = `Player ${player.id}: ${actionId} â†’ Stole ${stealCount} gem(s)`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Yellow hybrid actions
            if (actionId === 'yellowHybrid1') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { yellow: 1 }
                });
                
                // Trade 2 gems for 2 any colors
                const playerColors = Object.entries(player.resources).filter(([, amount]) => amount > 0);
                if (playerColors.length < 2) {
                    const message = `Player ${player.id}: yellowHybrid1 â†’ +1 yellow (not enough gems to trade)`;
                    dispatch({ type: 'ADD_LOG', message });
                    return;
                }
                
                // Choose 2 gems to trade away
                const tradeCost = {};
                for (let i = 0; i < 2; i++) {
                    const availableColors = Object.entries(player.resources)
                        .filter(([color, amount]) => amount + (tradeCost[color] || 0) > 0)
                        .map(([color, amount]) => ({
                            label: `${color.charAt(0).toUpperCase() + color.slice(1)} (${amount + (tradeCost[color] || 0)} available)`,
                            value: color
                        }));
                    
                    const colorToTrade = await showChoice(dispatch, `Choose color to trade away (${i + 1}/2)`, availableColors);
                    if (colorToTrade) {
                        tradeCost[colorToTrade] = (tradeCost[colorToTrade] || 0) - 1;
                    }
                }
                
                // Choose 2 gems to gain
                const colors = ['red', 'yellow', 'blue', 'purple'];
                const tradeGain = {};
                for (let i = 0; i < 2; i++) {
                    const colorOptions = colors.map(color => ({
                        label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                        value: color
                    }));
                    
                    const colorToGain = await showChoice(dispatch, `Choose color to gain (${i + 1}/2)`, colorOptions);
                    if (colorToGain) {
                        tradeGain[colorToGain] = (tradeGain[colorToGain] || 0) + 1;
                    }
                }
                
                // Apply the trade
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { ...tradeCost, ...tradeGain }
                });
                
                const message = `Player ${player.id}: yellowHybrid1 â†’ +1 yellow + traded gems`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (actionId === 'yellowHybrid2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { yellow: 1 }
                });
                
                dispatch({
                    type: 'ADD_EFFECT',
                    playerId: player.id,
                    effect: 'Next gain will be doubled'
                });
                
                const message = `Player ${player.id}: yellowHybrid2 â†’ +1 yellow + next gain doubled`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // BLUE LAYER ACTIONS
            
            // Blue hybrid actions - move workers
            if (actionId === 'blueHybrid1' || actionId === 'blueHybrid2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { blue: 1 }
                });
                
                const moveCount = actionId === 'blueHybrid1' ? 1 : 2;
                const allWorkers = Object.entries(currentState.occupiedSpaces);
                
                for (let i = 0; i < moveCount; i++) {
                    if (allWorkers.length === 0) break;
                    
                    const workerOptions = allWorkers.map(([spaceId, playerId]) => ({
                        label: `Player ${playerId}'s worker on ${spaceId}`,
                        value: { spaceId, playerId }
                    }));
                    
                    const workerToMove = await showChoice(dispatch, `Choose worker to move (${i + 1}/${moveCount})`, workerOptions);
                    if (!workerToMove) break;
                    
                    // Get available spaces
                    const occupiedSpaces = Object.keys(currentState.occupiedSpaces);
                    const availableSpaces = [];
                    
                    for (const layerData of Object.values(gameLayers)) {
                        for (const action of layerData.actions) {
                            if (action.round <= currentState.round && !occupiedSpaces.includes(action.id)) {
                                availableSpaces.push({
                                    label: action.title,
                                    value: action.id
                                });
                            }
                        }
                    }
                    
                    const newSpace = await showChoice(dispatch, 'Choose new space for worker', availableSpaces);
                    if (!newSpace) break;
                    
                    // Move the worker
                    const newOccupiedSpaces = { ...currentState.occupiedSpaces };
                    delete newOccupiedSpaces[workerToMove.spaceId];
                    newOccupiedSpaces[newSpace] = workerToMove.playerId;
                    
                    dispatch({
                        type: 'UPDATE_OCCUPIED_SPACES',
                        occupiedSpaces: newOccupiedSpaces
                    });
                    
                    // Note: They don't get the benefit of the new space
                }
                
                const message = `Player ${player.id}: ${actionId} â†’ +1 blue + moved ${moveCount} worker(s)`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            // Everyone return gems
            if (actionId === 'everyoneReturn1' || actionId === 'everyoneReturn2') {
                dispatch({
                    type: 'UPDATE_RESOURCES',
                    playerId: player.id,
                    resources: { blue: 1 }
                });
                
                const returnCount = actionId === 'everyoneReturn1' ? 1 : 2;
                const otherPlayers = currentState.players.filter(p => p.id !== player.id);
                
                for (const otherPlayer of otherPlayers) {
                    for (let i = 0; i < returnCount; i++) {
                        const availableColors = Object.entries(otherPlayer.resources)
                            .filter(([, amount]) => amount > 0)
                            .map(([color, amount]) => ({
                                label: `${color.charAt(0).toUpperCase() + color.slice(1)} (${amount} available)`,
                                value: color
                            }));
                        
                        if (availableColors.length === 0) break;
                        
                        const colorToReturn = await showChoice(dispatch, 
                            `Player ${otherPlayer.id}: Choose gem to return (${i + 1}/${returnCount})`, 
                            availableColors
                        );
                        
                        if (colorToReturn) {
                            dispatch({
                                type: 'UPDATE_RESOURCES',
                                playerId: otherPlayer.id,
                                resources: { [colorToReturn]: -1 }
                            });
                        }
                    }
                }
                
                const message = `Player ${player.id}: ${actionId} â†’ +1 blue + others returned ${returnCount} gem(s)`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            console.log(`Player ${player.id} executed action: ${actionId}`);
        }

        // Custom Modal Components
        function Modal({ isOpen, onClose, children }) {
            if (!isOpen) return null;
            
            return React.createElement('div', {
                className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
                onClick: onClose
            }, React.createElement('div', {
                className: 'glass rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl',
                onClick: (e) => e.stopPropagation()
            }, children));
        }

        function ChoiceModal({ title, options, onSelect, onCancel }) {
            const { dispatch } = useGame();
            
            const handleSelect = (option) => {
                dispatch({ type: 'HIDE_MODAL' });
                onSelect(option);
            };
            
            const handleCancel = () => {
                dispatch({ type: 'HIDE_MODAL' });
                if (onCancel) onCancel();
            };
            
            return React.createElement('div', { className: 'text-center' }, [
                React.createElement('h3', { 
                    key: 'title', 
                    className: 'text-xl font-bold text-gray-800 mb-4' 
                }, title),
                React.createElement('div', { 
                    key: 'options', 
                    className: 'space-y-2 mb-6' 
                }, options.map((option, index) => 
                    React.createElement('button', {
                        key: index,
                        onClick: () => handleSelect(option.value || option),
                        className: 'w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                    }, option.label || option)
                )),
                React.createElement('button', {
                    key: 'cancel',
                    onClick: handleCancel,
                    className: 'w-full bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                }, 'Cancel')
            ]);
        }

        function ConfirmModal({ title, message, onConfirm, onCancel }) {
            const { dispatch } = useGame();
            
            const handleConfirm = () => {
                dispatch({ type: 'HIDE_MODAL' });
                onConfirm();
            };
            
            const handleCancel = () => {
                dispatch({ type: 'HIDE_MODAL' });
                if (onCancel) onCancel();
            };
            
            return React.createElement('div', { className: 'text-center' }, [
                React.createElement('h3', { 
                    key: 'title', 
                    className: 'text-xl font-bold text-gray-800 mb-2' 
                }, title),
                React.createElement('p', { 
                    key: 'message', 
                    className: 'text-gray-600 mb-6' 
                }, message),
                React.createElement('div', { 
                    key: 'buttons', 
                    className: 'flex gap-3' 
                }, [
                    React.createElement('button', {
                        key: 'cancel',
                        onClick: handleCancel,
                        className: 'flex-1 bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Cancel'),
                    React.createElement('button', {
                        key: 'confirm',
                        onClick: handleConfirm,
                        className: 'flex-1 bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200'
                    }, 'Confirm')
                ])
            ]);
        }

        // Helper functions for custom prompts
        function showChoice(dispatch, title, options) {
            return new Promise((resolve) => {
                dispatch({
                    type: 'SHOW_MODAL',
                    modal: {
                        type: 'choice',
                        title,
                        options,
                        onSelect: resolve,
                        onCancel: () => resolve(null)
                    }
                });
            });
        }

        function showConfirm(dispatch, title, message) {
            return new Promise((resolve) => {
                dispatch({
                    type: 'SHOW_MODAL',
                    modal: {
                        type: 'confirm',
                        title,
                        message,
                        onConfirm: () => resolve(true),
                        onCancel: () => resolve(false)
                    }
                });
            });
        }

        // End Turn Button Component
        function EndTurnButton({ onEndTurn }) {
            return React.createElement('div', { className: 'mt-3 text-center' }, 
                React.createElement('button', {
                    onClick: onEndTurn,
                    className: 'w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200'
                }, 'End Turn')
            );
        }

        // Execute repeat action from red shop
        async function executeRepeatAction(player, dispatch, state, gameLayers) {
            const playerSpaces = Object.entries(state.occupiedSpaces)
                .filter(([spaceId, pid]) => pid === player.id)
                .map(([spaceId]) => spaceId);
            
            if (playerSpaces.length === 0) {
                const message = `Player ${player.id}: Red shop â†’ No workers to repeat`;
                dispatch({ type: 'ADD_LOG', message });
                return;
            }
            
            if (playerSpaces.length === 1) {
                // Auto-select the only option
                const spaceId = playerSpaces[0];
                let actionTitle = spaceId;
                for (const layerData of Object.values(gameLayers)) {
                    const action = layerData.actions.find(a => a.id === spaceId);
                    if (action) {
                        actionTitle = action.title;
                        break;
                    }
                }
                
                const message = `Player ${player.id}: Red shop â†’ Repeating ${actionTitle}`;
                dispatch({ type: 'ADD_LOG', message });
                
                await executeAction(spaceId, player, dispatch, state, gameLayers);
            } else {
                // Multiple options, let player choose
                const repeatOptions = playerSpaces.map(spaceId => {
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    return {
                        label: `Repeat: ${actionTitle}`,
                        value: spaceId
                    };
                });
                
                const choice = await showChoice(dispatch, 
                    'Choose an action to repeat', 
                    repeatOptions
                );
                
                if (choice) {
                    const message = `Player ${player.id}: Red shop â†’ Repeating ${choice}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    await executeAction(choice, player, dispatch, state, gameLayers);
                }
            }
        }

        // Execute yellow 2 shop effect
        async function executeYellow2Shop(player, dispatch, state) {
            // Gain 4 gems any colors
            const colors = ['red', 'yellow', 'blue', 'purple'];
            const choices = [];
            
            for (let i = 0; i < 4; i++) {
                const colorOptions = colors.map(color => ({
                    label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                    value: color
                }));
                
                const choice = await showChoice(dispatch, 
                    `Choose color ${i + 1}/4 for any colored gems`, 
                    colorOptions
                );
                
                if (choice) {
                    choices.push(choice);
                } else {
                    choices.push(colors[0]); // Default to first color if cancelled
                }
            }
            
            const resources = {};
            choices.forEach(color => {
                resources[color] = (resources[color] || 0) + 1;
            });
            
            dispatch({
                type: 'UPDATE_RESOURCES',
                playerId: player.id,
                resources
            });
            
            // Everyone else gains 1 gem of their choice
            for (const otherPlayer of state.players) {
                if (otherPlayer.id !== player.id) {
                    const colorChoice = await showChoice(dispatch, 
                        `Player ${otherPlayer.id}: Choose a gem color to gain`, 
                        colors.map(color => ({
                            label: `${color.charAt(0).toUpperCase() + color.slice(1)} Gem`,
                            value: color
                        }))
                    );
                    
                    if (colorChoice) {
                        dispatch({
                            type: 'UPDATE_RESOURCES',
                            playerId: otherPlayer.id,
                            resources: { [colorChoice]: 1 }
                        });
                    }
                }
            }
            
            const message = `Player ${player.id}: Yellow R2 shop â†’ Gained 4 gems, everyone gained 1 gem`;
            dispatch({ type: 'ADD_LOG', message });
        }

        // Effect activation function
        async function activateEffect(effect, playerId, effectIndex, dispatch, state) {
            const player = state.players.find(p => p.id === playerId);
            
            if (effect.includes('Can repeat a worker\'s action')) {
                // Find all occupied spaces that belong to the player
                const playerSpaces = Object.entries(state.occupiedSpaces)
                    .filter(([spaceId, pid]) => pid === playerId)
                    .map(([spaceId]) => spaceId);
                
                if (playerSpaces.length === 0) {
                    alert('No workers to repeat!');
                    return;
                }
                
                if (playerSpaces.length === 1) {
                    // Auto-select the only option
                    const spaceId = playerSpaces[0];
                    let actionTitle = spaceId;
                    for (const layerData of Object.values(gameLayers)) {
                        const action = layerData.actions.find(a => a.id === spaceId);
                        if (action) {
                            actionTitle = action.title;
                            break;
                        }
                    }
                    
                    const message = `Player ${playerId}: Used shop effect to repeat ${actionTitle}`;
                    dispatch({ type: 'ADD_LOG', message });
                    
                    // Execute the action again
                    await executeAction(spaceId, player, dispatch, state, gameLayers);
                } else {
                    // Multiple options, let player choose
                    const repeatOptions = playerSpaces.map(spaceId => {
                        let actionTitle = spaceId;
                        for (const layerData of Object.values(gameLayers)) {
                            const action = layerData.actions.find(a => a.id === spaceId);
                            if (action) {
                                actionTitle = action.title;
                                break;
                            }
                        }
                        return {
                            label: `Repeat: ${actionTitle}`,
                            value: spaceId
                        };
                    });
                    
                    const choice = await showChoice(dispatch, 
                        'Choose an action to repeat', 
                        repeatOptions
                    );
                    
                    if (choice) {
                        const message = `Player ${playerId}: Used shop effect to repeat ${choice}`;
                        dispatch({ type: 'ADD_LOG', message });
                        
                        // Execute the chosen action again
                        await executeAction(choice, player, dispatch, state, gameLayers);
                    }
                }
                
                // Remove the effect after use
                dispatch({
                    type: 'UPDATE_PLAYER_EFFECTS',
                    playerId: playerId,
                    effects: (player.effects || []).filter((_, i) => i !== effectIndex)
                });
                
            } else if (effect.includes('Can close any shop this round')) {
                // Choose which shop to close
                const shopOptions = [
                    { label: 'Red Shop', value: 'red' },
                    { label: 'Yellow Shop', value: 'yellow' },
                    { label: 'Blue Shop', value: 'blue' },
                    { label: 'Purple Shop', value: 'purple' }
                ];
                
                const shopToClose = await showChoice(dispatch, 'Choose shop to close this round', shopOptions);
                if (shopToClose) {
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: playerId,
                        effect: `${shopToClose.charAt(0).toUpperCase() + shopToClose.slice(1)} shop is closed this round`
                    });
                    
                    dispatch({ type: 'ADD_LOG', message: `Player ${playerId}: Closed ${shopToClose} shop for this round` });
                }
                
                // Remove the activatable effect
                dispatch({
                    type: 'UPDATE_PLAYER_EFFECTS',
                    playerId: playerId,
                    effects: (player.effects || []).filter((_, i) => i !== effectIndex)
                });
                
            } else if (effect.includes('Will take an extra turn after this one')) {
                // Check if player is already at the end of snake (would get 2 turns naturally)
                const currentIndex = state.turnOrder.indexOf(state.currentPlayer);
                const isAtSnakeEnd = (state.turnDirection === 1 && currentIndex === state.turnOrder.length - 1) ||
                                   (state.turnDirection === -1 && currentIndex === 0);
                
                if (isAtSnakeEnd) {
                    alert('You are already at the end of the turn snake and will get another turn naturally. Extra turn effect not needed.');
                } else {
                    // Apply extra turn effect
                    dispatch({
                        type: 'ADD_EFFECT',
                        playerId: state.currentPlayer,
                        effect: 'Will take an extra turn after this one'
                    });
                    
                    dispatch({ type: 'ADD_LOG', message: `Player ${state.currentPlayer}: Will take an extra turn after this one` });
                }
                
                // Remove the activatable effect regardless
                dispatch({
                    type: 'UPDATE_PLAYER_EFFECTS',
                    playerId: playerId,
                    effects: (player.effects || []).filter((_, i) => i !== effectIndex)
                });
                
            } else if (effect.includes('Can place the next player\'s worker')) {
                alert('Place next player\'s worker effect not implemented yet');
            } else if (effect.includes('Can undo the last player\'s turn')) {
                alert('Undo turn effect not implemented yet');
            }
        }

        // Get effect button for activatable effects
        function getEffectButton(effect, playerId, effectIndex) {
            const { state, dispatch } = useGame();
            
            const activatableEffects = [
                'Can repeat a worker\'s action',
                'Can close any shop this round',
                'Will take an extra turn after this one',
                'Can place the next player\'s worker',
                'Can undo the last player\'s turn'
            ];
            
            const isActivatable = activatableEffects.some(ae => effect.includes(ae));
            const isCurrentPlayer = state.currentPlayer === playerId;
            
            if (isActivatable && isCurrentPlayer) {
                return React.createElement('button', {
                    key: 'activate',
                    onClick: () => activateEffect(effect, playerId, effectIndex, dispatch, state),
                    className: 'bg-blue-500 hover:bg-blue-600 text-white text-xs px-2 py-1 rounded ml-2'
                }, 'Use');
            }
            
            return null;
        }

        // Player Card Component
        function PlayerCard({ player, isCurrentPlayer, onEndTurn }) {
            const { state } = useGame();
            
            // Get active colors from current game layers
            const activeColors = state.gameLayers ? Object.keys(state.gameLayers) : ['red', 'yellow', 'blue', 'purple'];
            
            const getPlayerStyle = () => {
                let baseStyle = "glass rounded-lg shadow-lg p-4 transition-all duration-300";
                if (isCurrentPlayer) {
                    baseStyle += " ring-4 ring-blue-400 ring-opacity-60 shadow-xl transform scale-105 pulse-current";
                }
                return baseStyle;
            };
            
            const getResourceIcon = (color, amount) => {
                const colors = {
                    red: 'bg-red-500',
                    yellow: 'bg-yellow-500', 
                    blue: 'bg-blue-500',
                    purple: 'bg-purple-500',
                };
                
                const gemIcons = {
                    red: 'ðŸ”´',
                    yellow: 'ðŸŸ¡', 
                    blue: 'ðŸ”µ',
                    purple: 'ðŸŸ£'
                };
                
                const gemIcon = gemIcons[color] || 'ðŸ’Ž';
                
                return React.createElement('div', {
                    key: color,
                    className: `w-12 h-12 rounded-lg ${colors[color]} flex flex-col items-center justify-center text-white font-bold text-sm shadow-lg hover:shadow-xl transform hover:scale-110 transition-all`
                }, [
                    React.createElement('div', { key: 'icon', className: 'text-lg' }, gemIcon),
                    React.createElement('div', { key: 'amount', className: 'text-xs' }, amount)
                ]);
            };
            
            return React.createElement('div', { className: getPlayerStyle() }, [
                React.createElement('div', { key: 'header', className: 'flex items-center justify-between mb-4' }, [
                    React.createElement('h3', { key: 'name', className: 'font-bold text-lg text-gray-800' }, [
                        player.name,
                        isCurrentPlayer && React.createElement('span', { key: 'indicator', className: 'text-blue-500 ml-2' }, 'ðŸŽ¯')
                    ]),
                    React.createElement('div', { key: 'vp', className: 'text-2xl font-bold text-blue-600 bg-blue-100 px-3 py-1 rounded-lg' }, `${player.victoryPoints} VP`)
                ]),
                React.createElement('div', { key: 'resources', className: 'flex gap-3 mb-4 justify-center' }, 
                    activeColors.map(color => 
                        getResourceIcon(color, player.resources[color] || 0)
                    )
                ),
                React.createElement('div', { key: 'workers', className: 'text-center text-gray-700 font-semibold mb-3' }, 
                    `Workers left: ${player.workersLeft}`),
                (player.effects && player.effects.length > 0) && React.createElement('div', { key: 'effects', className: 'mb-3' }, [
                    React.createElement('div', { key: 'label', className: 'text-xs font-semibold text-gray-600 mb-1' }, 'Effects:'),
                    ...(player.effects || []).map((effect, index) => 
                        React.createElement('div', { 
                            key: `effect-${index}`, 
                            className: 'bg-yellow-100 border border-yellow-300 rounded px-2 py-1 mb-1 text-xs flex justify-between items-center' 
                        }, [
                            React.createElement('span', { key: 'text' }, effect),
                            getEffectButton(effect, player.id, index)
                        ])
                    )
                ]),
                isCurrentPlayer && React.createElement(EndTurnButton, { key: 'end-turn', onEndTurn })
            ]);
        }

        // Game Layer Component  
        function GameLayer({ color, title, icon, actions, round }) {
            const getLayerStyle = () => {
                const baseStyle = "glass rounded-lg shadow-lg p-4 border-l-6 hover:shadow-xl transition-all duration-300";
                switch (color) {
                    case 'red': return `${baseStyle} border-l-red-500`;
                    case 'yellow': return `${baseStyle} border-l-yellow-500`;
                    case 'blue': return `${baseStyle} border-l-blue-500`;
                    case 'purple': return `${baseStyle} border-l-purple-500`;
                    default: return `${baseStyle} border-l-gray-500`;
                }
            };
            
            const getIconColor = () => {
                switch (color) {
                    case 'red': return 'text-red-500';
                    case 'yellow': return 'text-yellow-500';
                    case 'blue': return 'text-blue-500';
                    case 'purple': return 'text-purple-500';
                    default: return 'text-gray-500';
                }
            };
            
            const availableActions = actions.filter(action => action.round <= round);
            
            return React.createElement('div', { className: getLayerStyle() }, [
                React.createElement('div', { key: 'header', className: 'flex justify-between items-center mb-3' }, [
                    React.createElement('h2', { key: 'title', className: `text-xl font-bold ${getIconColor()}` }, 
                        `${icon} ${title}`),
                    React.createElement('span', { key: 'round', className: 'text-gray-600 text-sm bg-white px-2 py-1 rounded shadow' }, 
                        `R${round} (${availableActions.length})`)
                ]),
                React.createElement('div', { key: 'content', className: 'flex gap-4' }, [
                    React.createElement('div', { key: 'actions', className: 'flex-1 grid grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-2' }, 
                        availableActions.map(action => 
                            React.createElement(ActionSpace, {
                                key: action.id,
                                actionId: action.id,
                                title: action.title,
                                description: action.description,
                                round: action.round,
                                available: action.round <= round
                            })
                        )
                    ),
                    React.createElement('div', { key: 'shop-container', className: 'w-48 space-y-2' }, [
                        React.createElement(RegularShop, { key: 'regular-shop', color, round }),
                        React.createElement(VictoryShop, { key: 'victory-shop', color }),
                        round < 3 && React.createElement('div', { 
                            key: 'preview', 
                            className: 'p-2 bg-gradient-to-r from-yellow-100 to-yellow-200 border border-yellow-300 rounded text-center text-xs' 
                        }, React.createElement('strong', { className: 'text-yellow-800' }, 
                            `R${round + 1}: +${round === 1 ? '2' : '1'} spaces`))
                    ])
                ])
            ]);
        }

        // Regular Shop Component
        function RegularShop({ color, round }) {
            const { state, dispatch } = useGame();
            
            const shopData = {
                red: {
                    1: { cost: { red: 1, any: 1 }, effect: 'Repeat a worker\'s action' },
                    2: { cost: { red: 2, any: 2 }, effect: 'Place the next player\'s worker' }
                },
                yellow: {
                    1: { cost: { yellow: 1, any: 1 }, effect: 'Double next gain' },
                    2: { cost: { yellow: 2, any: 2 }, effect: 'Gain 4 gems + others gain 1' }
                },
                blue: {
                    1: { cost: { blue: 1, any: 1 }, effect: 'Close any shop this round' },
                    2: { cost: { blue: 2, any: 2 }, effect: 'Undo the last player\'s turn' }
                },
                purple: {
                    1: { cost: { purple: 1, any: 1 }, effect: 'Take an extra turn after this one' },
                    2: { cost: { purple: 2, any: 2 }, effect: 'Needs new effect (old one moved to R3)' }
                }
            };
            
            const handlePurchase = async (shopRound) => {
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                // Check if this shop is closed
                const isShopClosed = state.players.some(player => 
                    (player.effects || []).some(effect => 
                        effect.includes(`${color.charAt(0).toUpperCase() + color.slice(1)} shop is closed this round`)
                    )
                );
                
                if (isShopClosed) {
                    alert(`${color.charAt(0).toUpperCase() + color.slice(1)} shop is closed this round!`);
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                const shop = shopData[color][shopRound];
                
                // Check if player has enough resources
                const colorRequired = shop.cost[color] || 0;
                const anyRequired = shop.cost.any || 0;
                
                if (currentPlayer.resources[color] < colorRequired) {
                    alert(`Need ${colorRequired} ${color} gems. You have ${currentPlayer.resources[color]}.`);
                    return;
                }
                
                if (anyRequired > 0) {
                    const totalAllGems = Object.values(currentPlayer.resources).reduce((sum, amount) => sum + amount, 0);
                    const totalAvailableForAny = totalAllGems - colorRequired; // Subtract the specific color requirement
                    
                    if (totalAvailableForAny < anyRequired) {
                        alert(`Need ${anyRequired} additional gems of any color. You have ${totalAvailableForAny} available.`);
                        return;
                    }
                }
                
                // Deduct the specific color cost
                const resourceCost = {};
                if (colorRequired > 0) {
                    resourceCost[color] = -colorRequired;
                }
                
                // Deduct "any" cost - let player choose colors
                if (anyRequired > 0) {
                    let remaining = anyRequired;
                    
                    while (remaining > 0) {
                        const colorOptions = ['red', 'yellow', 'blue', 'purple']
                            .filter(c => {
                                const currentAmount = currentPlayer.resources[c];
                                const alreadySpent = resourceCost[c] ? -resourceCost[c] : 0;
                                return (currentAmount - alreadySpent) > 0;
                            })
                            .map(c => {
                                const currentAmount = currentPlayer.resources[c];
                                const alreadySpent = resourceCost[c] ? -resourceCost[c] : 0;
                                const available = currentAmount - alreadySpent;
                                return {
                                    label: `${c.charAt(0).toUpperCase() + c.slice(1)} (${available} available)`,
                                    value: c
                                };
                            });
                        
                        if (colorOptions.length === 0) break;
                        
                        const choice = await showChoice(dispatch, 
                            `Choose color to spend (${remaining} more needed)`, 
                            colorOptions
                        );
                        
                        if (choice) {
                            resourceCost[choice] = (resourceCost[choice] || 0) - 1;
                            remaining -= 1;
                        } else {
                            // If cancelled, auto-select first available
                            const autoChoice = colorOptions[0].value;
                            resourceCost[autoChoice] = (resourceCost[autoChoice] || 0) - 1;
                            remaining -= 1;
                        }
                    }
                }
                
                dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                
                // Apply the shop effect immediately
                switch(`${color}${shopRound}`) {
                    case 'red1':
                        // Repeat a worker's action - execute immediately
                        await executeRepeatAction(currentPlayer, dispatch, state, state.gameLayers);
                        break;
                    case 'red2':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Can place the next player\'s worker'
                        });
                        break;
                    case 'yellow1':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Next gain will be doubled'
                        });
                        break;
                    case 'yellow2':
                        // Gain 4 gems any colors + everyone gains gem - execute immediately
                        await executeYellow2Shop(currentPlayer, dispatch, state);
                        break;
                    case 'blue1':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Can close any shop this round'
                        });
                        break;
                    case 'blue2':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Can undo the last player\'s turn'
                        });
                        break;
                    case 'purple1':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'Will take an extra turn after this one'
                        });
                        break;
                    case 'purple2':
                        dispatch({
                            type: 'ADD_EFFECT',
                            playerId: currentPlayer.id,
                            effect: 'TBD effect'
                        });
                        break;
                }
                
                const message = `Player ${currentPlayer.id}: Bought ${color} R${shopRound} shop`;
                dispatch({ type: 'ADD_LOG', message });
                console.log(message);
            };
            
            const round1Shop = shopData[color][1];
            const round2Shop = shopData[color][2];
            
            return React.createElement('div', { 
                className: 'bg-gradient-to-br from-yellow-100 to-yellow-200 border-2 border-yellow-400 rounded-lg p-3 shadow-md hover:shadow-lg transition-all' 
            }, [
                React.createElement('div', { key: 'title', className: 'text-center font-bold text-yellow-700 mb-2 text-sm' }, `ðŸ›’ ${color.charAt(0).toUpperCase() + color.slice(1)}`),
                
                React.createElement('div', { key: 'round1', className: 'text-xs mb-2' }, [
                    React.createElement('div', { key: 'desc', className: 'mb-1 text-yellow-800' }, 
                        `R1: ${round1Shop.effect.length > 20 ? round1Shop.effect.substring(0, 20) + '...' : round1Shop.effect}`),
                    React.createElement('button', {
                        key: 'btn',
                        onClick: () => handlePurchase(1),
                        className: 'bg-yellow-600 hover:bg-yellow-700 text-white px-2 py-1 rounded text-xs transition-colors w-full'
                    }, 'Buy R1')
                ]),
                
                round >= 2 && React.createElement('div', { key: 'round2', className: 'text-xs' }, [
                    React.createElement('div', { key: 'desc', className: 'mb-1 text-yellow-800' }, 
                        `R2: ${round2Shop.effect.length > 20 ? round2Shop.effect.substring(0, 20) + '...' : round2Shop.effect}`),
                    React.createElement('button', {
                        key: 'btn',
                        onClick: () => handlePurchase(2),
                        className: 'bg-yellow-600 hover:bg-yellow-700 text-white px-2 py-1 rounded text-xs transition-colors w-full',
                        disabled: color === 'purple'
                    }, color === 'purple' ? 'TBD' : 'Buy R2')
                ])
            ]);
        }

        // Victory Shop Component
        function VictoryShop({ color }) {
            const { state, dispatch } = useGame();
            
            const shopData = {
                red: { cost: { red: 5 }, vp: 3 },
                yellow: { cost: { any: 7 }, vp: 3 },
                blue: { cost: { blue: 5 }, vp: 3 },
                purple: { cost: { purple: 5 }, vp: 3 }
            };
            
            const handlePurchase = () => {
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                const shop = shopData[color];
                
                if (color === 'yellow') {
                    const totalGems = Object.values(currentPlayer.resources).reduce((sum, count) => sum + count, 0);
                    if (totalGems < 7) {
                        alert(`Need 7 gems of any color. You have ${totalGems}.`);
                        return;
                    }
                    
                    // Deduct 7 gems proportionally
                    const resourceCost = {};
                    let remaining = 7;
                    const colors = ['red', 'yellow', 'blue', 'purple'];
                    
                    for (const color of colors) {
                        const take = Math.min(currentPlayer.resources[color], remaining);
                        if (take > 0) {
                            resourceCost[color] = -take; // Negative to subtract
                        }
                        remaining -= take;
                        if (remaining === 0) break;
                    }
                    
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                } else {
                    const requiredAmount = shop.cost[color];
                    if (currentPlayer.resources[color] < requiredAmount) {
                        alert(`Need ${requiredAmount} ${color} gems. You have ${currentPlayer.resources[color]}.`);
                        return;
                    }
                    
                    const resourceCost = {};
                    resourceCost[color] = -requiredAmount; // Negative to subtract
                    dispatch({ type: 'UPDATE_RESOURCES', playerId: currentPlayer.id, resources: resourceCost });
                }
                
                dispatch({ type: 'ADD_VICTORY_POINTS', playerId: currentPlayer.id, points: shop.vp });
                console.log(`Player ${currentPlayer.id} bought 3 victory points from ${color} shop`);
            };
            
            const shop = shopData[color];
            
            return React.createElement('div', { 
                className: 'bg-gradient-to-br from-green-100 to-green-200 border-2 border-green-400 rounded-lg p-3 shadow-md hover:shadow-lg transition-all' 
            }, [
                React.createElement('div', { key: 'title', className: 'text-center font-bold text-green-700 mb-2 text-sm' }, 'ðŸ† Victory'),
                React.createElement('div', { key: 'cost', className: 'text-center text-xs mb-2 text-green-800' }, 
                    React.createElement('strong', {}, 
                        `${color === 'yellow' ? '7 Any' : `5 ${color.charAt(0).toUpperCase() + color.slice(1)}`}: ${shop.vp} VP`)),
                React.createElement('div', { key: 'button', className: 'text-center' }, 
                    React.createElement('button', {
                        onClick: handlePurchase,
                        className: 'bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-xs font-bold shadow-md hover:shadow-lg transform hover:scale-105 transition-all'
                    }, 'Buy'))
            ]);
        }

        // All available game layers
        const allGameLayers = {
            red: {
                title: "Worker Manipulation",
                icon: "ðŸ”´",
                actions: [
                    { id: 'gain3red', title: 'Gain 3 Red', description: 'Round 1', round: 1 },
                    { id: 'gain2red', title: 'Gain 2 Red', description: 'Round 1', round: 1 },
                    { id: 'redHybrid1', title: '+1 Red + Swap Workers', description: '(Both players get actions)', round: 1 },
                    { id: 'redRepeatAction', title: 'Repeat an Action', description: '(That one of your workers is on)', round: 1 },
                    { id: 'forceRedPlacement', title: 'Other Players Must Place on Red', description: '(Until red layer is full)', round: 2 },
                    { id: 'redHybrid2', title: '+1 Red + Swap Workers', description: '(Only you get action)', round: 2 }
                ]
            },
            yellow: {
                title: "Resource Manipulation", 
                icon: "ðŸŸ¡",
                actions: [
                    { id: 'gain3yellow', title: 'Gain 3 Different Gems', description: 'Round 1', round: 1 },
                    { id: 'gain2yellow', title: 'Gain 2 Different Gems', description: 'Round 1', round: 1 },
                    { id: 'stealGem', title: 'Steal 1 Gem', description: 'Round 1', round: 1 },
                    { id: 'yellowHybrid1', title: '+1 Yellow + Trade 2 Gems for 2 Any', description: '(For 2 any colors)', round: 1 },
                    { id: 'steal2Gems', title: 'Steal 2 Gems', description: '(From any player)', round: 2 },
                    { id: 'yellowHybrid2', title: '+1 Yellow + Double Next Gain', description: '(Doesn\'t stack with shop)', round: 2 }
                ]
            },
            blue: {
                title: "Defense",
                icon: "ðŸ”µ", 
                actions: [
                    { id: 'gain3blue', title: 'Gain 3 Blue', description: 'Round 1', round: 1 },
                    { id: 'gain2blue', title: 'Gain 2 Blue', description: 'Round 1', round: 1 },
                    { id: 'blueHybrid1', title: '+1 Blue + Move Worker', description: '(They don\'t get benefit)', round: 1 },
                    { id: 'everyoneReturn1', title: 'Others Return 1 Gem Each', description: 'Round 1', round: 1 },
                    { id: 'blueHybrid2', title: '+1 Blue + Move 2 Workers', description: '(They don\'t get benefit)', round: 2 },
                    { id: 'everyoneReturn2', title: 'Others Return 2 Gems Each', description: 'Round 2', round: 2 }
                ]
            },
            purple: {
                title: "Timing/Order",
                icon: "ðŸŸ£",
                actions: [
                    { id: 'gain3purple', title: 'Gain 3 Purple', description: 'Round 1', round: 1 },
                    { id: 'gain2purple', title: 'Gain 2 Purple', description: 'Round 1', round: 1 },
                    { id: 'playTwoWorkers', title: 'Play Your Next Two Workers', description: 'Round 1', round: 1 },
                    { id: 'purpleShopHybrid', title: '+1 Purple + Any Round 1 Shop Benefit', description: 'Round 1', round: 1 },
                    { id: 'extraWorkers', title: 'Gain 2 Extra Workers Next Round', description: 'Round 2', round: 2 },
                    { id: 'purpleHybrid2', title: '+1 Purple + Choose Turn Order', description: '(For next round)', round: 2 }
                ]
            },
        };
        
        // Function to select random layers based on player count
        function selectGameLayers(playerCount) {
            const availableLayers = Object.keys(allGameLayers);
            const shuffled = [...availableLayers].sort(() => Math.random() - 0.5);
            const selectedLayerKeys = shuffled.slice(0, playerCount);
            
            const gameData = {};
            selectedLayerKeys.forEach(key => {
                gameData[key] = allGameLayers[key];
            });
            
            return gameData;
        }

        // Main Game Board Component
        function GameBoard() {
            const { state, dispatch } = useGame();
            
            // Sync state to Firebase whenever state changes
            useEffect(() => {
                if (state.roomCode && state.gameStarted) {
                    syncGameState(state.roomCode, {
                        currentPlayer: state.currentPlayer,
                        turnDirection: state.turnDirection,
                        players: state.players,
                        occupiedSpaces: state.occupiedSpaces,
                        round: state.round,
                        turnOrder: state.turnOrder,
                        workerPlacedThisTurn: state.workerPlacedThisTurn,
                        workersToPlace: state.workersToPlace,
                        actionLog: state.actionLog,
                        gameStarted: state.gameStarted,
                        gameLayers: state.gameLayers
                    });
                }
            }, [state.currentPlayer, state.players, state.occupiedSpaces, state.round, state.actionLog, state.workersToPlace, state.gameLayers]);
            
            const handleEndTurn = async () => {
                // Validate multiplayer turn
                if (state.roomCode && state.myPlayerId !== state.currentPlayer) {
                    alert('It\'s not your turn!');
                    return;
                }
                
                const currentPlayer = state.players.find(p => p.id === state.currentPlayer);
                
                if (state.workersToPlace > 0 && currentPlayer.workersLeft > 0) {
                    const workersRemaining = state.workersToPlace;
                    const confirmSkip = await showConfirm(dispatch, 
                        'End Turn Early?',
                        `You can still place ${workersRemaining} more worker${workersRemaining > 1 ? 's' : ''} this turn. Are you sure you want to end your turn?`
                    );
                    if (!confirmSkip) return;
                }
                
                dispatch({ type: 'END_TURN' });
            };
            
            const handleAdvanceRound = () => {
                if (state.round < 3) {
                    dispatch({ type: 'ADVANCE_ROUND' });
                } else {
                    alert('Game is already at Round 3 (final round)');
                }
            };
            
            const handleResetGame = () => {
                dispatch({ type: 'RESET_GAME' });
            };
            
            // If no layers selected yet, show loading or use default layers for local play
            if (!state.gameLayers) {
                console.log('No game layers found. State:', {
                    roomCode: state.roomCode,
                    gameStarted: state.gameStarted,
                    gameLayers: state.gameLayers
                });
                if (!state.roomCode) {
                    // Local play - use 4 layers
                    console.log('Local play - selecting 4 layers');
                    const selectedLayers = selectGameLayers(4);
                    dispatch({ type: 'SET_GAME_LAYERS', layers: selectedLayers });
                }
                return React.createElement('div', { 
                    className: 'min-h-screen flex items-center justify-center' 
                }, React.createElement('div', {
                    className: 'text-center glass rounded-xl p-8'
                }, [
                    React.createElement('h2', { key: 'title', className: 'text-2xl font-bold mb-4' }, 'Setting up game layers...'),
                    React.createElement('div', { key: 'spinner', className: 'animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto' }),
                    React.createElement('div', { key: 'debug', className: 'text-sm text-gray-600 mt-4' }, 
                        `Debug: roomCode=${state.roomCode}, gameStarted=${state.gameStarted}`)
                ]));
            }
            
            console.log('GameBoard rendering with layers:', Object.keys(state.gameLayers));

            const totalWorkers = state.players.reduce((sum, p) => sum + p.workersLeft, 0);
            const totalSpaces = Object.values(state.gameLayers).reduce((sum, layer) => 
                sum + layer.actions.filter(action => action.round <= state.round).length, 0
            );
            
            return React.createElement('div', { className: 'min-h-screen p-4' }, [
                React.createElement('div', { key: 'container', className: 'max-w-7xl mx-auto game-board' }, [
                    // Header
                    React.createElement('div', { key: 'header', className: 'text-center mb-8' }, [
                        React.createElement('h1', { 
                            key: 'title', 
                            className: 'text-5xl font-bold text-gray-800 mb-6 text-shadow' 
                        }, `Patrons - Round ${state.round}`),
                        React.createElement('div', { key: 'info', className: 'glass rounded-xl shadow-xl p-6 mb-6 max-w-2xl mx-auto' }, [
                            React.createElement('div', { 
                                key: 'current', 
                                className: 'text-2xl font-bold text-blue-600 mb-3' 
                            }, `Current Player: Player ${state.currentPlayer}`),
                            React.createElement('div', { 
                                key: 'workers-to-place', 
                                className: 'text-lg text-purple-600 font-semibold mb-2' 
                            }, `Workers to place: ${state.workersToPlace}`),
                            React.createElement('div', { key: 'stats', className: 'text-gray-700 text-lg' }, 
                                `Round ${state.round}: ${totalWorkers} Workers | ${totalSpaces} Action Spaces`),
                            React.createElement('div', { key: 'order', className: 'text-sm text-gray-600 mt-2' }, 
                                `Snake Draft: ${state.turnOrder.join(' â†’ ')} â†’ ${state.turnOrder.slice().reverse().join(' â†’ ')}`)
                        ])
                    ]),
                    
                    // Player Cards
                    React.createElement('div', { key: 'players', className: 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8' }, 
                        state.players.map(player => 
                            React.createElement(PlayerCard, {
                                key: player.id,
                                player,
                                isCurrentPlayer: player.id === state.currentPlayer,
                                onEndTurn: handleEndTurn
                            })
                        )
                    ),
                    
                    // Game Layers
                    React.createElement('div', { key: 'layers', className: 'space-y-4 mb-6' }, 
                        Object.entries(state.gameLayers).map(([color, data]) => 
                            React.createElement(GameLayer, {
                                key: color,
                                color,
                                title: data.title,
                                icon: data.icon,
                                actions: data.actions,
                                round: state.round
                            })
                        )
                    ),
                    
                    // Control Buttons
                    React.createElement('div', { key: 'controls', className: 'text-center glass rounded-lg p-4 shadow-lg' }, [
                        React.createElement('button', {
                            key: 'advance',
                            onClick: handleAdvanceRound,
                            className: 'bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold py-2 px-4 rounded-lg mr-3 shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                        }, `Advance to Round ${Math.min(state.round + 1, 3)}`),
                        React.createElement('button', {
                            key: 'reset',
                            onClick: handleResetGame,
                            className: 'bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:shadow-lg transform hover:scale-105 transition-all duration-200'
                        }, 'Reset Game'),
                        React.createElement('div', { key: 'instructions', className: 'text-gray-600 mt-3 text-sm' }, 
                            'Place worker â†’ Buy from shops â†’ End turn (button under current player)'),
                        state.actionLog.length > 0 && React.createElement('div', { key: 'action-log', className: 'mt-4 p-3 bg-gray-100 rounded-lg max-h-32 overflow-y-auto' }, [
                            React.createElement('div', { key: 'log-title', className: 'font-bold text-gray-700 mb-2 text-sm' }, 'Action Log (Last 10):'),
                            ...state.actionLog.map((log, index) => 
                                React.createElement('div', { 
                                    key: index, 
                                    className: 'text-xs text-gray-600 mb-1 font-mono' 
                                }, log)
                            )
                        ])
                    ])
                ]),
                // Modal System
                state.modal && React.createElement(Modal, { 
                    key: 'modal', 
                    isOpen: true, 
                    onClose: () => dispatch({ type: 'HIDE_MODAL' }) 
                }, state.modal.type === 'choice' 
                    ? React.createElement(ChoiceModal, state.modal)
                    : React.createElement(ConfirmModal, state.modal)
                )
            ]);
        }

        // Main App Component
        function App() {
            return React.createElement(GameProvider, {}, 
                React.createElement(MainApp, {})
            );
        }
        
        function MainApp() {
            const { state } = useGame();
            
            // Add error boundary
            try {
                // Show room lobby if not in a game
                if (!state.gameStarted) {
                    // If connected to a room but game hasn't started, show waiting room
                    if (state.roomCode) {
                        return React.createElement('div', { className: 'min-h-screen p-4' }, [
                            React.createElement(ConnectedPlayers, { key: 'players' }),
                            React.createElement('div', { 
                                key: 'waiting',
                                className: 'text-center mt-8' 
                            }, [
                                React.createElement('div', {
                                    key: 'spinner',
                                    className: 'animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4'
                                }),
                                React.createElement('h2', {
                                    key: 'text',
                                    className: 'text-xl text-gray-600'
                                }, state.isHost ? 'Waiting for you to start the game...' : 'Waiting for host to start the game...')
                            ])
                        ]);
                    }
                    
                    // Show room lobby for initial connection
                    return React.createElement(RoomLobby, {});
                }
                
                // Show game board with multiplayer info if in a room
                return React.createElement('div', { className: 'min-h-screen' }, [
                    state.roomCode && React.createElement(ConnectedPlayers, { key: 'players' }),
                    React.createElement(GameBoard, { key: 'game' })
                ]);
            } catch (error) {
                console.error('Render error:', error);
                console.error('Error stack:', error.stack);
                console.error('Game state at error:', state);
                return React.createElement('div', { 
                    className: 'min-h-screen flex items-center justify-center p-4' 
                }, React.createElement('div', {
                    className: 'glass rounded-xl p-8 text-center'
                }, [
                    React.createElement('h1', { 
                        key: 'title',
                        className: 'text-2xl font-bold text-red-600 mb-4' 
                    }, 'Game Error'),
                    React.createElement('p', { 
                        key: 'message',
                        className: 'text-gray-600 mb-4' 
                    }, 'Something went wrong. Check browser console for details.'),
                    React.createElement('div', {
                        key: 'error-details',
                        className: 'text-sm text-gray-500 mb-4 p-2 bg-gray-100 rounded'
                    }, `Error: ${error.message}`),
                    React.createElement('button', {
                        key: 'reload',
                        onClick: () => window.location.reload(),
                        className: 'bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded'
                    }, 'Reload Game')
                ]));
            }
        }

        // Render the app
        ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
</body>
</html>